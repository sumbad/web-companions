(()=>{"use strict";var __webpack_modules__={216:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n;// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t;const i=window,s=i.trustedTypes,e=s?s.createPolicy("lit-html",{createHTML:t=>t}):void 0,o="$lit$",n=`lit$${(Math.random()+"").slice(9)}$`,l="?"+n,h=`<${l}>`,r=document,u=()=>r.createComment(""),d=t=>null===t||"object"!=typeof t&&"function"!=typeof t,c=Array.isArray,v=t=>c(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),a="[ \\t\\n\\f\\r]",f=/<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,_=/--\x3e/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\\\s"\'>=/]+)(${a}*=${a}*(?:[^ \\t\\n\\f\\r"\'\\`<>=]|("|\')|))|$)`,"g"),g=/\'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=w(1),b=w(2),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1);function P(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==e?e.createHTML(i):i}const V=(t,i)=>{const s=t.length-1,e=[];let l,r=2===i?"<svg>":"",u=f;for(let i=0;i<s;i++){const s=t[i];let d,c,v=-1,a=0;for(;a<s.length&&(u.lastIndex=a,c=u.exec(s),null!==c);)a=u.lastIndex,u===f?"!--"===c[1]?u=_:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(l=RegExp("</"+c[2],"g")),u=p):void 0!==c[3]&&(u=p):u===p?">"===c[0]?(u=null!=l?l:f,v=-1):void 0===c[1]?v=-2:(v=u.lastIndex-c[2].length,d=c[1],u=void 0===c[3]?p:\'"\'===c[3]?$:g):u===$||u===g?u=p:u===_||u===m?u=f:(u=p,l=void 0);const w=u===p&&t[i+1].startsWith("/>")?" ":"";r+=u===f?s+h:v>=0?(e.push(d),s.slice(0,v)+o+s.slice(v)+n+w):s+n+(-2===v?(e.push(void 0),i):w)}return[P(t,r+(t[s]||"<?>")+(2===i?"</svg>":"")),e]};class N{constructor({strings:t,_$litType$:i},e){let h;this.parts=[];let r=0,d=0;const c=t.length-1,v=this.parts,[a,f]=V(t,i);if(this.el=N.createElement(a,e),C.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes)}for(;null!==(h=C.nextNode())&&v.length<c;){if(1===h.nodeType){if(h.hasAttributes()){const t=[];for(const i of h.getAttributeNames())if(i.endsWith(o)||i.startsWith(n)){const s=f[d++];if(t.push(i),void 0!==s){const t=h.getAttribute(s.toLowerCase()+o).split(n),i=/([.?@])?(.*)/.exec(s);v.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?H:"?"===i[1]?L:"@"===i[1]?z:k})}else v.push({type:6,index:r})}for(const i of t)h.removeAttribute(i)}if(y.test(h.tagName)){const t=h.textContent.split(n),i=t.length-1;if(i>0){h.textContent=s?s.emptyScript:"";for(let s=0;s<i;s++)h.append(t[s],u()),C.nextNode(),v.push({type:2,index:++r});h.append(t[i],u())}}}else if(8===h.nodeType)if(h.data===l)v.push({type:2,index:r});else{let t=-1;for(;-1!==(t=h.data.indexOf(n,t+1));)v.push({type:7,index:r}),t+=n.length-1}r++}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function S(t,i,s=t,e){var o,n,l,h;if(i===T)return i;let r=void 0!==e?null===(o=s._$Co)||void 0===o?void 0:o[e]:s._$Cl;const u=d(i)?void 0:i._$litDirective$;return(null==r?void 0:r.constructor)!==u&&(null===(n=null==r?void 0:r._$AO)||void 0===n||n.call(r,!1),void 0===u?r=void 0:(r=new u(t),r._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Co)&&void 0!==l?l:h._$Co=[])[e]=r:s._$Cl=r),void 0!==r&&(i=S(t,r._$AS(t,i.values),r,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:r).importNode(s,!0);C.currentNode=o;let n=C.nextNode(),l=0,h=0,u=e[0];for(;void 0!==u;){if(l===u.index){let i;2===u.type?i=new R(n,n.nextSibling,this,t):1===u.type?i=new u.ctor(n,u.name,u.strings,this,t):6===u.type&&(i=new Z(n,this,t)),this._$AV.push(i),u=e[++h]}l!==(null==u?void 0:u.index)&&(n=C.nextNode(),l++)}return C.currentNode=r,o}v(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++}}class R{constructor(t,i,s,e){var o;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cp=null===(o=null==e?void 0:e.isConnected)||void 0===o||o}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cp}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===(null==t?void 0:t.nodeType)&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S(this,t,i),d(t)?t===A||null==t||""===t?(this._$AH!==A&&this._$AR(),this._$AH=A):t!==this._$AH&&t!==T&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):v(t)?this.T(t):this._(t)}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t))}_(t){this._$AH!==A&&d(this._$AH)?this._$AA.nextSibling.data=t:this.$(r.createTextNode(t)),this._$AH=t}g(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=N.createElement(P(e.h,e.h[0]),this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.v(s);else{const t=new M(o,this),i=t.u(this.options);t.v(s),this.$(i),this._$AH=t}}_$AC(t){let i=E.get(t.strings);return void 0===i&&E.set(t.strings,i=new N(t)),i}T(t){c(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new R(this.k(u()),this.k(u()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e)}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i}}setConnected(t){var i;void 0===this._$AM&&(this._$Cp=t,null===(i=this._$AP)||void 0===i||i.call(this,t))}}class k{constructor(t,i,s,e,o){this.type=1,this._$AH=A,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=A}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=S(this,t,i,0),n=!d(t)||t!==this._$AH&&t!==T,n&&(this._$AH=t);else{const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=S(this,e[s+l],i,l),h===T&&(h=this._$AH[l]),n||(n=!d(h)||h!==this._$AH[l]),h===A?t=A:t!==A&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h}n&&!e&&this.j(t)}j(t){t===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"")}}class H extends k{constructor(){super(...arguments),this.type=3}j(t){this.element[this.name]=t===A?void 0:t}}const I=s?s.emptyScript:"";class L extends k{constructor(){super(...arguments),this.type=4}j(t){t&&t!==A?this.element.setAttribute(this.name,I):this.element.removeAttribute(this.name)}}class z extends k{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5}_$AI(t,i=this){var s;if((t=null!==(s=S(this,t,i,0))&&void 0!==s?s:A)===T)return;const e=this._$AH,o=t===A&&e!==A||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==A&&(e===A||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t)}}class Z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s}get _$AU(){return this._$AM._$AU}_$AI(t){S(this,t)}}const j={O:o,P:n,A:l,C:1,M:V,L:M,D:v,R:S,I:R,V:k,H:L,N:z,U:H,F:Z},B=i.litHtmlPolyfillSupport;null==B||B(N,R),(null!==(t=i.litHtmlVersions)&&void 0!==t?t:i.litHtmlVersions=[]).push("2.7.5");const D=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new R(i.insertBefore(u(),t),t,void 0,null!=s?s:{})}return l._$AI(t),l};\n//# sourceMappingURL=lit-html.js.map\n\n;// CONCATENATED MODULE: ./packages/lit/node_modules/@web-companions/gfc/lib/utils/p.js\nfunction p_setProp(key, value) {\n    if (!this.isConnected) {\n        this.props[key] = value;\n        return;\n    }\n    if (value !== this.props[key]) {\n        this[\'__stash__\'] = {\n            ...this[\'__stash__\'],\n            [key]: value,\n        };\n    }\n    Promise.resolve({\n        then: () => {\n            let stash = this[\'__stash__\'];\n            if (stash != null) {\n                this.props = {\n                    ...this.props,\n                    ...stash,\n                };\n                stash = null;\n            }\n        },\n    });\n}\nconst p_p = {\n    req(attribute) {\n        return {\n            type: {},\n            attribute,\n        };\n    },\n    opt(attribute) {\n        return {\n            type: {},\n            attribute,\n            optional: true,\n        };\n    },\n};\n//# sourceMappingURL=p.js.map\n;// CONCATENATED MODULE: ./packages/lit/node_modules/@web-companions/gfc/lib/EG.js\nvar __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nlet actualEl = undefined;\nfunction EG_EG(config) {\n    return (func) => {\n        const constructor = build(func, (config === null || config === void 0 ? void 0 : config.props) || {}, config === null || config === void 0 ? void 0 : config.mapper, this === null || this === void 0 ? void 0 : this.getRenderFn().element);\n        return (name, options) => {\n            try {\n                customElements.define(name, constructor, options);\n            }\n            catch (e) {\n                console.warn(e);\n            }\n            const component = function (_props) {\n                if (new.target != null) {\n                    return new constructor();\n                }\n                else {\n                    return customElements.whenDefined(name).then(() => customElements.get(name));\n                }\n            };\n            component.adapter = (func, defaultProps) => func(name, defaultProps);\n            return component;\n        };\n    };\n}\nfunction build(func, props, mapper = p_setProp, render = (result) => result.value) {\n    var _a;\n    const customEl = (_a = class extends HTMLElement {\n            static get observedAttributes() {\n                return Object.values(this.attributes);\n            }\n            set props(newProps) {\n                if (newProps !== undefined && this.props !== newProps) {\n                    this._props = newProps;\n                    this.next();\n                }\n            }\n            get props() {\n                return this._props;\n            }\n            async next(props) {\n                this.props = props || this.props;\n                if (!this.isScheduledNext && this.generation != null) {\n                    this.isScheduledNext = true;\n                    const generator = await Promise.resolve(this.generation);\n                    this.isScheduledNext = false;\n                    actualEl = this;\n                    render.call(this, generator.next(this.props));\n                }\n            }\n            constructor() {\n                super();\n                this.container = this;\n                this._props = {};\n                this.isScheduledNext = false;\n                for (const pK in props) {\n                    const pV = props[pK];\n                    let attr = undefined;\n                    if (\'type\' in pV) {\n                        attr = pV.attribute;\n                    }\n                    Reflect.defineProperty(this, pK, {\n                        get: () => {\n                            return this.props[pK];\n                        },\n                        set: (value) => {\n                            mapper.apply(this, [pK, value, attr]);\n                        },\n                        enumerable: true,\n                    });\n                }\n            }\n            connectedCallback() {\n                this.generation = func.call(this, this.props);\n                actualEl = this;\n                render.call(this, this.generation.next(this.props));\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (oldValue !== newValue) {\n                    for (const [attrKey, attrName] of Object.entries(this.constructor[\'attributes\'])) {\n                        if (attrName === name && this[attrKey] !== newValue) {\n                            this[attrKey] = newValue;\n                            break;\n                        }\n                    }\n                }\n            }\n            disconnectedCallback() {\n                var _a;\n                (_a = this.generation) === null || _a === void 0 ? void 0 : _a.return();\n            }\n        },\n        __setFunctionName(_a, "customEl"),\n        _a.attributes = {},\n        _a);\n    const attrKey = \'attributes\';\n    const attributes = Reflect.get(customEl, attrKey);\n    for (const pK in props) {\n        const pV = props[pK];\n        if (\'type\' in pV && pV.attribute !== undefined) {\n            Reflect.defineProperty(customEl, attrKey, {\n                value: {\n                    ...attributes,\n                    [pK]: pV.attribute,\n                },\n                enumerable: true,\n                writable: true,\n            });\n        }\n    }\n    return customEl;\n}\nfunction EG_setElNode(nodesSymbol, key) {\n    let node = { current: null };\n    if (actualEl == null) {\n        return node;\n    }\n    if (actualEl[nodesSymbol] == null) {\n        actualEl[nodesSymbol] = {};\n    }\n    const nodes = actualEl[nodesSymbol];\n    if (nodes[key] == null) {\n        nodes[key] = node;\n    }\n    node = nodes[key];\n    return node;\n}\n//# sourceMappingURL=EG.js.map\n;// CONCATENATED MODULE: ./packages/lit/node_modules/@web-companions/gfc/lib/NG.js\n\nconst ref2Node = new WeakMap();\nfunction NG_NG(func) {\n    var _a;\n    const render = (_a = this === null || this === void 0 ? void 0 : this.getRenderFn().node) !== null && _a !== void 0 ? _a : ((result) => result.value);\n    return (ref = { current: null }) => {\n        const nodesSymbol = Symbol(\'nodes\');\n        return (props = {}) => {\n            const _ref = props.key != null ? EG_setElNode(nodesSymbol, props.key) : ref;\n            let node = ref2Node.get(_ref);\n            if (node == null) {\n                const _node = {\n                    ..._ref,\n                    props,\n                    isScheduledNext: false,\n                };\n                const generator = Reflect.apply(func, _node, [props]);\n                _node.generator = generator;\n                _node.next = async function (_props) {\n                    this.props = _props || this.props;\n                    if (!this.isScheduledNext) {\n                        this.isScheduledNext = true;\n                        const g = await Promise.resolve(generator);\n                        this.isScheduledNext = false;\n                        this.value = render.call({ container: this }, g.next(this.props));\n                    }\n                };\n                node = _node;\n                ref2Node.set(_ref, node);\n            }\n            node.props = props;\n            node.value = render.call({ container: node }, node.generator.next(props));\n            return node.value;\n        };\n    };\n}\n//# sourceMappingURL=NG.js.map\n;// CONCATENATED MODULE: ./packages/lit/node_modules/@web-companions/gfc/lib/View.js\n\n\nclass View {\n    constructor(_render) {\n        this._render = _render;\n        this.element = EG_EG;\n        this.node = NG_NG;\n    }\n    getRenderFn() {\n        return this._render;\n    }\n}\n//# sourceMappingURL=View.js.map\n;// CONCATENATED MODULE: ./packages/lit/node_modules/@web-companions/gfc/lib/index.js\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/lit-html/directive-helpers.js\n\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const{I:directive_helpers_l}=j,directive_helpers_t=o=>null===o||"object"!=typeof o&&"function"!=typeof o,directive_helpers_i={HTML:1,SVG:2},directive_helpers_n=(o,l)=>void 0===l?void 0!==(null==o?void 0:o._$litType$):(null==o?void 0:o._$litType$)===l,directive_helpers_d=o=>void 0!==(null==o?void 0:o._$litDirective$),directive_helpers_v=o=>null==o?void 0:o._$litDirective$,directive_helpers_e=o=>void 0===o.strings,directive_helpers_c=()=>document.createComment(""),directive_helpers_r=(o,t,i)=>{var n;const d=o._$AA.parentNode,v=void 0===t?o._$AB:t._$AA;if(void 0===i){const t=d.insertBefore(directive_helpers_c(),v),n=d.insertBefore(directive_helpers_c(),v);i=new directive_helpers_l(t,n,o,o.options)}else{const l=i._$AB.nextSibling,t=i._$AM,e=t!==o;if(e){let l;null===(n=i._$AQ)||void 0===n||n.call(i,o),i._$AM=o,void 0!==i._$AP&&(l=o._$AU)!==t._$AU&&i._$AP(l)}if(l!==v||e){let o=i._$AA;for(;o!==l;){const l=o.nextSibling;d.insertBefore(o,v),o=l}}}return i},directive_helpers_u=(o,l,t=o)=>(o._$AI(l,t),o),directive_helpers_f={},directive_helpers_s=(o,l=directive_helpers_f)=>o._$AH=l,directive_helpers_m=o=>o._$AH,directive_helpers_p=o=>{var l;null===(l=o._$AP)||void 0===l||l.call(o,!1,!0);let t=o._$AA;const i=o._$AB.nextSibling;for(;t!==i;){const o=t.nextSibling;t.remove(),t=o}},directive_helpers_a=o=>{o._$AR()};\n//# sourceMappingURL=directive-helpers.js.map\n\n;// CONCATENATED MODULE: ./node_modules/lit-html/directive.js\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst directive_t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},directive_e=t=>(...e)=>({_$litDirective$:t,values:e});class directive_i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}\n//# sourceMappingURL=directive.js.map\n\n;// CONCATENATED MODULE: ./node_modules/lit-html/async-directive.js\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const async_directive_s=(i,t)=>{var e,o;const r=i._$AN;if(void 0===r)return!1;for(const i of r)null===(o=(e=i)._$AO)||void 0===o||o.call(e,t,!1),async_directive_s(i,t);return!0},async_directive_o=i=>{let t,e;do{if(void 0===(t=i._$AM))break;e=t._$AN,e.delete(i),i=t}while(0===(null==e?void 0:e.size))},async_directive_r=i=>{for(let t;t=i._$AM;i=t){let e=t._$AN;if(void 0===e)t._$AN=e=new Set;else if(e.has(i))break;e.add(i),async_directive_l(t)}};function async_directive_n(i){void 0!==this._$AN?(async_directive_o(this),this._$AM=i,async_directive_r(this)):this._$AM=i}function async_directive_h(i,t=!1,e=0){const r=this._$AH,n=this._$AN;if(void 0!==n&&0!==n.size)if(t)if(Array.isArray(r))for(let i=e;i<r.length;i++)async_directive_s(r[i],!1),async_directive_o(r[i]);else null!=r&&(async_directive_s(r,!1),async_directive_o(r));else async_directive_s(this,i)}const async_directive_l=i=>{var t,s,o,r;i.type==directive_t.CHILD&&(null!==(t=(o=i)._$AP)&&void 0!==t||(o._$AP=async_directive_h),null!==(s=(r=i)._$AQ)&&void 0!==s||(r._$AQ=async_directive_n))};class async_directive_c extends directive_i{constructor(){super(...arguments),this._$AN=void 0}_$AT(i,t,e){super._$AT(i,t,e),async_directive_r(this),this.isConnected=i._$AU}_$AO(i,t=!0){var e,r;i!==this.isConnected&&(this.isConnected=i,i?null===(e=this.reconnected)||void 0===e||e.call(this):null===(r=this.disconnected)||void 0===r||r.call(this)),t&&(async_directive_s(this,i),async_directive_o(this))}setValue(t){if(directive_helpers_e(this._$Ct))this._$Ct._$AI(t,this);else{const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0)}}disconnected(){}reconnected(){}}\n//# sourceMappingURL=async-directive.js.map\n\n;// CONCATENATED MODULE: ./packages/lit/lib/lit.view.js\n\n\n\n\nclass RenderNode extends async_directive_c {\n  render(tpl, ref) {\n    ref.current = this;\n    return tpl;\n  }\n}\nconst renderNodeDirective = directive_e(RenderNode);\nfunction renderNode(tpl, ref) {\n  if (ref.current instanceof HTMLElement) {\n    D(tpl, ref.current);\n    return undefined;\n  }\n  if (ref.current instanceof RenderNode && ref.current.isConnected) {\n    ref.current.setValue(tpl);\n  }\n  return renderNodeDirective(tpl, ref);\n}\nconst litView = new View({\n  element(result) {\n    D(result.value, this.container);\n  },\n  node(result) {\n    return renderNode(result.value, this.container);\n  }\n});\n;// CONCATENATED MODULE: ./packages/lit/lib/index.js\n\n;// CONCATENATED MODULE: ./packages/h/lib/style.js\nconst css = String.raw;\nfunction setStyle(style, node, styleId) {\n  if (window.ShadowRoot && \'adoptedStyleSheets\' in Document.prototype && \'replace\' in CSSStyleSheet.prototype && node instanceof ShadowRoot) {\n    const sheet = new CSSStyleSheet();\n    sheet[\'replaceSync\'](style);\n    node[\'adoptedStyleSheets\'] = [sheet];\n  } else {\n    const selector = `style${styleId != null ? `#${styleId}` : \'\'}`;\n    let styleEl = node.querySelector(selector);\n    if (styleEl == null) {\n      styleEl = document.createElement(\'style\');\n      if (styleId != null) {\n        styleEl.setAttribute(\'id\', styleId);\n      }\n      styleEl.innerHTML = style;\n      node.insertBefore(styleEl, node.firstChild);\n    } else {\n      styleEl.innerHTML = style;\n    }\n  }\n}\n;// CONCATENATED MODULE: ./packages/gfc/lib/utils/p.js\nfunction utils_p_setProp(key, value) {\n  if (!this.isConnected) {\n    this.props[key] = value;\n    return;\n  }\n  if (value !== this.props[key]) {\n    this[\'__stash__\'] = {\n      ...this[\'__stash__\'],\n      [key]: value\n    };\n  }\n  Promise.resolve({\n    then: () => {\n      let stash = this[\'__stash__\'];\n      if (stash != null) {\n        this.props = {\n          ...this.props,\n          ...stash\n        };\n        stash = null;\n      }\n    }\n  });\n}\nconst utils_p_p = {\n  req(attribute) {\n    return {\n      type: {},\n      attribute\n    };\n  },\n  opt(attribute) {\n    return {\n      type: {},\n      attribute,\n      optional: true\n    };\n  }\n};\n;// CONCATENATED MODULE: ./packages/gfc/lib/NG.js\n\nconst NG_ref2Node = new WeakMap();\nconst NG_getRef2Node = () => NG_ref2Node;\nfunction lib_NG_NG(func) {\n  var _a;\n  const render = (_a = this === null || this === void 0 ? void 0 : this.getRenderFn().node) !== null && _a !== void 0 ? _a : result => result.value;\n  return (ref = {\n    current: null\n  }) => {\n    const nodesSymbol = Symbol("nodes");\n    return (props = {}) => {\n      const _ref = setElNode(nodesSymbol, ref, props.key);\n      let node = NG_ref2Node.get(_ref);\n      if (node == null) {\n        const _node = {\n          ..._ref,\n          props,\n          isScheduledNext: false\n        };\n        const generator = Reflect.apply(func, _node, [props]);\n        _node.generator = generator;\n        _node.next = async function (_props) {\n          this.props = _props || this.props;\n          if (!this.isScheduledNext) {\n            this.isScheduledNext = true;\n            const g = await Promise.resolve(generator);\n            this.isScheduledNext = false;\n            this.value = render.call({\n              container: this\n            }, g.next(this.props));\n          }\n        };\n        node = _node;\n        NG_ref2Node.set(_ref, node);\n      }\n      node.props = props;\n      node.value = render.call({\n        container: node\n      }, node.generator.next(props));\n      return node.value;\n    };\n  };\n}\n;// CONCATENATED MODULE: ./packages/gfc/lib/EG.js\nvar EG_setFunctionName = undefined && undefined.__setFunctionName || function (f, name, prefix) {\n  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n  return Object.defineProperty(f, "name", {\n    configurable: true,\n    value: prefix ? "".concat(prefix, " ", name) : name\n  });\n};\n\n\nlet EG_actualEl = null;\nfunction lib_EG_EG(config) {\n  return func => {\n    const constructor = EG_build(func, (config === null || config === void 0 ? void 0 : config.props) || {}, config === null || config === void 0 ? void 0 : config.mapper, this === null || this === void 0 ? void 0 : this.getRenderFn().element);\n    return (name, options) => {\n      try {\n        customElements.define(name, constructor, options);\n      } catch (e) {\n        console.warn(e);\n      }\n      const component = function (_props) {\n        if (new.target != null) {\n          return new constructor();\n        } else {\n          return customElements.whenDefined(name).then(() => customElements.get(name));\n        }\n      };\n      component.adapter = (func, defaultProps) => func(name, defaultProps);\n      return component;\n    };\n  };\n}\nfunction EG_build(func, props, mapper = setProp, render = result => result.value) {\n  var _a;\n  const customEl = (_a = class extends HTMLElement {\n    static get observedAttributes() {\n      return Object.values(this.attributes);\n    }\n    set props(newProps) {\n      if (newProps !== undefined && this.props !== newProps) {\n        this._props = newProps;\n        this.next();\n      }\n    }\n    get props() {\n      return this._props;\n    }\n    async next(props) {\n      this.props = props || this.props;\n      if (!this.isScheduledNext && this.generation != null) {\n        this.isScheduledNext = true;\n        const generator = await Promise.resolve(this.generation);\n        this.isScheduledNext = false;\n        EG_actualEl = this;\n        render.call(this, generator.next(this.props));\n      }\n    }\n    constructor() {\n      super();\n      this.container = this;\n      this.__innerNodes = new Set();\n      this._props = {};\n      this.isScheduledNext = false;\n      for (const pK in props) {\n        const pV = props[pK];\n        let attr = undefined;\n        if ("type" in pV) {\n          attr = pV.attribute;\n        }\n        Reflect.defineProperty(this, pK, {\n          get: () => {\n            return this.props[pK];\n          },\n          set: value => {\n            mapper.apply(this, [pK, value, attr]);\n          },\n          enumerable: true\n        });\n      }\n    }\n    connectedCallback() {\n      this.generation = func.call(this, this.props);\n      EG_actualEl = this;\n      render.call(this, this.generation.next(this.props));\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (oldValue !== newValue) {\n        for (const [attrKey, attrName] of Object.entries(this.constructor["attributes"])) {\n          if (attrName === name && this[attrKey] !== newValue) {\n            this[attrKey] = newValue;\n            break;\n          }\n        }\n      }\n    }\n    disconnectedCallback() {\n      var _a;\n      const ref2Node = getRef2Node();\n      this.__innerNodes.forEach(it => {\n        var _a;\n        const node = ref2Node.get(it);\n        if (node != null) {\n          (_a = node.generator) === null || _a === void 0 ? void 0 : _a.return();\n          ref2Node.delete(it);\n        }\n      });\n      (_a = this.generation) === null || _a === void 0 ? void 0 : _a.return();\n    }\n  }, EG_setFunctionName(_a, "customEl"), _a.attributes = {}, _a);\n  const attrKey = "attributes";\n  const attributes = Reflect.get(customEl, attrKey);\n  for (const pK in props) {\n    const pV = props[pK];\n    if ("type" in pV && pV.attribute !== undefined) {\n      Reflect.defineProperty(customEl, attrKey, {\n        value: {\n          ...attributes,\n          [pK]: pV.attribute\n        },\n        enumerable: true,\n        writable: true\n      });\n    }\n  }\n  return customEl;\n}\nfunction lib_EG_setElNode(nodesSymbol, ref, key) {\n  if (ref.current != null) {\n    return ref;\n  }\n  let node = {\n    current: null\n  };\n  if (EG_actualEl == null) {\n    return node;\n  }\n  if (key == null) {\n    EG_actualEl.__innerNodes.add(ref);\n    return ref;\n  }\n  if (EG_actualEl[nodesSymbol] == null) {\n    EG_actualEl[nodesSymbol] = {};\n  }\n  const nodes = EG_actualEl[nodesSymbol];\n  if (nodes[key] == null) {\n    EG_actualEl.__innerNodes.add(node);\n    nodes[key] = node;\n  }\n  return nodes[key];\n}\n;// CONCATENATED MODULE: ./packages/gfc/lib/View.js\n\n\nclass View_View {\n  constructor(_render) {\n    this._render = _render;\n    this.element = EG;\n    this.node = NG;\n  }\n  getRenderFn() {\n    return this._render;\n  }\n}\n;// CONCATENATED MODULE: ./packages/gfc/lib/index.js\n\n\n\n\n;// CONCATENATED MODULE: ./node_modules/lit-html/directives/ref.js\n\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const ref_e=()=>new ref_o;class ref_o{}const ref_h=new WeakMap,ref_n=directive_e(class extends async_directive_c{render(t){return A}update(t,[s]){var e;const o=s!==this.G;return o&&void 0!==this.G&&this.ot(void 0),(o||this.rt!==this.lt)&&(this.G=s,this.ct=null===(e=t.options)||void 0===e?void 0:e.host,this.ot(this.lt=t.element)),A}ot(i){var t;if("function"==typeof this.G){const s=null!==(t=this.ct)&&void 0!==t?t:globalThis;let e=ref_h.get(s);void 0===e&&(e=new WeakMap,ref_h.set(s,e)),void 0!==e.get(this.G)&&this.G.call(this.ct,void 0),e.set(this.G,i),void 0!==i&&this.G.call(this.ct,i)}else this.G.value=i}get rt(){var i,t,s;return"function"==typeof this.G?null===(t=ref_h.get(null!==(i=this.ct)&&void 0!==i?i:globalThis))||void 0===t?void 0:t.get(this.G):null===(s=this.G)||void 0===s?void 0:s.value}disconnected(){this.rt===this.lt&&this.ot(void 0)}reconnected(){this.ot(this.lt)}});\n//# sourceMappingURL=ref.js.map\n\n// EXTERNAL MODULE: ./www/src/views/sidemenu/styles/sidemenu.css\nvar sidemenu = __webpack_require__(278);\n;// CONCATENATED MODULE: ./www/src/views/sidemenu/sidemenu.element.tsx\nvar _templateObject, _templateObject2, _templateObject3;\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\n\n\n\n\n\n/**\n * Side menu web component\n */\nvar sidemenuElement = litView.element({\n  props: {\n    /** placeholder text for search input */\n    searchPlaceholder: utils_p_p.opt("search-placeholder"),\n    /** menu data */\n    data: utils_p_p.req(),\n    /** last selected menu item */\n    activeMenuItem: utils_p_p.req(),\n    // EVENTS:\n    onchangeActive: utils_p_p.opt()\n  }\n})( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n  var _this = this;\n  var inputElRef, _hideMenuItems, handleMenuLinkClick, handleSearchKeyup, search, makeMenu, _params$searchPlaceho;\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        makeMenu = function _makeMenu() {\n          var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          // nested menu level\n          var deepLevel = 0;\n          var findLevel = function findLevel(item) {\n            if (item !== undefined) {\n              deepLevel++;\n              if (item.parent !== undefined) {\n                findLevel(params.data[item.parent]);\n              }\n            }\n          };\n          params.data && parent && findLevel(params.data[parent]);\n          return params.data && Object.keys(params.data).filter(function (key) {\n            return (params.data[key].parent || null) === parent;\n          }).map(function (key) {\n            var styles = [];\n            params.data[key].available && styles.push("cursor: pointer");\n            if (params.data[key].category) {\n              var categoryCssClass = ["insum-menu-category__title"];\n              params.activeMenuItem === key && categoryCssClass.push("insum-menu-category__title_active");\n              return params.data[key].hide ? undefined : x(_templateObject || (_templateObject = _taggedTemplateLiteral(["<div class=\\"insum-menu-category\\">\\n                <span @click=", " class=", " style=", ">\\n                  ", "\\n                </span>\\n                ", "\\n              </div>"])), function (e) {\n                return handleMenuLinkClick(e, key);\n              }, categoryCssClass.join(" "), styles.join(";"), params.data[key].label, makeMenu(key));\n            } else {\n              var linkCssClass = ["insum-menu-category__link"];\n              params.activeMenuItem === key && linkCssClass.push("insum-menu-category__link_active");\n              _hideMenuItems.includes(key) && linkCssClass.push("insum-menu-category__link_hide");\n              styles.push("padding-left: ".concat(deepLevel * 10 + 10, "px"));\n              return params.data[key].hide ? undefined : x(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\\n                <div @click=", " class=", " style=", ">\\n                  ", "\\n                </div>\\n                ", "\\n              "])), function (e) {\n                return handleMenuLinkClick(e, key);\n              }, linkCssClass.join(" "), styles.join(";"), params.data[key].label, makeMenu(key));\n            }\n          });\n        };\n        this.container = this.attachShadow({\n          mode: "open"\n        });\n        setStyle(sidemenu/* default */.A, this.container);\n        inputElRef = ref_e(); // list of hided menu items (after filter)\n        _hideMenuItems = [];\n        /**\n         * Handler for click by menu item\n         *\n         * @param event - click event\n         * @param itemKey - item ID\n         */\n        handleMenuLinkClick = function handleMenuLinkClick(event, itemKey) {\n          event.preventDefault();\n          event.stopPropagation();\n          console.log(itemKey);\n          if (params.data[itemKey].available) {\n            params.activeMenuItem = itemKey;\n            var changeActiveEvent = new CustomEvent("changeActive", {\n              detail: _objectSpread(_objectSpread({}, params.data[itemKey]), {}, {\n                key: itemKey\n              })\n            });\n            _this.dispatchEvent(changeActiveEvent);\n          }\n        };\n        /**\n         * Handler for keyup inside search field\n         *\n         * @param event - keyup event\n         */\n        handleSearchKeyup = function handleSearchKeyup(event) {\n          event.preventDefault();\n          if (event && event.target) {\n            var value = "value" in event.target ? String(event.target["value"]) : "";\n            search(value);\n          }\n        };\n        /**\n         * Filter menu items by text inside search field\n         *\n         * @param searchFor - text from search field\n         */\n        search = function search(searchFor) {\n          _hideMenuItems.length = 0;\n          for (var item in params.data) {\n            if (params.data[item].label.toLowerCase().indexOf(searchFor.toLowerCase()) === -1) {\n              _hideMenuItems.push(item);\n            }\n          }\n          _this.next();\n        };\n        /**\n         * Create a sub-menu template base on data\n         *\n         * @param parent - parent item key\n         */\n        requestAnimationFrame(function () {\n          var _inputElRef$value;\n          (_inputElRef$value = inputElRef.value) === null || _inputElRef$value === void 0 ? void 0 : _inputElRef$value.focus();\n        });\n      case 9:\n        if (false) {}\n        (_params$searchPlaceho = params.searchPlaceholder) !== null && _params$searchPlaceho !== void 0 ? _params$searchPlaceho : params.searchPlaceholder = "";\n        _context.next = 13;\n        return x(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<div class=\\"insum-menu__sidenav\\">\\n        <div class=\\"insum-menu-search\\">\\n          <insum-search-icon class=\\"insum-menu-search__icon\\"></insum-search-icon>\\n          <input @keyup=", " type=\\"text\\" .placeholder=", " .ref=", ">\\n        </div>\\n        ", "\\n        <slot></slot>\\n      </div>"])), handleSearchKeyup, params.searchPlaceholder, ref_n(inputElRef), makeMenu());\n      case 13:\n        params = _context.sent;\n        _context.next = 9;\n        break;\n      case 16:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee, this);\n}));\n// EXTERNAL MODULE: ./www/src/main.css\nvar main = __webpack_require__(820);\n;// CONCATENATED MODULE: ./www/src/views/counter-lit/counter.node.tsx\nfunction counter_node_typeof(obj) { "@babel/helpers - typeof"; return counter_node_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, counter_node_typeof(obj); }\nvar counter_node_templateObject;\n\nfunction counter_node_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ counter_node_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == counter_node_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction counter_node_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nvar counterNode = litView.node( /*#__PURE__*/counter_node_regeneratorRuntime().mark(function _callee(props) {\n  var _this = this;\n  var count, _props;\n  return counter_node_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        count = 0;\n        this.next(); // just for tests\n        _context.prev = 2;\n      case 3:\n        if (false) {}\n        _context.next = 6;\n        return x(counter_node_templateObject || (counter_node_templateObject = counter_node_taggedTemplateLiteral(["\\n          <button type=\\"button\\" @click=", ">\\n            ", "\\n          </button>\\n          <i>", "</i>\\n        "])), function () {\n          count++, _this.next();\n        }, (_props = props) === null || _props === void 0 ? void 0 : _props.msg, count);\n      case 6:\n        props = _context.sent;\n        _context.next = 3;\n        break;\n      case 9:\n        _context.prev = 9;\n        console.log("A CounterNode with lit-html render was disconnected");\n        return _context.finish(9);\n      case 12:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee, this, [[2,, 9, 12]]);\n}));\n// import { NG } from \'@web-companions/gfc\';\n// import { html, render } from \'uhtml\';\n// function renderNode(node: { current: object | Node | null }, tpl: any) {\n//   if (node.current instanceof Node) {\n//     render(node.current, html`${tpl}`);\n//     return undefined;\n//   } else {\n//     const a = html.for(node)`${tpl}`;\n//     return a;\n//   }\n// }\n// export const counterNode = NG()(function* (props: { msg: string }) {\n//   let count = 0;\n//   this.next(); // just for tests\n//   while (true) {\n//     props = yield renderNode(\n//       this,\n//       <>\n//         <button\n//           type="button"\n//           onclick={() => {\n//             count++, this.next();\n//           }}\n//         >\n//           {props?.msg}\n//         </button>\n//         <i>{count}</i>\n//       </>\n//     );\n//   }\n// });\n;// CONCATENATED MODULE: ./packages/h/lib/template.js\nfunction is(condition, value) {\n  return condition ? value : undefined;\n}\n;// CONCATENATED MODULE: ./www/src/views/counter-lit/counter.element.tsx\nfunction counter_element_typeof(obj) { "@babel/helpers - typeof"; return counter_element_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, counter_element_typeof(obj); }\nvar counter_element_templateObject, counter_element_templateObject2;\n\nfunction counter_element_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ counter_element_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == counter_element_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction counter_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nvar CounterNode = counterNode();\nvar CounterNode1 = counterNode();\nvar counterElement = litView.element({\n  props: {\n    msg: utils_p_p.req()\n  }\n})( /*#__PURE__*/counter_element_regeneratorRuntime().mark(function _callee(props) {\n  var _this = this;\n  var count, isShowingTempEl, _props;\n  return counter_element_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        count = 0;\n        isShowingTempEl = false;\n        setTimeout(function () {\n          isShowingTempEl = true;\n          _this.next();\n        }, 2000);\n        _context.prev = 3;\n      case 4:\n        if (false) {}\n        _context.next = 7;\n        return x(counter_element_templateObject || (counter_element_templateObject = counter_element_taggedTemplateLiteral(["<div class=\\"container\\">\\n          <div class=\\"row\\">\\n            <button class=\\"btn\\" type=\\"button\\" @click=", ">\\n              ", "\\n            </button>\\n            <i>", "</i>\\n          </div>\\n\\n          ", "\\n\\n          ", "\\n\\n          ", "\\n\\n          ", "\\n        </div>"])), function () {\n          count++;\n          _this.next();\n        }, (_props = props) === null || _props === void 0 ? void 0 : _props.msg, count, CounterNode({\n          key: "1",\n          msg: "Counter Node as JSX Tag1"\n        }), CounterNode({\n          key: "2",\n          msg: "Counter Node as JSX Tag2"\n        }), CounterNode({\n          msg: "Counter Node as JSX Tag3"\n        }), is(isShowingTempEl, x(counter_element_templateObject2 || (counter_element_templateObject2 = counter_element_taggedTemplateLiteral(["", ""])), CounterNode1({\n          msg: "Counter Node as JSX By condition"\n        }))));\n      case 7:\n        props = _context.sent;\n        _context.next = 4;\n        break;\n      case 10:\n        _context.prev = 10;\n        console.log("A CounterElement with lit-html render was disconnected");\n        return _context.finish(10);\n      case 13:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee, null, [[3,, 10, 13]]);\n}));\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/template-string-parser.js\nfunction* parse(text) {\n    let value = \'\';\n    let tokenStart = 0;\n    let open = false;\n    for (let i = 0; i < text.length; i += 1) {\n        if (text[i] === \'{\' && text[i + 1] === \'{\' && text[i - 1] !== \'\\\\\' && !open) {\n            open = true;\n            if (value)\n                yield { type: \'string\', start: tokenStart, end: i, value };\n            value = \'{{\';\n            tokenStart = i;\n            i += 2;\n        }\n        else if (text[i] === \'}\' && text[i + 1] === \'}\' && text[i - 1] !== \'\\\\\' && open) {\n            open = false;\n            yield { type: \'part\', start: tokenStart, end: i + 2, value: value.slice(2).trim() };\n            value = \'\';\n            i += 2;\n            tokenStart = i;\n        }\n        value += text[i] || \'\';\n    }\n    if (value)\n        yield { type: \'string\', start: tokenStart, end: text.length, value };\n}\n//# sourceMappingURL=template-string-parser.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/attribute-template-part.js\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === "m") throw new TypeError("Private method is not writable");\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AttributeTemplatePart_setter, _AttributeTemplatePart_value;\nclass AttributeTemplatePart {\n    constructor(setter, expression) {\n        this.expression = expression;\n        _AttributeTemplatePart_setter.set(this, void 0);\n        _AttributeTemplatePart_value.set(this, \'\');\n        __classPrivateFieldSet(this, _AttributeTemplatePart_setter, setter, "f");\n        __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").updateParent(\'\');\n    }\n    get attributeName() {\n        return __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").attr.name;\n    }\n    get attributeNamespace() {\n        return __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").attr.namespaceURI;\n    }\n    get value() {\n        return __classPrivateFieldGet(this, _AttributeTemplatePart_value, "f");\n    }\n    set value(value) {\n        __classPrivateFieldSet(this, _AttributeTemplatePart_value, value || \'\', "f");\n        __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").updateParent(value);\n    }\n    get element() {\n        return __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").element;\n    }\n    get booleanValue() {\n        return __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").booleanValue;\n    }\n    set booleanValue(value) {\n        __classPrivateFieldGet(this, _AttributeTemplatePart_setter, "f").booleanValue = value;\n    }\n}\n_AttributeTemplatePart_setter = new WeakMap(), _AttributeTemplatePart_value = new WeakMap();\nclass AttributeValueSetter {\n    constructor(element, attr) {\n        this.element = element;\n        this.attr = attr;\n        this.partList = [];\n    }\n    get booleanValue() {\n        return this.element.hasAttributeNS(this.attr.namespaceURI, this.attr.name);\n    }\n    set booleanValue(value) {\n        if (this.partList.length !== 1) {\n            throw new DOMException(\'Operation not supported\', \'NotSupportedError\');\n        }\n        ;\n        this.partList[0].value = value ? \'\' : null;\n    }\n    append(part) {\n        this.partList.push(part);\n    }\n    updateParent(partValue) {\n        if (this.partList.length === 1 && partValue === null) {\n            this.element.removeAttributeNS(this.attr.namespaceURI, this.attr.name);\n        }\n        else {\n            const str = this.partList.map(s => (typeof s === \'string\' ? s : s.value)).join(\'\');\n            this.element.setAttributeNS(this.attr.namespaceURI, this.attr.name, str);\n        }\n    }\n}\n//# sourceMappingURL=attribute-template-part.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/node-template-part.js\nvar node_template_part_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === "m") throw new TypeError("Private method is not writable");\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar node_template_part_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _NodeTemplatePart_parts;\nclass NodeTemplatePart {\n    constructor(node, expression) {\n        this.expression = expression;\n        _NodeTemplatePart_parts.set(this, void 0);\n        node_template_part_classPrivateFieldSet(this, _NodeTemplatePart_parts, [node], "f");\n        node.textContent = \'\';\n    }\n    get value() {\n        return node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f").map(node => node.textContent).join(\'\');\n    }\n    set value(string) {\n        this.replace(string);\n    }\n    get previousSibling() {\n        return node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f")[0].previousSibling;\n    }\n    get nextSibling() {\n        return node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f")[node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f").length - 1].nextSibling;\n    }\n    replace(...nodes) {\n        const parts = nodes.map(node => {\n            if (typeof node === \'string\')\n                return new Text(node);\n            return node;\n        });\n        if (!parts.length)\n            parts.push(new Text(\'\'));\n        node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f")[0].before(...parts);\n        for (const part of node_template_part_classPrivateFieldGet(this, _NodeTemplatePart_parts, "f"))\n            part.remove();\n        node_template_part_classPrivateFieldSet(this, _NodeTemplatePart_parts, parts, "f");\n    }\n}\n_NodeTemplatePart_parts = new WeakMap();\n//# sourceMappingURL=node-template-part.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/processors.js\n\nfunction createProcessor(processPart) {\n    return {\n        createCallback(instance, parts, params) {\n            this.processCallback(instance, parts, params);\n        },\n        processCallback(_, parts, params) {\n            var _a;\n            if (typeof params !== \'object\' || !params)\n                return;\n            for (const part of parts) {\n                if (part.expression in params) {\n                    const value = (_a = params[part.expression]) !== null && _a !== void 0 ? _a : \'\';\n                    processPart(part, value);\n                }\n            }\n        }\n    };\n}\nfunction processPropertyIdentity(part, value) {\n    part.value = String(value);\n}\nfunction processBooleanAttribute(part, value) {\n    if (typeof value === \'boolean\' &&\n        part instanceof AttributeTemplatePart &&\n        typeof part.element[part.attributeName] === \'boolean\') {\n        part.booleanValue = value;\n        return true;\n    }\n    return false;\n}\nconst propertyIdentity = createProcessor(processPropertyIdentity);\nconst propertyIdentityOrBooleanAttribute = createProcessor((part, value) => {\n    processBooleanAttribute(part, value) || processPropertyIdentity(part, value);\n});\n//# sourceMappingURL=processors.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/template-instance.js\nvar template_instance_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === "m") throw new TypeError("Private method is not writable");\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar template_instance_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _TemplateInstance_processor, _TemplateInstance_parts;\n\n\n\n\nfunction* collectParts(el) {\n    const walker = el.ownerDocument.createTreeWalker(el, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, null, false);\n    let node;\n    while ((node = walker.nextNode())) {\n        if (node instanceof Element && node.hasAttributes()) {\n            for (let i = 0; i < node.attributes.length; i += 1) {\n                const attr = node.attributes.item(i);\n                if (attr && attr.value.includes(\'{{\')) {\n                    const valueSetter = new AttributeValueSetter(node, attr);\n                    for (const token of parse(attr.value)) {\n                        if (token.type === \'string\') {\n                            valueSetter.append(token.value);\n                        }\n                        else {\n                            const part = new AttributeTemplatePart(valueSetter, token.value);\n                            valueSetter.append(part);\n                            yield part;\n                        }\n                    }\n                }\n            }\n        }\n        else if (node instanceof Text && node.textContent && node.textContent.includes(\'{{\')) {\n            for (const token of parse(node.textContent)) {\n                if (token.end < node.textContent.length)\n                    node.splitText(token.end);\n                if (token.type === \'part\')\n                    yield new NodeTemplatePart(node, token.value);\n                break;\n            }\n        }\n    }\n}\nclass TemplateInstance extends DocumentFragment {\n    constructor(template, params, processor = propertyIdentity) {\n        var _a, _b;\n        super();\n        _TemplateInstance_processor.set(this, void 0);\n        _TemplateInstance_parts.set(this, void 0);\n        // This is to fix an inconsistency in Safari which prevents us from\n        // correctly sub-classing DocumentFragment.\n        // https://bugs.webkit.org/show_bug.cgi?id=195556\n        if (Object.getPrototypeOf(this) !== TemplateInstance.prototype) {\n            Object.setPrototypeOf(this, TemplateInstance.prototype);\n        }\n        this.appendChild(template.content.cloneNode(true));\n        template_instance_classPrivateFieldSet(this, _TemplateInstance_parts, Array.from(collectParts(this)), "f");\n        template_instance_classPrivateFieldSet(this, _TemplateInstance_processor, processor, "f");\n        (_b = (_a = template_instance_classPrivateFieldGet(this, _TemplateInstance_processor, "f")).createCallback) === null || _b === void 0 ? void 0 : _b.call(_a, this, template_instance_classPrivateFieldGet(this, _TemplateInstance_parts, "f"), params);\n    }\n    update(params) {\n        template_instance_classPrivateFieldGet(this, _TemplateInstance_processor, "f").processCallback(this, template_instance_classPrivateFieldGet(this, _TemplateInstance_parts, "f"), params);\n    }\n}\n_TemplateInstance_processor = new WeakMap(), _TemplateInstance_parts = new WeakMap();\n//# sourceMappingURL=template-instance.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/template-parts/lib/index.js\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/directive.js\nconst directives = new WeakSet();\nfunction isDirective(directiveCallback) {\n    return directives.has(directiveCallback);\n}\nfunction processDirective(part, value) {\n    if (isDirective(value)) {\n        value(part);\n        return true;\n    }\n    return false;\n}\nfunction directive(directiveFactory) {\n    return (...values) => {\n        const callback = directiveFactory(...values);\n        directives.add(callback);\n        return callback;\n    };\n}\n//# sourceMappingURL=directive.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/events.js\n\nconst eventListeners = new WeakMap();\nclass EventHandler {\n    constructor(element, type) {\n        this.element = element;\n        this.type = type;\n        this.element.addEventListener(this.type, this);\n        eventListeners.get(this.element).set(this.type, this);\n    }\n    set(listener) {\n        if (typeof listener == \'function\') {\n            this.handleEvent = listener.bind(this.element);\n        }\n        else if (typeof listener === \'object\' && typeof listener.handleEvent === \'function\') {\n            this.handleEvent = listener.handleEvent.bind(listener);\n        }\n        else {\n            this.element.removeEventListener(this.type, this);\n            eventListeners.get(this.element).delete(this.type);\n        }\n    }\n    static for(part) {\n        if (!eventListeners.has(part.element))\n            eventListeners.set(part.element, new Map());\n        const type = part.attributeName.slice(2);\n        const elementListeners = eventListeners.get(part.element);\n        if (elementListeners.has(type))\n            return elementListeners.get(type);\n        return new EventHandler(part.element, type);\n    }\n}\nfunction processEvent(part, value) {\n    if (part instanceof AttributeTemplatePart && part.attributeName.startsWith(\'on\')) {\n        EventHandler.for(part).set(value);\n        part.element.removeAttributeNS(part.attributeNamespace, part.attributeName);\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=events.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/html.js\n\n\n\nfunction processSubTemplate(part, value) {\n    if (value instanceof TemplateResult && part instanceof NodeTemplatePart) {\n        value.renderInto(part);\n        return true;\n    }\n    return false;\n}\nfunction processDocumentFragment(part, value) {\n    if (value instanceof DocumentFragment && part instanceof NodeTemplatePart) {\n        if (value.childNodes.length)\n            part.replace(...value.childNodes);\n        return true;\n    }\n    return false;\n}\nfunction isIterable(value) {\n    return typeof value === \'object\' && Symbol.iterator in value;\n}\nfunction processIterable(part, value) {\n    if (!isIterable(value))\n        return false;\n    if (part instanceof NodeTemplatePart) {\n        const nodes = [];\n        for (const item of value) {\n            if (item instanceof TemplateResult) {\n                const fragment = document.createDocumentFragment();\n                item.renderInto(fragment);\n                nodes.push(...fragment.childNodes);\n            }\n            else if (item instanceof DocumentFragment) {\n                nodes.push(...item.childNodes);\n            }\n            else {\n                nodes.push(String(item));\n            }\n        }\n        if (nodes.length)\n            part.replace(...nodes);\n        return true;\n    }\n    else {\n        part.value = Array.from(value).join(\' \');\n        return true;\n    }\n}\nfunction processPart(part, value) {\n    processDirective(part, value) ||\n        processBooleanAttribute(part, value) ||\n        processEvent(part, value) ||\n        processSubTemplate(part, value) ||\n        processDocumentFragment(part, value) ||\n        processIterable(part, value) ||\n        processPropertyIdentity(part, value);\n}\nconst templates = new WeakMap();\nconst renderedTemplates = new WeakMap();\nconst renderedTemplateInstances = new WeakMap();\nclass TemplateResult {\n    constructor(strings, values, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.processor = processor;\n    }\n    get template() {\n        if (templates.has(this.strings)) {\n            return templates.get(this.strings);\n        }\n        else {\n            const template = document.createElement(\'template\');\n            const end = this.strings.length - 1;\n            template.innerHTML = this.strings.reduce((str, cur, i) => str + cur + (i < end ? `{{ ${i} }}` : \'\'), \'\');\n            templates.set(this.strings, template);\n            return template;\n        }\n    }\n    renderInto(element) {\n        const template = this.template;\n        if (renderedTemplates.get(element) !== template) {\n            renderedTemplates.set(element, template);\n            const instance = new TemplateInstance(template, this.values, this.processor);\n            renderedTemplateInstances.set(element, instance);\n            if (element instanceof NodeTemplatePart) {\n                element.replace(...instance.children);\n            }\n            else {\n                element.appendChild(instance);\n            }\n            return;\n        }\n        renderedTemplateInstances.get(element).update(this.values);\n    }\n}\nconst defaultProcessor = createProcessor(processPart);\nfunction html(strings, ...values) {\n    return new TemplateResult(strings, values, defaultProcessor);\n}\nfunction render(result, element) {\n    result.renderInto(element);\n}\n//# sourceMappingURL=html.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/until.js\n\n\nconst untils = new WeakMap();\nconst until = directive((...promises) => (part) => {\n    if (!untils.has(part))\n        untils.set(part, { i: promises.length });\n    const state = untils.get(part);\n    for (let i = 0; i < promises.length; i += 1) {\n        if (promises[i] instanceof Promise) {\n            // eslint-disable-next-line github/no-then\n            Promise.resolve(promises[i]).then(value => {\n                if (i < state.i) {\n                    state.i = i;\n                    processPart(part, value);\n                }\n            });\n        }\n        else if (i <= state.i) {\n            state.i = i;\n            processPart(part, promises[i]);\n        }\n    }\n});\n//# sourceMappingURL=until.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/unsafe-html.js\n\n\nconst unsafeHTML = directive((value) => (part) => {\n    if (!(part instanceof NodeTemplatePart))\n        return;\n    const template = document.createElement(\'template\');\n    template.innerHTML = value;\n    const fragment = document.importNode(template.content, true);\n    part.replace(...fragment.childNodes);\n});\n//# sourceMappingURL=unsafe-html.js.map\n;// CONCATENATED MODULE: ./node_modules/@github/jtml/lib/index.js\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./packages/jtml/node_modules/@web-companions/gfc/lib/utils/p.js\nfunction lib_utils_p_setProp(key, value) {\n    if (!this.isConnected) {\n        this.props[key] = value;\n        return;\n    }\n    if (value !== this.props[key]) {\n        this[\'__stash__\'] = {\n            ...this[\'__stash__\'],\n            [key]: value,\n        };\n    }\n    Promise.resolve({\n        then: () => {\n            let stash = this[\'__stash__\'];\n            if (stash != null) {\n                this.props = {\n                    ...this.props,\n                    ...stash,\n                };\n                stash = null;\n            }\n        },\n    });\n}\nconst lib_utils_p_p = {\n    req(attribute) {\n        return {\n            type: {},\n            attribute,\n        };\n    },\n    opt(attribute) {\n        return {\n            type: {},\n            attribute,\n            optional: true,\n        };\n    },\n};\n//# sourceMappingURL=p.js.map\n;// CONCATENATED MODULE: ./packages/jtml/node_modules/@web-companions/gfc/lib/EG.js\nvar lib_EG_setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nlet lib_EG_actualEl = undefined;\nfunction gfc_lib_EG_EG(config) {\n    return (func) => {\n        const constructor = lib_EG_build(func, (config === null || config === void 0 ? void 0 : config.props) || {}, config === null || config === void 0 ? void 0 : config.mapper, this === null || this === void 0 ? void 0 : this.getRenderFn().element);\n        return (name, options) => {\n            try {\n                customElements.define(name, constructor, options);\n            }\n            catch (e) {\n                console.warn(e);\n            }\n            const component = function (_props) {\n                if (new.target != null) {\n                    return new constructor();\n                }\n                else {\n                    return customElements.whenDefined(name).then(() => customElements.get(name));\n                }\n            };\n            component.adapter = (func, defaultProps) => func(name, defaultProps);\n            return component;\n        };\n    };\n}\nfunction lib_EG_build(func, props, mapper = lib_utils_p_setProp, render = (result) => result.value) {\n    var _a;\n    const customEl = (_a = class extends HTMLElement {\n            static get observedAttributes() {\n                return Object.values(this.attributes);\n            }\n            set props(newProps) {\n                if (newProps !== undefined && this.props !== newProps) {\n                    this._props = newProps;\n                    this.next();\n                }\n            }\n            get props() {\n                return this._props;\n            }\n            async next(props) {\n                this.props = props || this.props;\n                if (!this.isScheduledNext && this.generation != null) {\n                    this.isScheduledNext = true;\n                    const generator = await Promise.resolve(this.generation);\n                    this.isScheduledNext = false;\n                    lib_EG_actualEl = this;\n                    render.call(this, generator.next(this.props));\n                }\n            }\n            constructor() {\n                super();\n                this.container = this;\n                this._props = {};\n                this.isScheduledNext = false;\n                for (const pK in props) {\n                    const pV = props[pK];\n                    let attr = undefined;\n                    if (\'type\' in pV) {\n                        attr = pV.attribute;\n                    }\n                    Reflect.defineProperty(this, pK, {\n                        get: () => {\n                            return this.props[pK];\n                        },\n                        set: (value) => {\n                            mapper.apply(this, [pK, value, attr]);\n                        },\n                        enumerable: true,\n                    });\n                }\n            }\n            connectedCallback() {\n                this.generation = func.call(this, this.props);\n                lib_EG_actualEl = this;\n                render.call(this, this.generation.next(this.props));\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (oldValue !== newValue) {\n                    for (const [attrKey, attrName] of Object.entries(this.constructor[\'attributes\'])) {\n                        if (attrName === name && this[attrKey] !== newValue) {\n                            this[attrKey] = newValue;\n                            break;\n                        }\n                    }\n                }\n            }\n            disconnectedCallback() {\n                var _a;\n                (_a = this.generation) === null || _a === void 0 ? void 0 : _a.return();\n            }\n        },\n        lib_EG_setFunctionName(_a, "customEl"),\n        _a.attributes = {},\n        _a);\n    const attrKey = \'attributes\';\n    const attributes = Reflect.get(customEl, attrKey);\n    for (const pK in props) {\n        const pV = props[pK];\n        if (\'type\' in pV && pV.attribute !== undefined) {\n            Reflect.defineProperty(customEl, attrKey, {\n                value: {\n                    ...attributes,\n                    [pK]: pV.attribute,\n                },\n                enumerable: true,\n                writable: true,\n            });\n        }\n    }\n    return customEl;\n}\nfunction gfc_lib_EG_setElNode(nodesSymbol, key) {\n    let node = { current: null };\n    if (lib_EG_actualEl == null) {\n        return node;\n    }\n    if (lib_EG_actualEl[nodesSymbol] == null) {\n        lib_EG_actualEl[nodesSymbol] = {};\n    }\n    const nodes = lib_EG_actualEl[nodesSymbol];\n    if (nodes[key] == null) {\n        nodes[key] = node;\n    }\n    node = nodes[key];\n    return node;\n}\n//# sourceMappingURL=EG.js.map\n;// CONCATENATED MODULE: ./packages/jtml/node_modules/@web-companions/gfc/lib/NG.js\n\nconst lib_NG_ref2Node = new WeakMap();\nfunction gfc_lib_NG_NG(func) {\n    var _a;\n    const render = (_a = this === null || this === void 0 ? void 0 : this.getRenderFn().node) !== null && _a !== void 0 ? _a : ((result) => result.value);\n    return (ref = { current: null }) => {\n        const nodesSymbol = Symbol(\'nodes\');\n        return (props = {}) => {\n            const _ref = props.key != null ? gfc_lib_EG_setElNode(nodesSymbol, props.key) : ref;\n            let node = lib_NG_ref2Node.get(_ref);\n            if (node == null) {\n                const _node = {\n                    ..._ref,\n                    props,\n                    isScheduledNext: false,\n                };\n                const generator = Reflect.apply(func, _node, [props]);\n                _node.generator = generator;\n                _node.next = async function (_props) {\n                    this.props = _props || this.props;\n                    if (!this.isScheduledNext) {\n                        this.isScheduledNext = true;\n                        const g = await Promise.resolve(generator);\n                        this.isScheduledNext = false;\n                        this.value = render.call({ container: this }, g.next(this.props));\n                    }\n                };\n                node = _node;\n                lib_NG_ref2Node.set(_ref, node);\n            }\n            node.props = props;\n            node.value = render.call({ container: node }, node.generator.next(props));\n            return node.value;\n        };\n    };\n}\n//# sourceMappingURL=NG.js.map\n;// CONCATENATED MODULE: ./packages/jtml/node_modules/@web-companions/gfc/lib/View.js\n\n\nclass lib_View_View {\n    constructor(_render) {\n        this._render = _render;\n        this.element = gfc_lib_EG_EG;\n        this.node = gfc_lib_NG_NG;\n    }\n    getRenderFn() {\n        return this._render;\n    }\n}\n//# sourceMappingURL=View.js.map\n;// CONCATENATED MODULE: ./packages/jtml/node_modules/@web-companions/gfc/lib/index.js\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./packages/jtml/lib/jtml.view.js\n\n\n\n\nconst jtml_view_renderNodeDirective = directive((tpl, ref) => part => {\n  if (ref.current instanceof HTMLElement) {\n    render(tpl, ref.current);\n    return undefined;\n  }\n  ref.current = part;\n  processPart(part, tpl);\n});\nfunction jtml_view_renderNode(tpl, ref) {\n  if (ref.current instanceof HTMLElement) {\n    render(tpl, ref.current);\n    return undefined;\n  }\n  if (ref.current != null && "value" in ref.current) {\n    processPart(ref.current, tpl);\n  }\n  return jtml_view_renderNodeDirective(tpl, ref);\n}\nconst view = new lib_View_View({\n  element(result) {\n    render(result.value ?? html``, this.container);\n  },\n  node(result) {\n    return jtml_view_renderNode(result.value, this.container);\n  }\n});\n;// CONCATENATED MODULE: ./packages/jtml/lib/index.js\n\n\n;// CONCATENATED MODULE: ./www/src/views/counter-jtml/counter.node.tsx\n\n\nconst counter_node_counterNode = view.node(function* (props) {\n  let count = 0;\n  this.next(); // just for tests\n  try {\n    while (true) {\n      props = yield html`\n          <button type="button" onclick="${() => {\n        count++, this.next();\n      }}">\n            ${props?.msg}\n          </button>\n          <i>${count}</i>\n        `;\n    }\n  } finally {\n    console.log("A CounterNode with jtml render was disconnected");\n  }\n});\n;// CONCATENATED MODULE: ./www/src/views/counter-jtml/counter.element.tsx\n\n\n\n\nconst counter_element_CounterNode = counter_node_counterNode();\nconst counter_element_CounterNode1 = counter_node_counterNode();\nconst counter_element_counterElement = view.element({\n  props: {\n    msg: lib_utils_p_p.req()\n  }\n})(function* (props) {\n  let count = 0;\n  let isShowingTempEl = false;\n  setTimeout(() => {\n    isShowingTempEl = true;\n    this.next();\n  }, 2000);\n  try {\n    while (true) {\n      props = yield html`<div class="container">\n          <div class="row">\n            <button class="btn" type="button" onclick="${() => {\n        count++;\n        this.next();\n      }}">\n              ${props?.msg}\n            </button>\n            <i>${count}</i>\n          </div>\n\n          ${counter_element_CounterNode({\n        key: "1",\n        msg: "Counter Node as JSX Tag1"\n      })}\n\n          ${counter_element_CounterNode({\n        key: "2",\n        msg: "Counter Node as JSX Tag2"\n      })}\n\n          ${counter_element_CounterNode({\n        msg: "Counter Node as JSX Tag3"\n      })}\n\n          ${is(isShowingTempEl, html`${counter_element_CounterNode1({\n        msg: "Counter Node as JSX By condition"\n      })}`)}\n        </div>`;\n    }\n  } finally {\n    console.log("A CounterElement with jtml render was disconnected");\n  }\n});\n// EXTERNAL MODULE: ./www/src/views/gh-gist/ghGist.css\nvar ghGist = __webpack_require__(396);\n// EXTERNAL MODULE: ./www/src/views/gh-gist/ghGistIframe.css\nvar ghGistIframe = __webpack_require__(552);\n;// CONCATENATED MODULE: ./www/src/views/gh-gist/ghGist.element.tsx\nfunction ghGist_element_typeof(obj) { "@babel/helpers - typeof"; return ghGist_element_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ghGist_element_typeof(obj); }\nvar ghGist_element_templateObject;\n\nfunction ghGist_element_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ ghGist_element_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == ghGist_element_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ghGist_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\nvar ghGistElement = litView.element({\n  props: {\n    sharedLink: utils_p_p.req("iframeid")\n  }\n})( /*#__PURE__*/ghGist_element_regeneratorRuntime().mark(function _callee(params) {\n  var iframeRef;\n  return ghGist_element_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        setStyle(ghGist/* default */.A, this.container);\n        iframeRef = ref_e();\n        requestAnimationFrame(function () {\n          var iframeEl = iframeRef.value;\n          if (iframeEl == null) {\n            return;\n          }\n          var iframeElWindow = iframeEl["contentWindow"];\n          var doc = iframeEl["contentDocument"] || (iframeElWindow === null || iframeElWindow === void 0 ? void 0 : iframeElWindow.document);\n          if (doc == null) {\n            return;\n          }\n          doc.open();\n          doc.write( /*html*/"\\n      <html>\\n        <body>\\n          <scr" + "ipt type=\\"text/javascript\\" src=\\"".concat(params.sharedLink, ".js\\"></sc") + "ript>\\n        </body>\\n      </html>\\n      ");\n          doc.close();\n          if (iframeElWindow == null) {\n            return;\n          }\n          iframeElWindow.onload = function () {\n            if (doc == null) {\n              return;\n            }\n            setStyle(ghGistIframe/* default */.A, doc.body);\n            iframeEl.style.height = doc.body.scrollHeight + "px";\n          };\n        });\n      case 3:\n        if (false) {}\n        _context.next = 6;\n        return x(ghGist_element_templateObject || (ghGist_element_templateObject = ghGist_element_taggedTemplateLiteral(["<iframe .ref=", " scrolling=\\"no\\"></iframe>"])), ref_n(iframeRef));\n      case 6:\n        params = _context.sent;\n        _context.next = 3;\n        break;\n      case 9:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee, this);\n}));\n;// CONCATENATED MODULE: ./www/src/views/get-started/getStarted.element.tsx\nfunction getStarted_element_typeof(obj) { "@babel/helpers - typeof"; return getStarted_element_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, getStarted_element_typeof(obj); }\nvar getStarted_element_templateObject;\n\nfunction getStarted_element_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ getStarted_element_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == getStarted_element_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction getStarted_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nvar getStartedElement = litView.element()( /*#__PURE__*/getStarted_element_regeneratorRuntime().mark(function _callee() {\n  return getStarted_element_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (false) {}\n        _context.next = 3;\n        return x(getStarted_element_templateObject || (getStarted_element_templateObject = getStarted_element_taggedTemplateLiteral(["\\n        <p>\\n          This page will give you an introduction to the way of using", "\\n          <code>web-companions</code> inside some project.\\n        </p>\\n        <p>\\n          Of course, you can use only one library from a list of packages inside", "\\n          <code>web-companions</code> to solve a specific task. But here we will\\n          show you <b>how to create an atomic component</b> that is the general\\n          purpose of <code>web-companions</code> set of tools.\\n        </p>\\n        <p>\\n          We will use", "\\n          <a href=\\"https://www.npmjs.com/package/lit-html\\">lit-html</a> as a", "\\n          <code>render</code> because it\'s a robust and has a good support\\n          inside <code>web-companions</code>. Additionally, for better DX, we\\n          will set up", "\\n          <a href=\\"https://github.com/sumbad/babel-plugin-transform-jsx-to-tt\\">\\n            babel-plugin-transform-jsx-to-tt\\n          </a>\\n          . This <code>babel</code> plugin allows us to write templates with", "\\n          <code>JSX</code> instead of using Tagged Template Literals directly.\\n          For demonstration goal, we will use", "\\n          <a href=\\"https://webpack.js.org/\\">webpack</a>. But of course, you can\\n          use <code>web-companions</code> without bundling at all. Ok, so let\'s\\n          start step by step.\\n        </p>\\n\\n        <section>\\n          <h5>\\n            1. Create <code>npm</code> project and install <code>webpack</code>", "\\n            and <code>babel</code>:\\n          </h5>\\n          <pre>\\n            Run in terminal next commands\\n            <code>\\n              ", "\\n            </code>\\n          </pre>\\n        </section>\\n        <section>\\n          <h5>2. Set up project:</h5>\\n          <pre>\\n            Create <b>webpack.config.js</b> file inside wc-get-started folder\\n            with next content\\n            <code>\\n              ", "\\n            </code>\\n            Create <b>.babelrc.json</b> file inside wc-get-started folder with\\n            next content\\n            <code>\\n              ", "\\n            </code>\\n          </pre>\\n        </section>\\n        <section>\\n          <h5>\\n            3. Install <code>web-companions</code>\\n          </h5>\\n          <pre>\\n            Run in terminal next commands\\n            <code>\\n              ", "\\n            </code>\\n          </pre>\\n        </section>\\n        <section>\\n          <h5>\\n            4. Create your first <code>view component</code>\\n          </h5>\\n          <pre>\\n            Create <b>index.html</b> file inside <b>wc-get-started/src</b>", "\\n            folder with next content\\n            <code>\\n              ", "\\n            </code>\\n            Create <b>index.jsx</b> file inside <b>wc-get-started/src</b> folder\\n            with next content\\n            <code>\\n              ", "\\n            </code>\\n          </pre>\\n        </section>\\n\\n        <section>\\n          <h5>5. Run project locally:</h5>\\n          <pre>\\n            Run in terminal next commands\\n            <code>\\n              ", "\\n            </code>\\n          </pre>\\n        </section>\\n\\n        <p>\\n          Now you can open in a browser url from your terminal. It will show you\\n          a very simple page with only one button.\\n        </p>\\n      "])), " ", " ", " ", " ", " ", " ", " ", " ", "\\nmkdir wc-get-started\\ncd wc-get-started\\nnpm init -y\\nnpm install webpack webpack-cli webpack-dev-server babel-loader @babel/core @babel/preset-env babel-plugin-transform-jsx-to-tt --save-dev\\n              ", "\\nconst path = require(\'path\');\\n\\nmodule.exports = {\\n  mode: \'development\',\\n  entry: {\\n    index: path.join(__dirname, \'src\', \'index.jsx\'),\\n  },\\n  output: {\\n    path: path.join(__dirname, \'dist\'),\\n  },\\n  devServer: {\\n    static: {\\n      directory: path.join(__dirname, \'src\'),\\n    },\\n  },\\n  module: {\\n    rules: [\\n      {\\n        test: /.m?js(x?)$/,\\n        loader: \'babel-loader\',\\n        exclude: /node_modules/,\\n      },\\n    ],\\n  },\\n};\\n              ", "\\n{\\n    \\"presets\\": [\\"@babel/env\\"],\\n    \\"plugins\\": [\\n      [\\n        \\"babel-plugin-transform-jsx-to-tt\\",\\n        {\\n          \\"tag\\": \\"html\\",\\n          \\"import\\": {\\n            \\"module\\": \\"lit-html\\",\\n            \\"export\\": \\"html\\"\\n          },\\n          \\"attributes\\": [\\n            {\\n              \\"preset\\": \\"lit-html\\"\\n            }\\n          ]\\n        }\\n      ]\\n    ]\\n}  \\n              ", "\\nnpm install @web-companions/lit\\n              ", " ", "\\n<!DOCTYPE html>\\n<html lang=\\"en\\">\\n  <head>\\n    <meta charset=\\"UTF-8\\" />\\n    <meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1.0\\" />\\n    <title>Use web-companions</title>\\n    <script type=\\"module\\" src=\\"/index.js\\"><\/script></head>\\n  </head>\\n  <body>\\n    <app-main></app-main>\\n  </body>\\n</html>\\n              ", "\\nimport { litView } from \'@web-companions/lit\';\\n\\nlitView.element()(function* () {\\n  let counter = 0;\\n\\n  while (true) {\\n    yield (\\n      <>\\n        <h1>\\n          Get started with <code>web-companions</code>\\n        </h1>\\n\\n        <p>This is a simple counter, press the next button to increase value</p>\\n\\n        <button\\n          onclick={() => {\\n            counter++, this.next();\\n          }}\\n        >\\n          Add +1\\n        </button>\\n        {counter}\\n      </>\\n    );\\n  }\\n})(\'app-main\');\\n              ", "\\nnpx webpack serve\\n              ");\n      case 3:\n        _context.next = 0;\n        break;\n      case 5:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee);\n}));\n;// CONCATENATED MODULE: ./www/src/views/introduction/Introduction.element.tsx\nfunction Introduction_element_typeof(obj) { "@babel/helpers - typeof"; return Introduction_element_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Introduction_element_typeof(obj); }\nvar Introduction_element_templateObject;\n\nfunction Introduction_element_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ Introduction_element_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == Introduction_element_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction Introduction_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nvar introductionElement = litView.element()( /*#__PURE__*/Introduction_element_regeneratorRuntime().mark(function _callee() {\n  return Introduction_element_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (false) {}\n        _context.next = 3;\n        return x(Introduction_element_templateObject || (Introduction_element_templateObject = Introduction_element_taggedTemplateLiteral(["\\n        <h5>\\n          Welcome to the <code>web-companions</code> documentation!\\n        </h5>\\n        <p>\\n          At its core, <code>web-companions</code> is a set of tools to simplify\\n          the web development process with", "\\n          <b>\\n            concentration on creating atomic view components using Web\\n            Specifications\\n          </b>\\n          .\\n        </p>\\n        <p>\\n          These libraries are not a framework and not need to learn it\\n          separately. It\'s like <code>innerHtml</code>, but with helpers and\\n          wrappers to make it easier to use Web Specifications and perform\\n          simple, straightforward tasks:\\n        </p>\\n        <ul>\\n          <li>Write native UI components in a clear way.</li>\\n          <li>\\n            No extra knowledge. Learn language, learn specifications and\\n            platforms.\\n          </li>\\n          <li>Without frameworks with minimum of dependencies.</li>\\n        </ul>\\n\\n        <hr>\\n        <h5>A little theory</h5>\\n\\n        <p>In general, any UI component has two things:</p>\\n        <ol>\\n          <li>\\n            Lifecycle \\u2013 to control how a component will be created, updated and\\n            destroyed.\\n          </li>\\n          <li>\\n            Render \\u2013 to visually present a component in a platform, for web it\\n            will be HTML, CSS, SVG.\\n          </li>\\n        </ol>\\n\\n        <pre>\\n          <code>\\n            ", "\\n          </code>\\n        </pre>\\n\\n        <p>\\n          To simplify the development process and increase DX we combined\\n          Lifecycle and Render inside <code>view</code>. A <code>view</code>", "\\n          could be rendered as an HTML element or an HTML node inside an element\\n          in a web page. Any <code>view</code> is building on two parts:", "\\n          <b>lifecycle and render</b>. In turn, the lifecycle is built on", "\\n          <a href=\\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\\">\\n            Generator\\n          </a>", "\\n          and", "\\n          <a href=\\"https://developer.mozilla.org/en-US/docs/Web/API/Web_components#custom_elements_2\\">\\n            Custom elements\\n          </a>\\n          . That\'s all!\\n        </p>\\n\\n        <hr>\\n        <h5>More details</h5>\\n\\n        <p>\\n          To use lifecycle convenient way, it was wrapped inside\\n          <code>@web-companions/gfc</code> package. So that we can just write a\\n          generator function for <code>EG</code> or <code>NG</code> functions,\\n          that will use it inside a custom element. Generator function in JS is\\n          a function that can run it part and return values several times\\n          without rerun the whole function. We create an infinity part that\\n          render a new HTML with updated values each time when we produce them.\\n        </p>\\n\\n        <img alt=\\"Web-companions work schema\\" src=\\"https://raw.githubusercontent.com/sumbad/web-companions/master/doc/schema.png\\" width=\\"100%\\">\\n\\n        <p>\\n          No magic, no compilations, no hacks and hooks. As you can see, it\'s\\n          easy to repeat these libraries using JavaScript generator functions\\n          and Web Specifications.\\n        </p>\\n      "])), " ", "\\n<UI Component> = <Lifecycle> + <Render>;\\n\\n// where:\\n\\n<Lifecycle> = @web-companions/gfc;\\n\\n<Render> =  lit-html | uhtml | hyperHTML | @github/jtml | <any other, even innerHTML if you need something very simple>;\\n            ", " ", " ", " ", " ", " ");\n      case 3:\n        _context.next = 0;\n        break;\n      case 5:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee);\n}));\n;// CONCATENATED MODULE: ./www/src/views/page-content/pageContent.element.tsx\nfunction pageContent_element_typeof(obj) { "@babel/helpers - typeof"; return pageContent_element_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, pageContent_element_typeof(obj); }\nvar pageContent_element_templateObject, pageContent_element_templateObject2, pageContent_element_templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20;\n\nfunction pageContent_element_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ pageContent_element_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == pageContent_element_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction pageContent_element_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction pageContent_element_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? pageContent_element_ownKeys(Object(source), !0).forEach(function (key) { pageContent_element_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : pageContent_element_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction pageContent_element_defineProperty(obj, key, value) { key = pageContent_element_toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction pageContent_element_toPropertyKey(arg) { var key = pageContent_element_toPrimitive(arg, "string"); return pageContent_element_typeof(key) === "symbol" ? key : String(key); }\nfunction pageContent_element_toPrimitive(input, hint) { if (pageContent_element_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (pageContent_element_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }\nfunction pageContent_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\n\nvar CounterJtmlElement = counter_element_counterElement("demo-counter-jtml");\nvar CounterLitElement = counterElement("demo-counter-lit");\nvar GhGistElement = ghGistElement("demo-gh-gist");\nvar GetStartedElement = getStartedElement("get-started");\nvar IntroductionElement = introductionElement("companions-introduction");\nvar pageContentElement = litView.element({\n  props: {\n    activePage: utils_p_p.req()\n  }\n})( /*#__PURE__*/pageContent_element_regeneratorRuntime().mark(function _callee(params) {\n  var _this = this;\n  var demo, selectedItem, handleSelectedItem, MenuTemplateRenders, _demo$menu, _demo, _demo$gists, _demo2;\n  return pageContent_element_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        demo = {\n          title: function title() {\n            return x(pageContent_element_templateObject || (pageContent_element_templateObject = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          content: function content() {\n            return x(pageContent_element_templateObject2 || (pageContent_element_templateObject2 = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          menu: function menu() {\n            return x(pageContent_element_templateObject3 || (pageContent_element_templateObject3 = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          gists: function gists() {\n            return x(_templateObject4 || (_templateObject4 = pageContent_element_taggedTemplateLiteral([""])));\n          }\n        };\n        selectedItem = null;\n        handleSelectedItem = function handleSelectedItem(item) {\n          return function () {\n            selectedItem = item;\n            _this.next();\n          };\n        };\n        MenuTemplateRenders = function MenuTemplateRenders() {\n          return x(_templateObject5 || (_templateObject5 = pageContent_element_taggedTemplateLiteral(["<nav class=\\"navbar\\">\\n      <div class=\\"container\\">\\n        <ul class=\\"navbar-list\\">\\n          <li class=\\"navbar-item\\">\\n            <a class=\\"navbar-link\\" @click=", ">\\n              jtml render\\n            </a>\\n            <a class=\\"navbar-link\\" @click=", ">\\n              lit-html render\\n            </a>\\n          </li>\\n        </ul>\\n      </div>\\n    </nav>"])), handleSelectedItem("jtml"), handleSelectedItem("lit"));\n        };\n      case 4:\n        if (false) {}\n        _context.t0 = params.activePage;\n        _context.next = _context.t0 === "introduction" ? 8 : _context.t0 === "get_started" ? 10 : _context.t0 === "counter" ? 12 : 15;\n        break;\n      case 8:\n        demo = {\n          title: function title() {\n            return x(_templateObject6 || (_templateObject6 = pageContent_element_taggedTemplateLiteral(["<h1>\\uD83E\\uDD14 Introduction</h1>"])));\n          },\n          content: function content() {\n            return x(_templateObject7 || (_templateObject7 = pageContent_element_taggedTemplateLiteral(["<companions-introduction></companions-introduction>"])));\n          }\n        };\n        return _context.abrupt("break", 17);\n      case 10:\n        demo = {\n          title: function title() {\n            return x(_templateObject8 || (_templateObject8 = pageContent_element_taggedTemplateLiteral(["<h1>\\uD83C\\uDFAC Get started</h1>"])));\n          },\n          content: function content() {\n            return x(_templateObject9 || (_templateObject9 = pageContent_element_taggedTemplateLiteral(["<get-started></get-started>"])));\n          }\n        };\n        return _context.abrupt("break", 17);\n      case 12:\n        demo = pageContent_element_objectSpread(pageContent_element_objectSpread({}, demo), {}, {\n          title: function title() {\n            return x(_templateObject10 || (_templateObject10 = pageContent_element_taggedTemplateLiteral(["<h2>\\u25B6\\uFE0F Demo. Counter</h2>"])));\n          },\n          // menu: MenuTemplateRenders,\n          content: function content() {\n            return x(_templateObject11 || (_templateObject11 = pageContent_element_taggedTemplateLiteral(["<demo-counter-jtml .msg=", "></demo-counter-jtml>"])), "Counter Element");\n          },\n          gists: function gists() {\n            return x(_templateObject12 || (_templateObject12 = pageContent_element_taggedTemplateLiteral(["<demo-gh-gist .sharedLink=", "></demo-gh-gist>"])), "https://gist.github.com/sumbad/7d0ee6ad3f9282cfd3c99cb6ddbedc6b");\n          }\n        });\n        if (selectedItem === "lit") {\n          demo.content = function () {\n            return x(_templateObject13 || (_templateObject13 = pageContent_element_taggedTemplateLiteral(["<demo-counter-lit .msg=", "></demo-counter-lit>"])), "Counter Element");\n          };\n          demo.gists = function () {\n            return x(_templateObject14 || (_templateObject14 = pageContent_element_taggedTemplateLiteral(["<demo-gh-gist .sharedLink=", "></demo-gh-gist>"])), "https://gist.github.com/sumbad/7d0ee6ad3f9282cfd3c99cb6ddbedc6b");\n          };\n        }\n        return _context.abrupt("break", 17);\n      case 15:\n        demo = {\n          title: function title() {\n            return x(_templateObject15 || (_templateObject15 = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          content: function content() {\n            return x(_templateObject16 || (_templateObject16 = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          menu: function menu() {\n            return x(_templateObject17 || (_templateObject17 = pageContent_element_taggedTemplateLiteral([""])));\n          },\n          gists: function gists() {\n            return x(_templateObject18 || (_templateObject18 = pageContent_element_taggedTemplateLiteral([""])));\n          }\n        };\n        return _context.abrupt("break", 17);\n      case 17:\n        _context.next = 19;\n        return x(_templateObject19 || (_templateObject19 = pageContent_element_taggedTemplateLiteral(["<div class=\\"page-content\\">\\n        ", "\\n        ", "\\n        ", "\\n        ", "\\n      </div>"])), demo.title(), (_demo$menu = (_demo = demo).menu) === null || _demo$menu === void 0 ? void 0 : _demo$menu.call(_demo), demo.content(), is(demo.gists != null, x(_templateObject20 || (_templateObject20 = pageContent_element_taggedTemplateLiteral(["\\n            <hr>\\n            <hr>\\n            <h3>\\uD83D\\uDEE0\\uFE0F Source code</h3>\\n            ", "\\n          "])), (_demo$gists = (_demo2 = demo).gists) === null || _demo$gists === void 0 ? void 0 : _demo$gists.call(_demo2))));\n      case 19:\n        params = _context.sent;\n        _context.next = 4;\n        break;\n      case 22:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee);\n}));\n;// CONCATENATED MODULE: ./www/src/main.tsx\nfunction main_typeof(obj) { "@babel/helpers - typeof"; return main_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, main_typeof(obj); }\nvar main_templateObject, main_templateObject2;\n\nfunction main_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ main_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == main_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'" + methodName + "\' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction main_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\nvar SidemenuElement = sidemenuElement("demo-sidemenu");\nvar PageContentElement = pageContentElement("demo-page-content");\nvar gitHubIcon = litView.node( /*#__PURE__*/main_regeneratorRuntime().mark(function _callee() {\n  return main_regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        if (false) {}\n        _context.next = 3;\n        return x(main_templateObject || (main_templateObject = main_taggedTemplateLiteral(["<svg xmlns=\\"http://www.w3.org/2000/svg\\" class=\\"icon icon-tabler icon-tabler-brand-github\\" width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" stroke-width=\\"1\\" stroke=\\"currentColor\\" fill=\\"none\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\">\\n        <path stroke=\\"none\\" d=\\"M0 0h24v24H0z\\" fill=\\"none\\"></path>\\n        <path d=\\"M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5\\"></path>\\n      </svg>"])));\n      case 3:\n        _context.next = 0;\n        break;\n      case 5:\n      case "end":\n        return _context.stop();\n    }\n  }, _callee);\n}));\nvar menu = {\n  introduction: {\n    label: "Introduction",\n    category: true,\n    available: true\n  },\n  get_started: {\n    label: "Get started",\n    category: true,\n    available: true\n  },\n  demo: {\n    label: "Demo",\n    category: true\n  },\n  counter: {\n    label: "Counter",\n    parent: "demo",\n    available: true\n  }\n};\n/**\n * ROOT element\n */\nlitView.element()( /*#__PURE__*/main_regeneratorRuntime().mark(function _callee2() {\n  var _this = this;\n  var activePage, onchangeActive;\n  return main_regeneratorRuntime().wrap(function _callee2$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        setStyle(main/* default */.A, this.container);\n        activePage = "introduction";\n        onchangeActive = function onchangeActive(event) {\n          console.log(event.detail.key);\n          activePage = event.detail.key;\n          _this.next();\n        };\n      case 3:\n        if (false) {}\n        _context2.next = 6;\n        return x(main_templateObject2 || (main_templateObject2 = main_taggedTemplateLiteral(["\\n        <demo-sidemenu searchPlaceholder=\\"Search\\" .data=", " activeMenuItem=\\"introduction\\" @changeActive=", ">\\n          <footer>\\n            <a href=\\"https://github.com/sumbad/web-companions\\">\\n              ", " web-companions\\n            </a>\\n          </footer>\\n        </demo-sidemenu>\\n\\n        <div class=\\"demo-content\\">\\n          <demo-page-content .activePage=", "></demo-page-content>\\n        </div>\\n      "])), menu, onchangeActive, gitHubIcon()(), activePage);\n      case 6:\n        _context2.next = 3;\n        break;\n      case 8:\n      case "end":\n        return _context2.stop();\n    }\n  }, _callee2, this);\n}))("www-main");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUU1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGl0LWh0bWwuanM/NjE2OSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2xpdC9ub2RlX21vZHVsZXMvQHdlYi1jb21wYW5pb25zL2dmYy9saWIvdXRpbHMvcC5qcz9mMjI2Iiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvbGl0L25vZGVfbW9kdWxlcy9Ad2ViLWNvbXBhbmlvbnMvZ2ZjL2xpYi9FRy5qcz80Njc2Iiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvbGl0L25vZGVfbW9kdWxlcy9Ad2ViLWNvbXBhbmlvbnMvZ2ZjL2xpYi9ORy5qcz83NDBjIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvbGl0L25vZGVfbW9kdWxlcy9Ad2ViLWNvbXBhbmlvbnMvZ2ZjL2xpYi9WaWV3LmpzP2Q0ZTEiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9wYWNrYWdlcy9saXQvbm9kZV9tb2R1bGVzL0B3ZWItY29tcGFuaW9ucy9nZmMvbGliL2luZGV4LmpzPzE2ZDEiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvZGlyZWN0aXZlLWhlbHBlcnMuanM/MzA5YyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9kaXJlY3RpdmUuanM/OTM3OSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9hc3luYy1kaXJlY3RpdmUuanM/YTVlZCIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2xpdC9saWIvbGl0LnZpZXcuanM/Njk0MyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2xpdC9saWIvaW5kZXguanM/YTA5MyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2gvbGliL3N0eWxlLmpzP2Q5OTkiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9wYWNrYWdlcy9nZmMvbGliL3V0aWxzL3AuanM/MjM0NyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2dmYy9saWIvTkcuanM/NGM2MiIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2dmYy9saWIvRUcuanM/NmQ4MiIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2dmYy9saWIvVmlldy5qcz9mMjdmIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvZ2ZjL2xpYi9pbmRleC5qcz8xOGVjIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2RpcmVjdGl2ZXMvcmVmLmpzP2JmZGQiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL3NpZGVtZW51L3NpZGVtZW51LmVsZW1lbnQudHN4PzBmNWMiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL2NvdW50ZXItbGl0L2NvdW50ZXIubm9kZS50c3g/ZjRmYiIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2gvbGliL3RlbXBsYXRlLmpzP2JkODQiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL2NvdW50ZXItbGl0L2NvdW50ZXIuZWxlbWVudC50c3g/MzI3OSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL3RlbXBsYXRlLXBhcnRzL2xpYi90ZW1wbGF0ZS1zdHJpbmctcGFyc2VyLmpzPzY3YjMiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvQGdpdGh1Yi90ZW1wbGF0ZS1wYXJ0cy9saWIvYXR0cmlidXRlLXRlbXBsYXRlLXBhcnQuanM/NTg5ZSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL3RlbXBsYXRlLXBhcnRzL2xpYi9ub2RlLXRlbXBsYXRlLXBhcnQuanM/OTU5ZCIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL3RlbXBsYXRlLXBhcnRzL2xpYi9wcm9jZXNzb3JzLmpzP2RiZjQiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvQGdpdGh1Yi90ZW1wbGF0ZS1wYXJ0cy9saWIvdGVtcGxhdGUtaW5zdGFuY2UuanM/MTM2OSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL3RlbXBsYXRlLXBhcnRzL2xpYi9pbmRleC5qcz83MmM3Iiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vbm9kZV9tb2R1bGVzL0BnaXRodWIvanRtbC9saWIvZGlyZWN0aXZlLmpzPzRiMWQiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvQGdpdGh1Yi9qdG1sL2xpYi9ldmVudHMuanM/NDQzYyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL2p0bWwvbGliL2h0bWwuanM/ZTRjYyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9AZ2l0aHViL2p0bWwvbGliL3VudGlsLmpzP2QyODMiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvQGdpdGh1Yi9qdG1sL2xpYi91bnNhZmUtaHRtbC5qcz8zMTRkIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vbm9kZV9tb2R1bGVzL0BnaXRodWIvanRtbC9saWIvaW5kZXguanM/NzNlNCIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2p0bWwvbm9kZV9tb2R1bGVzL0B3ZWItY29tcGFuaW9ucy9nZmMvbGliL3V0aWxzL3AuanM/NWQxOSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2p0bWwvbm9kZV9tb2R1bGVzL0B3ZWItY29tcGFuaW9ucy9nZmMvbGliL0VHLmpzP2RiYmQiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9wYWNrYWdlcy9qdG1sL25vZGVfbW9kdWxlcy9Ad2ViLWNvbXBhbmlvbnMvZ2ZjL2xpYi9ORy5qcz85ZDMwIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvanRtbC9ub2RlX21vZHVsZXMvQHdlYi1jb21wYW5pb25zL2dmYy9saWIvVmlldy5qcz9lYzEyIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvanRtbC9ub2RlX21vZHVsZXMvQHdlYi1jb21wYW5pb25zL2dmYy9saWIvaW5kZXguanM/NTc3MSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3BhY2thZ2VzL2p0bWwvbGliL2p0bWwudmlldy5qcz82NmEzIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vcGFja2FnZXMvanRtbC9saWIvaW5kZXguanM/OTQ3ZSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvdmlld3MvY291bnRlci1qdG1sL2NvdW50ZXIubm9kZS50c3g/YWM5OSIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvdmlld3MvY291bnRlci1qdG1sL2NvdW50ZXIuZWxlbWVudC50c3g/NWQ0MiIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvdmlld3MvZ2gtZ2lzdC9naEdpc3QuZWxlbWVudC50c3g/YjEyNyIsIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvdmlld3MvZ2V0LXN0YXJ0ZWQvZ2V0U3RhcnRlZC5lbGVtZW50LnRzeD85ODIzIiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy92aWV3cy9pbnRyb2R1Y3Rpb24vSW50cm9kdWN0aW9uLmVsZW1lbnQudHN4P2I4NWIiLCJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL3BhZ2UtY29udGVudC9wYWdlQ29udGVudC5lbGVtZW50LnRzeD8yZWQ2Iiwid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy9tYWluLnRzeD9lMmVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xudmFyIHQ7Y29uc3QgaT13aW5kb3cscz1pLnRydXN0ZWRUeXBlcyxlPXM/cy5jcmVhdGVQb2xpY3koXCJsaXQtaHRtbFwiLHtjcmVhdGVIVE1MOnQ9PnR9KTp2b2lkIDAsbz1cIiRsaXQkXCIsbj1gbGl0JCR7KE1hdGgucmFuZG9tKCkrXCJcIikuc2xpY2UoOSl9JGAsbD1cIj9cIituLGg9YDwke2x9PmAscj1kb2N1bWVudCx1PSgpPT5yLmNyZWF0ZUNvbW1lbnQoXCJcIiksZD10PT5udWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQsYz1BcnJheS5pc0FycmF5LHY9dD0+Yyh0KXx8XCJmdW5jdGlvblwiPT10eXBlb2YobnVsbD09dD92b2lkIDA6dFtTeW1ib2wuaXRlcmF0b3JdKSxhPVwiWyBcXHRcXG5cXGZcXHJdXCIsZj0vPCg/OighLS18XFwvW15hLXpBLVpdKXwoXFwvP1thLXpBLVpdW14+XFxzXSopfChcXC8/JCkpL2csXz0vLS0+L2csbT0vPi9nLHA9UmVnRXhwKGA+fCR7YX0oPzooW15cXFxcc1wiJz49L10rKSgke2F9Kj0ke2F9Kig/OlteIFxcdFxcblxcZlxcclwiJ1xcYDw+PV18KFwifCcpfCkpfCQpYCxcImdcIiksZz0vJy9nLCQ9L1wiL2cseT0vXig/OnNjcmlwdHxzdHlsZXx0ZXh0YXJlYXx0aXRsZSkkL2ksdz10PT4oaSwuLi5zKT0+KHtfJGxpdFR5cGUkOnQsc3RyaW5nczppLHZhbHVlczpzfSkseD13KDEpLGI9dygyKSxUPVN5bWJvbC5mb3IoXCJsaXQtbm9DaGFuZ2VcIiksQT1TeW1ib2wuZm9yKFwibGl0LW5vdGhpbmdcIiksRT1uZXcgV2Vha01hcCxDPXIuY3JlYXRlVHJlZVdhbGtlcihyLDEyOSxudWxsLCExKTtmdW5jdGlvbiBQKHQsaSl7aWYoIUFycmF5LmlzQXJyYXkodCl8fCF0Lmhhc093blByb3BlcnR5KFwicmF3XCIpKXRocm93IEVycm9yKFwiaW52YWxpZCB0ZW1wbGF0ZSBzdHJpbmdzIGFycmF5XCIpO3JldHVybiB2b2lkIDAhPT1lP2UuY3JlYXRlSFRNTChpKTppfWNvbnN0IFY9KHQsaSk9Pntjb25zdCBzPXQubGVuZ3RoLTEsZT1bXTtsZXQgbCxyPTI9PT1pP1wiPHN2Zz5cIjpcIlwiLHU9Zjtmb3IobGV0IGk9MDtpPHM7aSsrKXtjb25zdCBzPXRbaV07bGV0IGQsYyx2PS0xLGE9MDtmb3IoO2E8cy5sZW5ndGgmJih1Lmxhc3RJbmRleD1hLGM9dS5leGVjKHMpLG51bGwhPT1jKTspYT11Lmxhc3RJbmRleCx1PT09Zj9cIiEtLVwiPT09Y1sxXT91PV86dm9pZCAwIT09Y1sxXT91PW06dm9pZCAwIT09Y1syXT8oeS50ZXN0KGNbMl0pJiYobD1SZWdFeHAoXCI8L1wiK2NbMl0sXCJnXCIpKSx1PXApOnZvaWQgMCE9PWNbM10mJih1PXApOnU9PT1wP1wiPlwiPT09Y1swXT8odT1udWxsIT1sP2w6Zix2PS0xKTp2b2lkIDA9PT1jWzFdP3Y9LTI6KHY9dS5sYXN0SW5kZXgtY1syXS5sZW5ndGgsZD1jWzFdLHU9dm9pZCAwPT09Y1szXT9wOidcIic9PT1jWzNdPyQ6Zyk6dT09PSR8fHU9PT1nP3U9cDp1PT09X3x8dT09PW0/dT1mOih1PXAsbD12b2lkIDApO2NvbnN0IHc9dT09PXAmJnRbaSsxXS5zdGFydHNXaXRoKFwiLz5cIik/XCIgXCI6XCJcIjtyKz11PT09Zj9zK2g6dj49MD8oZS5wdXNoKGQpLHMuc2xpY2UoMCx2KStvK3Muc2xpY2Uodikrbit3KTpzK24rKC0yPT09dj8oZS5wdXNoKHZvaWQgMCksaSk6dyl9cmV0dXJuW1AodCxyKyh0W3NdfHxcIjw/PlwiKSsoMj09PWk/XCI8L3N2Zz5cIjpcIlwiKSksZV19O2NsYXNzIE57Y29uc3RydWN0b3Ioe3N0cmluZ3M6dCxfJGxpdFR5cGUkOml9LGUpe2xldCBoO3RoaXMucGFydHM9W107bGV0IHI9MCxkPTA7Y29uc3QgYz10Lmxlbmd0aC0xLHY9dGhpcy5wYXJ0cyxbYSxmXT1WKHQsaSk7aWYodGhpcy5lbD1OLmNyZWF0ZUVsZW1lbnQoYSxlKSxDLmN1cnJlbnROb2RlPXRoaXMuZWwuY29udGVudCwyPT09aSl7Y29uc3QgdD10aGlzLmVsLmNvbnRlbnQsaT10LmZpcnN0Q2hpbGQ7aS5yZW1vdmUoKSx0LmFwcGVuZCguLi5pLmNoaWxkTm9kZXMpfWZvcig7bnVsbCE9PShoPUMubmV4dE5vZGUoKSkmJnYubGVuZ3RoPGM7KXtpZigxPT09aC5ub2RlVHlwZSl7aWYoaC5oYXNBdHRyaWJ1dGVzKCkpe2NvbnN0IHQ9W107Zm9yKGNvbnN0IGkgb2YgaC5nZXRBdHRyaWJ1dGVOYW1lcygpKWlmKGkuZW5kc1dpdGgobyl8fGkuc3RhcnRzV2l0aChuKSl7Y29uc3Qgcz1mW2QrK107aWYodC5wdXNoKGkpLHZvaWQgMCE9PXMpe2NvbnN0IHQ9aC5nZXRBdHRyaWJ1dGUocy50b0xvd2VyQ2FzZSgpK28pLnNwbGl0KG4pLGk9LyhbLj9AXSk/KC4qKS8uZXhlYyhzKTt2LnB1c2goe3R5cGU6MSxpbmRleDpyLG5hbWU6aVsyXSxzdHJpbmdzOnQsY3RvcjpcIi5cIj09PWlbMV0/SDpcIj9cIj09PWlbMV0/TDpcIkBcIj09PWlbMV0/ejprfSl9ZWxzZSB2LnB1c2goe3R5cGU6NixpbmRleDpyfSl9Zm9yKGNvbnN0IGkgb2YgdCloLnJlbW92ZUF0dHJpYnV0ZShpKX1pZih5LnRlc3QoaC50YWdOYW1lKSl7Y29uc3QgdD1oLnRleHRDb250ZW50LnNwbGl0KG4pLGk9dC5sZW5ndGgtMTtpZihpPjApe2gudGV4dENvbnRlbnQ9cz9zLmVtcHR5U2NyaXB0OlwiXCI7Zm9yKGxldCBzPTA7czxpO3MrKyloLmFwcGVuZCh0W3NdLHUoKSksQy5uZXh0Tm9kZSgpLHYucHVzaCh7dHlwZToyLGluZGV4Oisrcn0pO2guYXBwZW5kKHRbaV0sdSgpKX19fWVsc2UgaWYoOD09PWgubm9kZVR5cGUpaWYoaC5kYXRhPT09bCl2LnB1c2goe3R5cGU6MixpbmRleDpyfSk7ZWxzZXtsZXQgdD0tMTtmb3IoOy0xIT09KHQ9aC5kYXRhLmluZGV4T2Yobix0KzEpKTspdi5wdXNoKHt0eXBlOjcsaW5kZXg6cn0pLHQrPW4ubGVuZ3RoLTF9cisrfX1zdGF0aWMgY3JlYXRlRWxlbWVudCh0LGkpe2NvbnN0IHM9ci5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7cmV0dXJuIHMuaW5uZXJIVE1MPXQsc319ZnVuY3Rpb24gUyh0LGkscz10LGUpe3ZhciBvLG4sbCxoO2lmKGk9PT1UKXJldHVybiBpO2xldCByPXZvaWQgMCE9PWU/bnVsbD09PShvPXMuXyRDbyl8fHZvaWQgMD09PW8/dm9pZCAwOm9bZV06cy5fJENsO2NvbnN0IHU9ZChpKT92b2lkIDA6aS5fJGxpdERpcmVjdGl2ZSQ7cmV0dXJuKG51bGw9PXI/dm9pZCAwOnIuY29uc3RydWN0b3IpIT09dSYmKG51bGw9PT0obj1udWxsPT1yP3ZvaWQgMDpyLl8kQU8pfHx2b2lkIDA9PT1ufHxuLmNhbGwociwhMSksdm9pZCAwPT09dT9yPXZvaWQgMDoocj1uZXcgdSh0KSxyLl8kQVQodCxzLGUpKSx2b2lkIDAhPT1lPyhudWxsIT09KGw9KGg9cykuXyRDbykmJnZvaWQgMCE9PWw/bDpoLl8kQ289W10pW2VdPXI6cy5fJENsPXIpLHZvaWQgMCE9PXImJihpPVModCxyLl8kQVModCxpLnZhbHVlcykscixlKSksaX1jbGFzcyBNe2NvbnN0cnVjdG9yKHQsaSl7dGhpcy5fJEFWPVtdLHRoaXMuXyRBTj12b2lkIDAsdGhpcy5fJEFEPXQsdGhpcy5fJEFNPWl9Z2V0IHBhcmVudE5vZGUoKXtyZXR1cm4gdGhpcy5fJEFNLnBhcmVudE5vZGV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9dSh0KXt2YXIgaTtjb25zdHtlbDp7Y29udGVudDpzfSxwYXJ0czplfT10aGlzLl8kQUQsbz0obnVsbCE9PShpPW51bGw9PXQ/dm9pZCAwOnQuY3JlYXRpb25TY29wZSkmJnZvaWQgMCE9PWk/aTpyKS5pbXBvcnROb2RlKHMsITApO0MuY3VycmVudE5vZGU9bztsZXQgbj1DLm5leHROb2RlKCksbD0wLGg9MCx1PWVbMF07Zm9yKDt2b2lkIDAhPT11Oyl7aWYobD09PXUuaW5kZXgpe2xldCBpOzI9PT11LnR5cGU/aT1uZXcgUihuLG4ubmV4dFNpYmxpbmcsdGhpcyx0KToxPT09dS50eXBlP2k9bmV3IHUuY3RvcihuLHUubmFtZSx1LnN0cmluZ3MsdGhpcyx0KTo2PT09dS50eXBlJiYoaT1uZXcgWihuLHRoaXMsdCkpLHRoaXMuXyRBVi5wdXNoKGkpLHU9ZVsrK2hdfWwhPT0obnVsbD09dT92b2lkIDA6dS5pbmRleCkmJihuPUMubmV4dE5vZGUoKSxsKyspfXJldHVybiBDLmN1cnJlbnROb2RlPXIsb312KHQpe2xldCBpPTA7Zm9yKGNvbnN0IHMgb2YgdGhpcy5fJEFWKXZvaWQgMCE9PXMmJih2b2lkIDAhPT1zLnN0cmluZ3M/KHMuXyRBSSh0LHMsaSksaSs9cy5zdHJpbmdzLmxlbmd0aC0yKTpzLl8kQUkodFtpXSkpLGkrK319Y2xhc3MgUntjb25zdHJ1Y3Rvcih0LGkscyxlKXt2YXIgbzt0aGlzLnR5cGU9Mix0aGlzLl8kQUg9QSx0aGlzLl8kQU49dm9pZCAwLHRoaXMuXyRBQT10LHRoaXMuXyRBQj1pLHRoaXMuXyRBTT1zLHRoaXMub3B0aW9ucz1lLHRoaXMuXyRDcD1udWxsPT09KG89bnVsbD09ZT92b2lkIDA6ZS5pc0Nvbm5lY3RlZCl8fHZvaWQgMD09PW98fG99Z2V0IF8kQVUoKXt2YXIgdCxpO3JldHVybiBudWxsIT09KGk9bnVsbD09PSh0PXRoaXMuXyRBTSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQuXyRBVSkmJnZvaWQgMCE9PWk/aTp0aGlzLl8kQ3B9Z2V0IHBhcmVudE5vZGUoKXtsZXQgdD10aGlzLl8kQUEucGFyZW50Tm9kZTtjb25zdCBpPXRoaXMuXyRBTTtyZXR1cm4gdm9pZCAwIT09aSYmMTE9PT0obnVsbD09dD92b2lkIDA6dC5ub2RlVHlwZSkmJih0PWkucGFyZW50Tm9kZSksdH1nZXQgc3RhcnROb2RlKCl7cmV0dXJuIHRoaXMuXyRBQX1nZXQgZW5kTm9kZSgpe3JldHVybiB0aGlzLl8kQUJ9XyRBSSh0LGk9dGhpcyl7dD1TKHRoaXMsdCxpKSxkKHQpP3Q9PT1BfHxudWxsPT10fHxcIlwiPT09dD8odGhpcy5fJEFIIT09QSYmdGhpcy5fJEFSKCksdGhpcy5fJEFIPUEpOnQhPT10aGlzLl8kQUgmJnQhPT1UJiZ0aGlzLl8odCk6dm9pZCAwIT09dC5fJGxpdFR5cGUkP3RoaXMuZyh0KTp2b2lkIDAhPT10Lm5vZGVUeXBlP3RoaXMuJCh0KTp2KHQpP3RoaXMuVCh0KTp0aGlzLl8odCl9ayh0KXtyZXR1cm4gdGhpcy5fJEFBLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsdGhpcy5fJEFCKX0kKHQpe3RoaXMuXyRBSCE9PXQmJih0aGlzLl8kQVIoKSx0aGlzLl8kQUg9dGhpcy5rKHQpKX1fKHQpe3RoaXMuXyRBSCE9PUEmJmQodGhpcy5fJEFIKT90aGlzLl8kQUEubmV4dFNpYmxpbmcuZGF0YT10OnRoaXMuJChyLmNyZWF0ZVRleHROb2RlKHQpKSx0aGlzLl8kQUg9dH1nKHQpe3ZhciBpO2NvbnN0e3ZhbHVlczpzLF8kbGl0VHlwZSQ6ZX09dCxvPVwibnVtYmVyXCI9PXR5cGVvZiBlP3RoaXMuXyRBQyh0KToodm9pZCAwPT09ZS5lbCYmKGUuZWw9Ti5jcmVhdGVFbGVtZW50KFAoZS5oLGUuaFswXSksdGhpcy5vcHRpb25zKSksZSk7aWYoKG51bGw9PT0oaT10aGlzLl8kQUgpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLl8kQUQpPT09byl0aGlzLl8kQUgudihzKTtlbHNle2NvbnN0IHQ9bmV3IE0obyx0aGlzKSxpPXQudSh0aGlzLm9wdGlvbnMpO3QudihzKSx0aGlzLiQoaSksdGhpcy5fJEFIPXR9fV8kQUModCl7bGV0IGk9RS5nZXQodC5zdHJpbmdzKTtyZXR1cm4gdm9pZCAwPT09aSYmRS5zZXQodC5zdHJpbmdzLGk9bmV3IE4odCkpLGl9VCh0KXtjKHRoaXMuXyRBSCl8fCh0aGlzLl8kQUg9W10sdGhpcy5fJEFSKCkpO2NvbnN0IGk9dGhpcy5fJEFIO2xldCBzLGU9MDtmb3IoY29uc3QgbyBvZiB0KWU9PT1pLmxlbmd0aD9pLnB1c2gocz1uZXcgUih0aGlzLmsodSgpKSx0aGlzLmsodSgpKSx0aGlzLHRoaXMub3B0aW9ucykpOnM9aVtlXSxzLl8kQUkobyksZSsrO2U8aS5sZW5ndGgmJih0aGlzLl8kQVIocyYmcy5fJEFCLm5leHRTaWJsaW5nLGUpLGkubGVuZ3RoPWUpfV8kQVIodD10aGlzLl8kQUEubmV4dFNpYmxpbmcsaSl7dmFyIHM7Zm9yKG51bGw9PT0ocz10aGlzLl8kQVApfHx2b2lkIDA9PT1zfHxzLmNhbGwodGhpcywhMSwhMCxpKTt0JiZ0IT09dGhpcy5fJEFCOyl7Y29uc3QgaT10Lm5leHRTaWJsaW5nO3QucmVtb3ZlKCksdD1pfX1zZXRDb25uZWN0ZWQodCl7dmFyIGk7dm9pZCAwPT09dGhpcy5fJEFNJiYodGhpcy5fJENwPXQsbnVsbD09PShpPXRoaXMuXyRBUCl8fHZvaWQgMD09PWl8fGkuY2FsbCh0aGlzLHQpKX19Y2xhc3Mga3tjb25zdHJ1Y3Rvcih0LGkscyxlLG8pe3RoaXMudHlwZT0xLHRoaXMuXyRBSD1BLHRoaXMuXyRBTj12b2lkIDAsdGhpcy5lbGVtZW50PXQsdGhpcy5uYW1lPWksdGhpcy5fJEFNPWUsdGhpcy5vcHRpb25zPW8scy5sZW5ndGg+Mnx8XCJcIiE9PXNbMF18fFwiXCIhPT1zWzFdPyh0aGlzLl8kQUg9QXJyYXkocy5sZW5ndGgtMSkuZmlsbChuZXcgU3RyaW5nKSx0aGlzLnN0cmluZ3M9cyk6dGhpcy5fJEFIPUF9Z2V0IHRhZ05hbWUoKXtyZXR1cm4gdGhpcy5lbGVtZW50LnRhZ05hbWV9Z2V0IF8kQVUoKXtyZXR1cm4gdGhpcy5fJEFNLl8kQVV9XyRBSSh0LGk9dGhpcyxzLGUpe2NvbnN0IG89dGhpcy5zdHJpbmdzO2xldCBuPSExO2lmKHZvaWQgMD09PW8pdD1TKHRoaXMsdCxpLDApLG49IWQodCl8fHQhPT10aGlzLl8kQUgmJnQhPT1ULG4mJih0aGlzLl8kQUg9dCk7ZWxzZXtjb25zdCBlPXQ7bGV0IGwsaDtmb3IodD1vWzBdLGw9MDtsPG8ubGVuZ3RoLTE7bCsrKWg9Uyh0aGlzLGVbcytsXSxpLGwpLGg9PT1UJiYoaD10aGlzLl8kQUhbbF0pLG58fChuPSFkKGgpfHxoIT09dGhpcy5fJEFIW2xdKSxoPT09QT90PUE6dCE9PUEmJih0Kz0obnVsbCE9aD9oOlwiXCIpK29bbCsxXSksdGhpcy5fJEFIW2xdPWh9biYmIWUmJnRoaXMuaih0KX1qKHQpe3Q9PT1BP3RoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKTp0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSxudWxsIT10P3Q6XCJcIil9fWNsYXNzIEggZXh0ZW5kcyBre2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9M31qKHQpe3RoaXMuZWxlbWVudFt0aGlzLm5hbWVdPXQ9PT1BP3ZvaWQgMDp0fX1jb25zdCBJPXM/cy5lbXB0eVNjcmlwdDpcIlwiO2NsYXNzIEwgZXh0ZW5kcyBre2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnR5cGU9NH1qKHQpe3QmJnQhPT1BP3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLEkpOnRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5uYW1lKX19Y2xhc3MgeiBleHRlbmRzIGt7Y29uc3RydWN0b3IodCxpLHMsZSxvKXtzdXBlcih0LGkscyxlLG8pLHRoaXMudHlwZT01fV8kQUkodCxpPXRoaXMpe3ZhciBzO2lmKCh0PW51bGwhPT0ocz1TKHRoaXMsdCxpLDApKSYmdm9pZCAwIT09cz9zOkEpPT09VClyZXR1cm47Y29uc3QgZT10aGlzLl8kQUgsbz10PT09QSYmZSE9PUF8fHQuY2FwdHVyZSE9PWUuY2FwdHVyZXx8dC5vbmNlIT09ZS5vbmNlfHx0LnBhc3NpdmUhPT1lLnBhc3NpdmUsbj10IT09QSYmKGU9PT1BfHxvKTtvJiZ0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyxlKSxuJiZ0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm5hbWUsdGhpcyx0KSx0aGlzLl8kQUg9dH1oYW5kbGVFdmVudCh0KXt2YXIgaSxzO1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuXyRBSD90aGlzLl8kQUguY2FsbChudWxsIT09KHM9bnVsbD09PShpPXRoaXMub3B0aW9ucyl8fHZvaWQgMD09PWk/dm9pZCAwOmkuaG9zdCkmJnZvaWQgMCE9PXM/czp0aGlzLmVsZW1lbnQsdCk6dGhpcy5fJEFILmhhbmRsZUV2ZW50KHQpfX1jbGFzcyBae2NvbnN0cnVjdG9yKHQsaSxzKXt0aGlzLmVsZW1lbnQ9dCx0aGlzLnR5cGU9Nix0aGlzLl8kQU49dm9pZCAwLHRoaXMuXyRBTT1pLHRoaXMub3B0aW9ucz1zfWdldCBfJEFVKCl7cmV0dXJuIHRoaXMuXyRBTS5fJEFVfV8kQUkodCl7Uyh0aGlzLHQpfX1jb25zdCBqPXtPOm8sUDpuLEE6bCxDOjEsTTpWLEw6TSxEOnYsUjpTLEk6UixWOmssSDpMLE46eixVOkgsRjpafSxCPWkubGl0SHRtbFBvbHlmaWxsU3VwcG9ydDtudWxsPT1CfHxCKE4sUiksKG51bGwhPT0odD1pLmxpdEh0bWxWZXJzaW9ucykmJnZvaWQgMCE9PXQ/dDppLmxpdEh0bWxWZXJzaW9ucz1bXSkucHVzaChcIjIuNy41XCIpO2NvbnN0IEQ9KHQsaSxzKT0+e3ZhciBlLG87Y29uc3Qgbj1udWxsIT09KGU9bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1lP2U6aTtsZXQgbD1uLl8kbGl0UGFydCQ7aWYodm9pZCAwPT09bCl7Y29uc3QgdD1udWxsIT09KG89bnVsbD09cz92b2lkIDA6cy5yZW5kZXJCZWZvcmUpJiZ2b2lkIDAhPT1vP286bnVsbDtuLl8kbGl0UGFydCQ9bD1uZXcgUihpLmluc2VydEJlZm9yZSh1KCksdCksdCx2b2lkIDAsbnVsbCE9cz9zOnt9KX1yZXR1cm4gbC5fJEFJKHQpLGx9O2V4cG9ydHtqIGFzIF8kTEgseCBhcyBodG1sLFQgYXMgbm9DaGFuZ2UsQSBhcyBub3RoaW5nLEQgYXMgcmVuZGVyLGIgYXMgc3ZnfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdC1odG1sLmpzLm1hcFxuIiwiZXhwb3J0IGZ1bmN0aW9uIHNldFByb3Aoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHRoaXMucHJvcHNba2V5XSkge1xuICAgICAgICB0aGlzWydfX3N0YXNoX18nXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXNbJ19fc3Rhc2hfXyddLFxuICAgICAgICAgICAgW2tleV06IHZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0aGVuOiAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3Rhc2ggPSB0aGlzWydfX3N0YXNoX18nXTtcbiAgICAgICAgICAgIGlmIChzdGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Rhc2gsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGFzaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgcCA9IHtcbiAgICByZXEoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB7fSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9wdChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHt9LFxuICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wLmpzLm1hcCIsInZhciBfX3NldEZ1bmN0aW9uTmFtZSA9ICh0aGlzICYmIHRoaXMuX19zZXRGdW5jdGlvbk5hbWUpIHx8IGZ1bmN0aW9uIChmLCBuYW1lLCBwcmVmaXgpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuaW1wb3J0IHsgc2V0UHJvcCB9IGZyb20gJy4vdXRpbHMvcC5qcyc7XG5sZXQgYWN0dWFsRWwgPSB1bmRlZmluZWQ7XG5leHBvcnQgZnVuY3Rpb24gRUcoY29uZmlnKSB7XG4gICAgcmV0dXJuIChmdW5jKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gYnVpbGQoZnVuYywgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5wcm9wcykgfHwge30sIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5tYXBwZXIsIHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLmVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKG5hbWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZnVuY3Rpb24gKF9wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKG5hbWUpLnRoZW4oKCkgPT4gY3VzdG9tRWxlbWVudHMuZ2V0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tcG9uZW50LmFkYXB0ZXIgPSAoZnVuYywgZGVmYXVsdFByb3BzKSA9PiBmdW5jKG5hbWUsIGRlZmF1bHRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZChmdW5jLCBwcm9wcywgbWFwcGVyID0gc2V0UHJvcCwgcmVuZGVyID0gKHJlc3VsdCkgPT4gcmVzdWx0LnZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGN1c3RvbUVsID0gKF9hID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0IHByb3BzKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IHByb3BzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIG5leHQocHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWROZXh0ICYmIHRoaXMuZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbEVsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNhbGwodGhpcywgZ2VuZXJhdG9yLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBLIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBWID0gcHJvcHNbcEtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiBwVikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHBWLmF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHBLLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wc1twS107XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIuYXBwbHkodGhpcywgW3BLLCB2YWx1ZSwgYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGZ1bmMuY2FsbCh0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICBhY3R1YWxFbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVuZGVyLmNhbGwodGhpcywgdGhpcy5nZW5lcmF0aW9uLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbYXR0cktleSwgYXR0ck5hbWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uc3RydWN0b3JbJ2F0dHJpYnV0ZXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gbmFtZSAmJiB0aGlzW2F0dHJLZXldICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYXR0cktleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmdlbmVyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19zZXRGdW5jdGlvbk5hbWUoX2EsIFwiY3VzdG9tRWxcIiksXG4gICAgICAgIF9hLmF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgICAgX2EpO1xuICAgIGNvbnN0IGF0dHJLZXkgPSAnYXR0cmlidXRlcyc7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFJlZmxlY3QuZ2V0KGN1c3RvbUVsLCBhdHRyS2V5KTtcbiAgICBmb3IgKGNvbnN0IHBLIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHBWID0gcHJvcHNbcEtdO1xuICAgICAgICBpZiAoJ3R5cGUnIGluIHBWICYmIHBWLmF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGN1c3RvbUVsLCBhdHRyS2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgW3BLXTogcFYuYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21FbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbE5vZGUobm9kZXNTeW1ib2wsIGtleSkge1xuICAgIGxldCBub2RlID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgaWYgKGFjdHVhbEVsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChhY3R1YWxFbFtub2Rlc1N5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgICBhY3R1YWxFbFtub2Rlc1N5bWJvbF0gPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBhY3R1YWxFbFtub2Rlc1N5bWJvbF07XG4gICAgaWYgKG5vZGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBub2Rlc1trZXldID0gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGVzW2tleV07XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FRy5qcy5tYXAiLCJpbXBvcnQgeyBzZXRFbE5vZGUgfSBmcm9tICcuL0VHLmpzJztcbmNvbnN0IHJlZjJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBORyhmdW5jKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlciA9IChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLm5vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgocmVzdWx0KSA9PiByZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiAocmVmID0geyBjdXJyZW50OiBudWxsIH0pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXNTeW1ib2wgPSBTeW1ib2woJ25vZGVzJyk7XG4gICAgICAgIHJldHVybiAocHJvcHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgX3JlZiA9IHByb3BzLmtleSAhPSBudWxsID8gc2V0RWxOb2RlKG5vZGVzU3ltYm9sLCBwcm9wcy5rZXkpIDogcmVmO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByZWYyTm9kZS5nZXQoX3JlZik7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX25vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLl9yZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBpc1NjaGVkdWxlZE5leHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gUmVmbGVjdC5hcHBseShmdW5jLCBfbm9kZSwgW3Byb3BzXSk7XG4gICAgICAgICAgICAgICAgX25vZGUuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgICAgIF9ub2RlLm5leHQgPSBhc3luYyBmdW5jdGlvbiAoX3Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSBfcHJvcHMgfHwgdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2NoZWR1bGVkTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZyA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShnZW5lcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZW5kZXIuY2FsbCh7IGNvbnRhaW5lcjogdGhpcyB9LCBnLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XG4gICAgICAgICAgICAgICAgcmVmMk5vZGUuc2V0KF9yZWYsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHJlbmRlci5jYWxsKHsgY29udGFpbmVyOiBub2RlIH0sIG5vZGUuZ2VuZXJhdG9yLm5leHQocHJvcHMpKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ORy5qcy5tYXAiLCJpbXBvcnQgeyBFRyB9IGZyb20gJy4vRUcuanMnO1xuaW1wb3J0IHsgTkcgfSBmcm9tICcuL05HLmpzJztcbmV4cG9ydCBjbGFzcyBWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlciA9IF9yZW5kZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IEVHO1xuICAgICAgICB0aGlzLm5vZGUgPSBORztcbiAgICB9XG4gICAgZ2V0UmVuZGVyRm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5qcy5tYXAiLCJleHBvcnQgeyBFRyB9IGZyb20gJy4vRUcuanMnO1xuZXhwb3J0IHsgTkcgfSBmcm9tICcuL05HLmpzJztcbmV4cG9ydCB7IFZpZXcgfSBmcm9tICcuL1ZpZXcuanMnO1xuZXhwb3J0IHsgcCB9IGZyb20gJy4vdXRpbHMvcC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnR7XyRMSCBhcyBvfWZyb21cIi4vbGl0LWh0bWwuanNcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL2NvbnN0e0k6bH09byx0PW89Pm51bGw9PT1vfHxcIm9iamVjdFwiIT10eXBlb2YgbyYmXCJmdW5jdGlvblwiIT10eXBlb2YgbyxpPXtIVE1MOjEsU1ZHOjJ9LG49KG8sbCk9PnZvaWQgMD09PWw/dm9pZCAwIT09KG51bGw9PW8/dm9pZCAwOm8uXyRsaXRUeXBlJCk6KG51bGw9PW8/dm9pZCAwOm8uXyRsaXRUeXBlJCk9PT1sLGQ9bz0+dm9pZCAwIT09KG51bGw9PW8/dm9pZCAwOm8uXyRsaXREaXJlY3RpdmUkKSx2PW89Pm51bGw9PW8/dm9pZCAwOm8uXyRsaXREaXJlY3RpdmUkLGU9bz0+dm9pZCAwPT09by5zdHJpbmdzLGM9KCk9PmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikscj0obyx0LGkpPT57dmFyIG47Y29uc3QgZD1vLl8kQUEucGFyZW50Tm9kZSx2PXZvaWQgMD09PXQ/by5fJEFCOnQuXyRBQTtpZih2b2lkIDA9PT1pKXtjb25zdCB0PWQuaW5zZXJ0QmVmb3JlKGMoKSx2KSxuPWQuaW5zZXJ0QmVmb3JlKGMoKSx2KTtpPW5ldyBsKHQsbixvLG8ub3B0aW9ucyl9ZWxzZXtjb25zdCBsPWkuXyRBQi5uZXh0U2libGluZyx0PWkuXyRBTSxlPXQhPT1vO2lmKGUpe2xldCBsO251bGw9PT0obj1pLl8kQVEpfHx2b2lkIDA9PT1ufHxuLmNhbGwoaSxvKSxpLl8kQU09byx2b2lkIDAhPT1pLl8kQVAmJihsPW8uXyRBVSkhPT10Ll8kQVUmJmkuXyRBUChsKX1pZihsIT09dnx8ZSl7bGV0IG89aS5fJEFBO2Zvcig7byE9PWw7KXtjb25zdCBsPW8ubmV4dFNpYmxpbmc7ZC5pbnNlcnRCZWZvcmUobyx2KSxvPWx9fX1yZXR1cm4gaX0sdT0obyxsLHQ9byk9PihvLl8kQUkobCx0KSxvKSxmPXt9LHM9KG8sbD1mKT0+by5fJEFIPWwsbT1vPT5vLl8kQUgscD1vPT57dmFyIGw7bnVsbD09PShsPW8uXyRBUCl8fHZvaWQgMD09PWx8fGwuY2FsbChvLCExLCEwKTtsZXQgdD1vLl8kQUE7Y29uc3QgaT1vLl8kQUIubmV4dFNpYmxpbmc7Zm9yKDt0IT09aTspe2NvbnN0IG89dC5uZXh0U2libGluZzt0LnJlbW92ZSgpLHQ9b319LGE9bz0+e28uXyRBUigpfTtleHBvcnR7aSBhcyBUZW1wbGF0ZVJlc3VsdFR5cGUsYSBhcyBjbGVhclBhcnQsbSBhcyBnZXRDb21taXR0ZWRWYWx1ZSx2IGFzIGdldERpcmVjdGl2ZUNsYXNzLHIgYXMgaW5zZXJ0UGFydCxkIGFzIGlzRGlyZWN0aXZlUmVzdWx0LHQgYXMgaXNQcmltaXRpdmUsZSBhcyBpc1NpbmdsZUV4cHJlc3Npb24sbiBhcyBpc1RlbXBsYXRlUmVzdWx0LHAgYXMgcmVtb3ZlUGFydCx1IGFzIHNldENoaWxkUGFydFZhbHVlLHMgYXMgc2V0Q29tbWl0dGVkVmFsdWV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlyZWN0aXZlLWhlbHBlcnMuanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmNvbnN0IHQ9e0FUVFJJQlVURToxLENISUxEOjIsUFJPUEVSVFk6MyxCT09MRUFOX0FUVFJJQlVURTo0LEVWRU5UOjUsRUxFTUVOVDo2fSxlPXQ9PiguLi5lKT0+KHtfJGxpdERpcmVjdGl2ZSQ6dCx2YWx1ZXM6ZX0pO2NsYXNzIGl7Y29uc3RydWN0b3IodCl7fWdldCBfJEFVKCl7cmV0dXJuIHRoaXMuXyRBTS5fJEFVfV8kQVQodCxlLGkpe3RoaXMuXyRDdD10LHRoaXMuXyRBTT1lLHRoaXMuXyRDaT1pfV8kQVModCxlKXtyZXR1cm4gdGhpcy51cGRhdGUodCxlKX11cGRhdGUodCxlKXtyZXR1cm4gdGhpcy5yZW5kZXIoLi4uZSl9fWV4cG9ydHtpIGFzIERpcmVjdGl2ZSx0IGFzIFBhcnRUeXBlLGUgYXMgZGlyZWN0aXZlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZS5qcy5tYXBcbiIsImltcG9ydHtpc1NpbmdsZUV4cHJlc3Npb24gYXMgaX1mcm9tXCIuL2RpcmVjdGl2ZS1oZWxwZXJzLmpzXCI7aW1wb3J0e0RpcmVjdGl2ZSBhcyB0LFBhcnRUeXBlIGFzIGV9ZnJvbVwiLi9kaXJlY3RpdmUuanNcIjtleHBvcnR7RGlyZWN0aXZlLFBhcnRUeXBlLGRpcmVjdGl2ZX1mcm9tXCIuL2RpcmVjdGl2ZS5qc1wiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovY29uc3Qgcz0oaSx0KT0+e3ZhciBlLG87Y29uc3Qgcj1pLl8kQU47aWYodm9pZCAwPT09cilyZXR1cm4hMTtmb3IoY29uc3QgaSBvZiByKW51bGw9PT0obz0oZT1pKS5fJEFPKXx8dm9pZCAwPT09b3x8by5jYWxsKGUsdCwhMSkscyhpLHQpO3JldHVybiEwfSxvPWk9PntsZXQgdCxlO2Rve2lmKHZvaWQgMD09PSh0PWkuXyRBTSkpYnJlYWs7ZT10Ll8kQU4sZS5kZWxldGUoaSksaT10fXdoaWxlKDA9PT0obnVsbD09ZT92b2lkIDA6ZS5zaXplKSl9LHI9aT0+e2ZvcihsZXQgdDt0PWkuXyRBTTtpPXQpe2xldCBlPXQuXyRBTjtpZih2b2lkIDA9PT1lKXQuXyRBTj1lPW5ldyBTZXQ7ZWxzZSBpZihlLmhhcyhpKSlicmVhaztlLmFkZChpKSxsKHQpfX07ZnVuY3Rpb24gbihpKXt2b2lkIDAhPT10aGlzLl8kQU4/KG8odGhpcyksdGhpcy5fJEFNPWkscih0aGlzKSk6dGhpcy5fJEFNPWl9ZnVuY3Rpb24gaChpLHQ9ITEsZT0wKXtjb25zdCByPXRoaXMuXyRBSCxuPXRoaXMuXyRBTjtpZih2b2lkIDAhPT1uJiYwIT09bi5zaXplKWlmKHQpaWYoQXJyYXkuaXNBcnJheShyKSlmb3IobGV0IGk9ZTtpPHIubGVuZ3RoO2krKylzKHJbaV0sITEpLG8ocltpXSk7ZWxzZSBudWxsIT1yJiYocyhyLCExKSxvKHIpKTtlbHNlIHModGhpcyxpKX1jb25zdCBsPWk9Pnt2YXIgdCxzLG8scjtpLnR5cGU9PWUuQ0hJTEQmJihudWxsIT09KHQ9KG89aSkuXyRBUCkmJnZvaWQgMCE9PXR8fChvLl8kQVA9aCksbnVsbCE9PShzPShyPWkpLl8kQVEpJiZ2b2lkIDAhPT1zfHwoci5fJEFRPW4pKX07Y2xhc3MgYyBleHRlbmRzIHR7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuXyRBTj12b2lkIDB9XyRBVChpLHQsZSl7c3VwZXIuXyRBVChpLHQsZSkscih0aGlzKSx0aGlzLmlzQ29ubmVjdGVkPWkuXyRBVX1fJEFPKGksdD0hMCl7dmFyIGUscjtpIT09dGhpcy5pc0Nvbm5lY3RlZCYmKHRoaXMuaXNDb25uZWN0ZWQ9aSxpP251bGw9PT0oZT10aGlzLnJlY29ubmVjdGVkKXx8dm9pZCAwPT09ZXx8ZS5jYWxsKHRoaXMpOm51bGw9PT0ocj10aGlzLmRpc2Nvbm5lY3RlZCl8fHZvaWQgMD09PXJ8fHIuY2FsbCh0aGlzKSksdCYmKHModGhpcyxpKSxvKHRoaXMpKX1zZXRWYWx1ZSh0KXtpZihpKHRoaXMuXyRDdCkpdGhpcy5fJEN0Ll8kQUkodCx0aGlzKTtlbHNle2NvbnN0IGk9Wy4uLnRoaXMuXyRDdC5fJEFIXTtpW3RoaXMuXyRDaV09dCx0aGlzLl8kQ3QuXyRBSShpLHRoaXMsMCl9fWRpc2Nvbm5lY3RlZCgpe31yZWNvbm5lY3RlZCgpe319ZXhwb3J0e2MgYXMgQXN5bmNEaXJlY3RpdmV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtZGlyZWN0aXZlLmpzLm1hcFxuIiwiaW1wb3J0IHsgVmlldyB9IGZyb20gJ0B3ZWItY29tcGFuaW9ucy9nZmMnO1xuaW1wb3J0IHsgcmVuZGVyIH0gZnJvbSAnbGl0LWh0bWwnO1xuaW1wb3J0IHsgQXN5bmNEaXJlY3RpdmUgfSBmcm9tICdsaXQtaHRtbC9hc3luYy1kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgZGlyZWN0aXZlIH0gZnJvbSAnbGl0LWh0bWwvZGlyZWN0aXZlLmpzJztcbmNsYXNzIFJlbmRlck5vZGUgZXh0ZW5kcyBBc3luY0RpcmVjdGl2ZSB7XG4gIHJlbmRlcih0cGwsIHJlZikge1xuICAgIHJlZi5jdXJyZW50ID0gdGhpcztcbiAgICByZXR1cm4gdHBsO1xuICB9XG59XG5jb25zdCByZW5kZXJOb2RlRGlyZWN0aXZlID0gZGlyZWN0aXZlKFJlbmRlck5vZGUpO1xuZnVuY3Rpb24gcmVuZGVyTm9kZSh0cGwsIHJlZikge1xuICBpZiAocmVmLmN1cnJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJlbmRlcih0cGwsIHJlZi5jdXJyZW50KTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChyZWYuY3VycmVudCBpbnN0YW5jZW9mIFJlbmRlck5vZGUgJiYgcmVmLmN1cnJlbnQuaXNDb25uZWN0ZWQpIHtcbiAgICByZWYuY3VycmVudC5zZXRWYWx1ZSh0cGwpO1xuICB9XG4gIHJldHVybiByZW5kZXJOb2RlRGlyZWN0aXZlKHRwbCwgcmVmKTtcbn1cbmV4cG9ydCBjb25zdCBsaXRWaWV3ID0gbmV3IFZpZXcoe1xuICBlbGVtZW50KHJlc3VsdCkge1xuICAgIHJlbmRlcihyZXN1bHQudmFsdWUsIHRoaXMuY29udGFpbmVyKTtcbiAgfSxcbiAgbm9kZShyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVuZGVyTm9kZShyZXN1bHQudmFsdWUsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxufSk7IiwiZXhwb3J0ICogZnJvbSAnLi9saXQudmlldy5qcyc7IiwiZXhwb3J0IGNvbnN0IGNzcyA9IFN0cmluZy5yYXc7XG5leHBvcnQgZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5vZGUsIHN0eWxlSWQpIHtcbiAgaWYgKHdpbmRvdy5TaGFkb3dSb290ICYmICdhZG9wdGVkU3R5bGVTaGVldHMnIGluIERvY3VtZW50LnByb3RvdHlwZSAmJiAncmVwbGFjZScgaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICBjb25zdCBzaGVldCA9IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgc2hlZXRbJ3JlcGxhY2VTeW5jJ10oc3R5bGUpO1xuICAgIG5vZGVbJ2Fkb3B0ZWRTdHlsZVNoZWV0cyddID0gW3NoZWV0XTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGBzdHlsZSR7c3R5bGVJZCAhPSBudWxsID8gYCMke3N0eWxlSWR9YCA6ICcnfWA7XG4gICAgbGV0IHN0eWxlRWwgPSBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGlmIChzdHlsZUVsID09IG51bGwpIHtcbiAgICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgaWYgKHN0eWxlSWQgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZUVsLnNldEF0dHJpYnV0ZSgnaWQnLCBzdHlsZUlkKTtcbiAgICAgIH1cbiAgICAgIHN0eWxlRWwuaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgICBub2RlLmluc2VydEJlZm9yZShzdHlsZUVsLCBub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsLmlubmVySFRNTCA9IHN0eWxlO1xuICAgIH1cbiAgfVxufSIsImV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wKGtleSwgdmFsdWUpIHtcbiAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgdGhpcy5wcm9wc1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSAhPT0gdGhpcy5wcm9wc1trZXldKSB7XG4gICAgdGhpc1snX19zdGFzaF9fJ10gPSB7XG4gICAgICAuLi50aGlzWydfX3N0YXNoX18nXSxcbiAgICAgIFtrZXldOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICB0aGVuOiAoKSA9PiB7XG4gICAgICBsZXQgc3Rhc2ggPSB0aGlzWydfX3N0YXNoX18nXTtcbiAgICAgIGlmIChzdGFzaCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgICAuLi5zdGFzaFxuICAgICAgICB9O1xuICAgICAgICBzdGFzaCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCBwID0ge1xuICByZXEoYXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHt9LFxuICAgICAgYXR0cmlidXRlXG4gICAgfTtcbiAgfSxcbiAgb3B0KGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB7fSxcbiAgICAgIGF0dHJpYnV0ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfTtcbiAgfVxufTsiLCJpbXBvcnQgeyBzZXRFbE5vZGUgfSBmcm9tIFwiLi9FRy5qc1wiO1xuY29uc3QgcmVmMk5vZGUgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNvbnN0IGdldFJlZjJOb2RlID0gKCkgPT4gcmVmMk5vZGU7XG5leHBvcnQgZnVuY3Rpb24gTkcoZnVuYykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlbmRlciA9IChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLm5vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc3VsdCA9PiByZXN1bHQudmFsdWU7XG4gIHJldHVybiAocmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfSkgPT4ge1xuICAgIGNvbnN0IG5vZGVzU3ltYm9sID0gU3ltYm9sKFwibm9kZXNcIik7XG4gICAgcmV0dXJuIChwcm9wcyA9IHt9KSA9PiB7XG4gICAgICBjb25zdCBfcmVmID0gc2V0RWxOb2RlKG5vZGVzU3ltYm9sLCByZWYsIHByb3BzLmtleSk7XG4gICAgICBsZXQgbm9kZSA9IHJlZjJOb2RlLmdldChfcmVmKTtcbiAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgX25vZGUgPSB7XG4gICAgICAgICAgLi4uX3JlZixcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBpc1NjaGVkdWxlZE5leHQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IFJlZmxlY3QuYXBwbHkoZnVuYywgX25vZGUsIFtwcm9wc10pO1xuICAgICAgICBfbm9kZS5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIF9ub2RlLm5leHQgPSBhc3luYyBmdW5jdGlvbiAoX3Byb3BzKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcyA9IF9wcm9wcyB8fCB0aGlzLnByb3BzO1xuICAgICAgICAgIGlmICghdGhpcy5pc1NjaGVkdWxlZE5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoZ2VuZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVuZGVyLmNhbGwoe1xuICAgICAgICAgICAgICBjb250YWluZXI6IHRoaXNcbiAgICAgICAgICAgIH0sIGcubmV4dCh0aGlzLnByb3BzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBub2RlID0gX25vZGU7XG4gICAgICAgIHJlZjJOb2RlLnNldChfcmVmLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUucHJvcHMgPSBwcm9wcztcbiAgICAgIG5vZGUudmFsdWUgPSByZW5kZXIuY2FsbCh7XG4gICAgICAgIGNvbnRhaW5lcjogbm9kZVxuICAgICAgfSwgbm9kZS5nZW5lcmF0b3IubmV4dChwcm9wcykpO1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfTtcbiAgfTtcbn0iLCJ2YXIgX19zZXRGdW5jdGlvbk5hbWUgPSB0aGlzICYmIHRoaXMuX19zZXRGdW5jdGlvbk5hbWUgfHwgZnVuY3Rpb24gKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZVxuICB9KTtcbn07XG5pbXBvcnQgeyBzZXRQcm9wIH0gZnJvbSBcIi4vdXRpbHMvcC5qc1wiO1xuaW1wb3J0IHsgZ2V0UmVmMk5vZGUgfSBmcm9tIFwiLi9ORy5qc1wiO1xubGV0IGFjdHVhbEVsID0gbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBFRyhjb25maWcpIHtcbiAgcmV0dXJuIGZ1bmMgPT4ge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gYnVpbGQoZnVuYywgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5wcm9wcykgfHwge30sIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5tYXBwZXIsIHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLmVsZW1lbnQpO1xuICAgIHJldHVybiAobmFtZSwgb3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9uZW50ID0gZnVuY3Rpb24gKF9wcm9wcykge1xuICAgICAgICBpZiAobmV3LnRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjdXN0b21FbGVtZW50cy53aGVuRGVmaW5lZChuYW1lKS50aGVuKCgpID0+IGN1c3RvbUVsZW1lbnRzLmdldChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb21wb25lbnQuYWRhcHRlciA9IChmdW5jLCBkZWZhdWx0UHJvcHMpID0+IGZ1bmMobmFtZSwgZGVmYXVsdFByb3BzKTtcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkKGZ1bmMsIHByb3BzLCBtYXBwZXIgPSBzZXRQcm9wLCByZW5kZXIgPSByZXN1bHQgPT4gcmVzdWx0LnZhbHVlKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgY3VzdG9tRWwgPSAoX2EgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHNldCBwcm9wcyhuZXdQcm9wcykge1xuICAgICAgaWYgKG5ld1Byb3BzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBwcm9wcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICB9XG4gICAgYXN5bmMgbmV4dChwcm9wcykge1xuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzIHx8IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWROZXh0ICYmIHRoaXMuZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2VuZXJhdGlvbik7XG4gICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gZmFsc2U7XG4gICAgICAgIGFjdHVhbEVsID0gdGhpcztcbiAgICAgICAgcmVuZGVyLmNhbGwodGhpcywgZ2VuZXJhdG9yLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXM7XG4gICAgICB0aGlzLl9faW5uZXJOb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkTmV4dCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBwSyBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBwViA9IHByb3BzW3BLXTtcbiAgICAgICAgbGV0IGF0dHIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChcInR5cGVcIiBpbiBwVikge1xuICAgICAgICAgIGF0dHIgPSBwVi5hdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwSywge1xuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHNbcEtdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBtYXBwZXIuYXBwbHkodGhpcywgW3BLLCB2YWx1ZSwgYXR0cl0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICB0aGlzLmdlbmVyYXRpb24gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5wcm9wcyk7XG4gICAgICBhY3R1YWxFbCA9IHRoaXM7XG4gICAgICByZW5kZXIuY2FsbCh0aGlzLCB0aGlzLmdlbmVyYXRpb24ubmV4dCh0aGlzLnByb3BzKSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBbYXR0cktleSwgYXR0ck5hbWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uc3RydWN0b3JbXCJhdHRyaWJ1dGVzXCJdKSkge1xuICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gbmFtZSAmJiB0aGlzW2F0dHJLZXldICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpc1thdHRyS2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcmVmMk5vZGUgPSBnZXRSZWYyTm9kZSgpO1xuICAgICAgdGhpcy5fX2lubmVyTm9kZXMuZm9yRWFjaChpdCA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHJlZjJOb2RlLmdldChpdCk7XG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAoX2EgPSBub2RlLmdlbmVyYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJldHVybigpO1xuICAgICAgICAgIHJlZjJOb2RlLmRlbGV0ZShpdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgKF9hID0gdGhpcy5nZW5lcmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmV0dXJuKCk7XG4gICAgfVxuICB9LCBfX3NldEZ1bmN0aW9uTmFtZShfYSwgXCJjdXN0b21FbFwiKSwgX2EuYXR0cmlidXRlcyA9IHt9LCBfYSk7XG4gIGNvbnN0IGF0dHJLZXkgPSBcImF0dHJpYnV0ZXNcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IFJlZmxlY3QuZ2V0KGN1c3RvbUVsLCBhdHRyS2V5KTtcbiAgZm9yIChjb25zdCBwSyBpbiBwcm9wcykge1xuICAgIGNvbnN0IHBWID0gcHJvcHNbcEtdO1xuICAgIGlmIChcInR5cGVcIiBpbiBwViAmJiBwVi5hdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjdXN0b21FbCwgYXR0cktleSwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgW3BLXTogcFYuYXR0cmlidXRlXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1c3RvbUVsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVsTm9kZShub2Rlc1N5bWJvbCwgcmVmLCBrZXkpIHtcbiAgaWYgKHJlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICByZXR1cm4gcmVmO1xuICB9XG4gIGxldCBub2RlID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAgaWYgKGFjdHVhbEVsID09IG51bGwpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICBhY3R1YWxFbC5fX2lubmVyTm9kZXMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBpZiAoYWN0dWFsRWxbbm9kZXNTeW1ib2xdID09IG51bGwpIHtcbiAgICBhY3R1YWxFbFtub2Rlc1N5bWJvbF0gPSB7fTtcbiAgfVxuICBjb25zdCBub2RlcyA9IGFjdHVhbEVsW25vZGVzU3ltYm9sXTtcbiAgaWYgKG5vZGVzW2tleV0gPT0gbnVsbCkge1xuICAgIGFjdHVhbEVsLl9faW5uZXJOb2Rlcy5hZGQobm9kZSk7XG4gICAgbm9kZXNba2V5XSA9IG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vZGVzW2tleV07XG59IiwiaW1wb3J0IHsgRUcgfSBmcm9tICcuL0VHLmpzJztcbmltcG9ydCB7IE5HIH0gZnJvbSAnLi9ORy5qcyc7XG5leHBvcnQgY2xhc3MgVmlldyB7XG4gIGNvbnN0cnVjdG9yKF9yZW5kZXIpIHtcbiAgICB0aGlzLl9yZW5kZXIgPSBfcmVuZGVyO1xuICAgIHRoaXMuZWxlbWVudCA9IEVHO1xuICAgIHRoaXMubm9kZSA9IE5HO1xuICB9XG4gIGdldFJlbmRlckZuKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXI7XG4gIH1cbn0iLCJleHBvcnQgeyBFRyB9IGZyb20gJy4vRUcuanMnO1xuZXhwb3J0IHsgTkcgfSBmcm9tICcuL05HLmpzJztcbmV4cG9ydCB7IFZpZXcgfSBmcm9tICcuL1ZpZXcuanMnO1xuZXhwb3J0IHsgcCB9IGZyb20gJy4vdXRpbHMvcC5qcyc7IiwiaW1wb3J0e25vdGhpbmcgYXMgaX1mcm9tXCIuLi9saXQtaHRtbC5qc1wiO2ltcG9ydHtBc3luY0RpcmVjdGl2ZSBhcyB0fWZyb21cIi4uL2FzeW5jLWRpcmVjdGl2ZS5qc1wiO2ltcG9ydHtkaXJlY3RpdmUgYXMgc31mcm9tXCIuLi9kaXJlY3RpdmUuanNcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL2NvbnN0IGU9KCk9Pm5ldyBvO2NsYXNzIG97fWNvbnN0IGg9bmV3IFdlYWtNYXAsbj1zKGNsYXNzIGV4dGVuZHMgdHtyZW5kZXIodCl7cmV0dXJuIGl9dXBkYXRlKHQsW3NdKXt2YXIgZTtjb25zdCBvPXMhPT10aGlzLkc7cmV0dXJuIG8mJnZvaWQgMCE9PXRoaXMuRyYmdGhpcy5vdCh2b2lkIDApLChvfHx0aGlzLnJ0IT09dGhpcy5sdCkmJih0aGlzLkc9cyx0aGlzLmN0PW51bGw9PT0oZT10Lm9wdGlvbnMpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmhvc3QsdGhpcy5vdCh0aGlzLmx0PXQuZWxlbWVudCkpLGl9b3QoaSl7dmFyIHQ7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5HKXtjb25zdCBzPW51bGwhPT0odD10aGlzLmN0KSYmdm9pZCAwIT09dD90Omdsb2JhbFRoaXM7bGV0IGU9aC5nZXQocyk7dm9pZCAwPT09ZSYmKGU9bmV3IFdlYWtNYXAsaC5zZXQocyxlKSksdm9pZCAwIT09ZS5nZXQodGhpcy5HKSYmdGhpcy5HLmNhbGwodGhpcy5jdCx2b2lkIDApLGUuc2V0KHRoaXMuRyxpKSx2b2lkIDAhPT1pJiZ0aGlzLkcuY2FsbCh0aGlzLmN0LGkpfWVsc2UgdGhpcy5HLnZhbHVlPWl9Z2V0IHJ0KCl7dmFyIGksdCxzO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuRz9udWxsPT09KHQ9aC5nZXQobnVsbCE9PShpPXRoaXMuY3QpJiZ2b2lkIDAhPT1pP2k6Z2xvYmFsVGhpcykpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmdldCh0aGlzLkcpOm51bGw9PT0ocz10aGlzLkcpfHx2b2lkIDA9PT1zP3ZvaWQgMDpzLnZhbHVlfWRpc2Nvbm5lY3RlZCgpe3RoaXMucnQ9PT10aGlzLmx0JiZ0aGlzLm90KHZvaWQgMCl9cmVjb25uZWN0ZWQoKXt0aGlzLm90KHRoaXMubHQpfX0pO2V4cG9ydHtlIGFzIGNyZWF0ZVJlZixuIGFzIHJlZn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWYuanMubWFwXG4iLCJ2YXIgX3RlbXBsYXRlT2JqZWN0LCBfdGVtcGxhdGVPYmplY3QyLCBfdGVtcGxhdGVPYmplY3QzO1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJsaXQtaHRtbFwiO1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5pbXBvcnQgeyBwIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9nZmNcIjtcbmltcG9ydCB7IHNldFN0eWxlIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9oL3N0eWxlXCI7XG5pbXBvcnQgeyBsaXRWaWV3IH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9saXRcIjtcbmltcG9ydCB7IGNyZWF0ZVJlZiwgcmVmIH0gZnJvbSBcImxpdC1odG1sL2RpcmVjdGl2ZXMvcmVmLmpzXCI7XG5pbXBvcnQgc3R5bGUgZnJvbSBcIi4vc3R5bGVzL3NpZGVtZW51LmNzc1wiO1xuLyoqXG4gKiBTaWRlIG1lbnUgd2ViIGNvbXBvbmVudFxuICovXG5leHBvcnQgdmFyIHNpZGVtZW51RWxlbWVudCA9IGxpdFZpZXcuZWxlbWVudCh7XG4gIHByb3BzOiB7XG4gICAgLyoqIHBsYWNlaG9sZGVyIHRleHQgZm9yIHNlYXJjaCBpbnB1dCAqL1xuICAgIHNlYXJjaFBsYWNlaG9sZGVyOiBwLm9wdChcInNlYXJjaC1wbGFjZWhvbGRlclwiKSxcbiAgICAvKiogbWVudSBkYXRhICovXG4gICAgZGF0YTogcC5yZXEoKSxcbiAgICAvKiogbGFzdCBzZWxlY3RlZCBtZW51IGl0ZW0gKi9cbiAgICBhY3RpdmVNZW51SXRlbTogcC5yZXEoKSxcbiAgICAvLyBFVkVOVFM6XG4gICAgb25jaGFuZ2VBY3RpdmU6IHAub3B0KClcbiAgfVxufSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBhcmFtcykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgaW5wdXRFbFJlZiwgX2hpZGVNZW51SXRlbXMsIGhhbmRsZU1lbnVMaW5rQ2xpY2ssIGhhbmRsZVNlYXJjaEtleXVwLCBzZWFyY2gsIG1ha2VNZW51LCBfcGFyYW1zJHNlYXJjaFBsYWNlaG87XG4gIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIG1ha2VNZW51ID0gZnVuY3Rpb24gX21ha2VNZW51KCkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgICAgLy8gbmVzdGVkIG1lbnUgbGV2ZWxcbiAgICAgICAgICB2YXIgZGVlcExldmVsID0gMDtcbiAgICAgICAgICB2YXIgZmluZExldmVsID0gZnVuY3Rpb24gZmluZExldmVsKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZGVlcExldmVsKys7XG4gICAgICAgICAgICAgIGlmIChpdGVtLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluZExldmVsKHBhcmFtcy5kYXRhW2l0ZW0ucGFyZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhcmFtcy5kYXRhICYmIHBhcmVudCAmJiBmaW5kTGV2ZWwocGFyYW1zLmRhdGFbcGFyZW50XSk7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtcy5kYXRhICYmIE9iamVjdC5rZXlzKHBhcmFtcy5kYXRhKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJhbXMuZGF0YVtrZXldLnBhcmVudCB8fCBudWxsKSA9PT0gcGFyZW50O1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgICAgICBwYXJhbXMuZGF0YVtrZXldLmF2YWlsYWJsZSAmJiBzdHlsZXMucHVzaChcImN1cnNvcjogcG9pbnRlclwiKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZGF0YVtrZXldLmNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgIHZhciBjYXRlZ29yeUNzc0NsYXNzID0gW1wiaW5zdW0tbWVudS1jYXRlZ29yeV9fdGl0bGVcIl07XG4gICAgICAgICAgICAgIHBhcmFtcy5hY3RpdmVNZW51SXRlbSA9PT0ga2V5ICYmIGNhdGVnb3J5Q3NzQ2xhc3MucHVzaChcImluc3VtLW1lbnUtY2F0ZWdvcnlfX3RpdGxlX2FjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5kYXRhW2tleV0uaGlkZSA/IHVuZGVmaW5lZCA6IGh0bWwoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxkaXYgY2xhc3M9XFxcImluc3VtLW1lbnUtY2F0ZWdvcnlcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBAY2xpY2s9XCIsIFwiIGNsYXNzPVwiLCBcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgICA8L2Rpdj5cIl0pKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTWVudUxpbmtDbGljayhlLCBrZXkpO1xuICAgICAgICAgICAgICB9LCBjYXRlZ29yeUNzc0NsYXNzLmpvaW4oXCIgXCIpLCBzdHlsZXMuam9pbihcIjtcIiksIHBhcmFtcy5kYXRhW2tleV0ubGFiZWwsIG1ha2VNZW51KGtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGxpbmtDc3NDbGFzcyA9IFtcImluc3VtLW1lbnUtY2F0ZWdvcnlfX2xpbmtcIl07XG4gICAgICAgICAgICAgIHBhcmFtcy5hY3RpdmVNZW51SXRlbSA9PT0ga2V5ICYmIGxpbmtDc3NDbGFzcy5wdXNoKFwiaW5zdW0tbWVudS1jYXRlZ29yeV9fbGlua19hY3RpdmVcIik7XG4gICAgICAgICAgICAgIF9oaWRlTWVudUl0ZW1zLmluY2x1ZGVzKGtleSkgJiYgbGlua0Nzc0NsYXNzLnB1c2goXCJpbnN1bS1tZW51LWNhdGVnb3J5X19saW5rX2hpZGVcIik7XG4gICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwicGFkZGluZy1sZWZ0OiBcIi5jb25jYXQoZGVlcExldmVsICogMTAgKyAxMCwgXCJweFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZGF0YVtrZXldLmhpZGUgPyB1bmRlZmluZWQgOiBodG1sKF90ZW1wbGF0ZU9iamVjdDIgfHwgKF90ZW1wbGF0ZU9iamVjdDIgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgICAgICAgICA8ZGl2IEBjbGljaz1cIiwgXCIgY2xhc3M9XCIsIFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgICAgXCJdKSksIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1lbnVMaW5rQ2xpY2soZSwga2V5KTtcbiAgICAgICAgICAgICAgfSwgbGlua0Nzc0NsYXNzLmpvaW4oXCIgXCIpLCBzdHlsZXMuam9pbihcIjtcIiksIHBhcmFtcy5kYXRhW2tleV0ubGFiZWwsIG1ha2VNZW51KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuYXR0YWNoU2hhZG93KHtcbiAgICAgICAgICBtb2RlOiBcIm9wZW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgc2V0U3R5bGUoc3R5bGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgaW5wdXRFbFJlZiA9IGNyZWF0ZVJlZigpOyAvLyBsaXN0IG9mIGhpZGVkIG1lbnUgaXRlbXMgKGFmdGVyIGZpbHRlcilcbiAgICAgICAgX2hpZGVNZW51SXRlbXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgZm9yIGNsaWNrIGJ5IG1lbnUgaXRlbVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBjbGljayBldmVudFxuICAgICAgICAgKiBAcGFyYW0gaXRlbUtleSAtIGl0ZW0gSURcbiAgICAgICAgICovXG4gICAgICAgIGhhbmRsZU1lbnVMaW5rQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVNZW51TGlua0NsaWNrKGV2ZW50LCBpdGVtS2V5KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtS2V5KTtcbiAgICAgICAgICBpZiAocGFyYW1zLmRhdGFbaXRlbUtleV0uYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBwYXJhbXMuYWN0aXZlTWVudUl0ZW0gPSBpdGVtS2V5O1xuICAgICAgICAgICAgdmFyIGNoYW5nZUFjdGl2ZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiY2hhbmdlQWN0aXZlXCIsIHtcbiAgICAgICAgICAgICAgZGV0YWlsOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcy5kYXRhW2l0ZW1LZXldKSwge30sIHtcbiAgICAgICAgICAgICAgICBrZXk6IGl0ZW1LZXlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VBY3RpdmVFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlciBmb3Iga2V5dXAgaW5zaWRlIHNlYXJjaCBmaWVsZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBrZXl1cCBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlU2VhcmNoS2V5dXAgPSBmdW5jdGlvbiBoYW5kbGVTZWFyY2hLZXl1cChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gXCJ2YWx1ZVwiIGluIGV2ZW50LnRhcmdldCA/IFN0cmluZyhldmVudC50YXJnZXRbXCJ2YWx1ZVwiXSkgOiBcIlwiO1xuICAgICAgICAgICAgc2VhcmNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWx0ZXIgbWVudSBpdGVtcyBieSB0ZXh0IGluc2lkZSBzZWFyY2ggZmllbGRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlYXJjaEZvciAtIHRleHQgZnJvbSBzZWFyY2ggZmllbGRcbiAgICAgICAgICovXG4gICAgICAgIHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChzZWFyY2hGb3IpIHtcbiAgICAgICAgICBfaGlkZU1lbnVJdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGZvciAodmFyIGl0ZW0gaW4gcGFyYW1zLmRhdGEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZGF0YVtpdGVtXS5sYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoRm9yLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgICAgICAgICBfaGlkZU1lbnVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBzdWItbWVudSB0ZW1wbGF0ZSBiYXNlIG9uIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmVudCAtIHBhcmVudCBpdGVtIGtleVxuICAgICAgICAgKi9cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX2lucHV0RWxSZWYkdmFsdWU7XG4gICAgICAgICAgKF9pbnB1dEVsUmVmJHZhbHVlID0gaW5wdXRFbFJlZi52YWx1ZSkgPT09IG51bGwgfHwgX2lucHV0RWxSZWYkdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbnB1dEVsUmVmJHZhbHVlLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSA5OlxuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKF9wYXJhbXMkc2VhcmNoUGxhY2VobyA9IHBhcmFtcy5zZWFyY2hQbGFjZWhvbGRlcikgIT09IG51bGwgJiYgX3BhcmFtcyRzZWFyY2hQbGFjZWhvICE9PSB2b2lkIDAgPyBfcGFyYW1zJHNlYXJjaFBsYWNlaG8gOiBwYXJhbXMuc2VhcmNoUGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDMgfHwgKF90ZW1wbGF0ZU9iamVjdDMgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxkaXYgY2xhc3M9XFxcImluc3VtLW1lbnVfX3NpZGVuYXZcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5zdW0tbWVudS1zZWFyY2hcXFwiPlxcbiAgICAgICAgICA8aW5zdW0tc2VhcmNoLWljb24gY2xhc3M9XFxcImluc3VtLW1lbnUtc2VhcmNoX19pY29uXFxcIj48L2luc3VtLXNlYXJjaC1pY29uPlxcbiAgICAgICAgICA8aW5wdXQgQGtleXVwPVwiLCBcIiB0eXBlPVxcXCJ0ZXh0XFxcIiAucGxhY2Vob2xkZXI9XCIsIFwiIC5yZWY9XCIsIFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIDxzbG90Pjwvc2xvdD5cXG4gICAgICA8L2Rpdj5cIl0pKSwgaGFuZGxlU2VhcmNoS2V5dXAsIHBhcmFtcy5zZWFyY2hQbGFjZWhvbGRlciwgcmVmKGlucHV0RWxSZWYpLCBtYWtlTWVudSgpKTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHBhcmFtcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTY6XG4gICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgfVxuICB9LCBfY2FsbGVlLCB0aGlzKTtcbn0pKTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG52YXIgX3RlbXBsYXRlT2JqZWN0O1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJsaXQtaHRtbFwiO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTsgfVxuaW1wb3J0IHsgbGl0VmlldyB9IGZyb20gXCJAd2ViLWNvbXBhbmlvbnMvbGl0XCI7XG5leHBvcnQgdmFyIGNvdW50ZXJOb2RlID0gbGl0Vmlldy5ub2RlKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm9wcykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgY291bnQsIF9wcm9wcztcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTsgLy8ganVzdCBmb3IgdGVzdHNcbiAgICAgICAgX2NvbnRleHQucHJldiA9IDI7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBAY2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGk+XCIsIFwiPC9pPlxcbiAgICAgICAgXCJdKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb3VudCsrLCBfdGhpcy5uZXh0KCk7XG4gICAgICAgIH0sIChfcHJvcHMgPSBwcm9wcykgPT09IG51bGwgfHwgX3Byb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvcHMubXNnLCBjb3VudCk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHByb3BzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OlxuICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgY29uc29sZS5sb2coXCJBIENvdW50ZXJOb2RlIHdpdGggbGl0LWh0bWwgcmVuZGVyIHdhcyBkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goOSk7XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgIH1cbiAgfSwgX2NhbGxlZSwgdGhpcywgW1syLCwgOSwgMTJdXSk7XG59KSk7XG4vLyBpbXBvcnQgeyBORyB9IGZyb20gJ0B3ZWItY29tcGFuaW9ucy9nZmMnO1xuLy8gaW1wb3J0IHsgaHRtbCwgcmVuZGVyIH0gZnJvbSAndWh0bWwnO1xuLy8gZnVuY3Rpb24gcmVuZGVyTm9kZShub2RlOiB7IGN1cnJlbnQ6IG9iamVjdCB8IE5vZGUgfCBudWxsIH0sIHRwbDogYW55KSB7XG4vLyAgIGlmIChub2RlLmN1cnJlbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4vLyAgICAgcmVuZGVyKG5vZGUuY3VycmVudCwgaHRtbGAke3RwbH1gKTtcbi8vICAgICByZXR1cm4gdW5kZWZpbmVkO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIGNvbnN0IGEgPSBodG1sLmZvcihub2RlKWAke3RwbH1gO1xuLy8gICAgIHJldHVybiBhO1xuLy8gICB9XG4vLyB9XG4vLyBleHBvcnQgY29uc3QgY291bnRlck5vZGUgPSBORygpKGZ1bmN0aW9uKiAocHJvcHM6IHsgbXNnOiBzdHJpbmcgfSkge1xuLy8gICBsZXQgY291bnQgPSAwO1xuLy8gICB0aGlzLm5leHQoKTsgLy8ganVzdCBmb3IgdGVzdHNcbi8vICAgd2hpbGUgKHRydWUpIHtcbi8vICAgICBwcm9wcyA9IHlpZWxkIHJlbmRlck5vZGUoXG4vLyAgICAgICB0aGlzLFxuLy8gICAgICAgPD5cbi8vICAgICAgICAgPGJ1dHRvblxuLy8gICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuLy8gICAgICAgICAgIG9uY2xpY2s9eygpID0+IHtcbi8vICAgICAgICAgICAgIGNvdW50KyssIHRoaXMubmV4dCgpO1xuLy8gICAgICAgICAgIH19XG4vLyAgICAgICAgID5cbi8vICAgICAgICAgICB7cHJvcHM/Lm1zZ31cbi8vICAgICAgICAgPC9idXR0b24+XG4vLyAgICAgICAgIDxpPntjb3VudH08L2k+XG4vLyAgICAgICA8Lz5cbi8vICAgICApO1xuLy8gICB9XG4vLyB9KTsiLCJleHBvcnQgZnVuY3Rpb24gaXMoY29uZGl0aW9uLCB2YWx1ZSkge1xuICByZXR1cm4gY29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxudmFyIF90ZW1wbGF0ZU9iamVjdCwgX3RlbXBsYXRlT2JqZWN0MjtcbmltcG9ydCB7IGh0bWwgfSBmcm9tIFwibGl0LWh0bWxcIjtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykgeyBpZiAoIXJhdykgeyByYXcgPSBzdHJpbmdzLnNsaWNlKDApOyB9IHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHsgcmF3OiB7IHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdykgfSB9KSk7IH1cbmltcG9ydCB7IHAgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2dmY1wiO1xuaW1wb3J0IHsgY291bnRlck5vZGUgfSBmcm9tIFwiLi9jb3VudGVyLm5vZGVcIjtcbmltcG9ydCB7IGxpdFZpZXcgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2xpdFwiO1xuaW1wb3J0IHsgaXMgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2gvdGVtcGxhdGVcIjtcbnZhciBDb3VudGVyTm9kZSA9IGNvdW50ZXJOb2RlKCk7XG52YXIgQ291bnRlck5vZGUxID0gY291bnRlck5vZGUoKTtcbmV4cG9ydCB2YXIgY291bnRlckVsZW1lbnQgPSBsaXRWaWV3LmVsZW1lbnQoe1xuICBwcm9wczoge1xuICAgIG1zZzogcC5yZXEoKVxuICB9XG59KSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocHJvcHMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIGNvdW50LCBpc1Nob3dpbmdUZW1wRWwsIF9wcm9wcztcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICBpc1Nob3dpbmdUZW1wRWwgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNTaG93aW5nVGVtcEVsID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpcy5uZXh0KCk7XG4gICAgICAgIH0sIDIwMDApO1xuICAgICAgICBfY29udGV4dC5wcmV2ID0gMztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG5cXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxpPlwiLCBcIjwvaT5cXG4gICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgIFwiLCBcIlxcblxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XCJdKSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgIF90aGlzLm5leHQoKTtcbiAgICAgICAgfSwgKF9wcm9wcyA9IHByb3BzKSA9PT0gbnVsbCB8fCBfcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9wcy5tc2csIGNvdW50LCBDb3VudGVyTm9kZSh7XG4gICAgICAgICAga2V5OiBcIjFcIixcbiAgICAgICAgICBtc2c6IFwiQ291bnRlciBOb2RlIGFzIEpTWCBUYWcxXCJcbiAgICAgICAgfSksIENvdW50ZXJOb2RlKHtcbiAgICAgICAgICBrZXk6IFwiMlwiLFxuICAgICAgICAgIG1zZzogXCJDb3VudGVyIE5vZGUgYXMgSlNYIFRhZzJcIlxuICAgICAgICB9KSwgQ291bnRlck5vZGUoe1xuICAgICAgICAgIG1zZzogXCJDb3VudGVyIE5vZGUgYXMgSlNYIFRhZzNcIlxuICAgICAgICB9KSwgaXMoaXNTaG93aW5nVGVtcEVsLCBodG1sKF90ZW1wbGF0ZU9iamVjdDIgfHwgKF90ZW1wbGF0ZU9iamVjdDIgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlwiLCBcIlwiXSkpLCBDb3VudGVyTm9kZTEoe1xuICAgICAgICAgIG1zZzogXCJDb3VudGVyIE5vZGUgYXMgSlNYIEJ5IGNvbmRpdGlvblwiXG4gICAgICAgIH0pKSkpO1xuICAgICAgY2FzZSA3OlxuICAgICAgICBwcm9wcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIF9jb250ZXh0LnByZXYgPSAxMDtcbiAgICAgICAgY29uc29sZS5sb2coXCJBIENvdW50ZXJFbGVtZW50IHdpdGggbGl0LWh0bWwgcmVuZGVyIHdhcyBkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMTApO1xuICAgICAgY2FzZSAxMzpcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICB9XG4gIH0sIF9jYWxsZWUsIG51bGwsIFtbMywsIDEwLCAxM11dKTtcbn0pKTsiLCJleHBvcnQgZnVuY3Rpb24qIHBhcnNlKHRleHQpIHtcbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgdG9rZW5TdGFydCA9IDA7XG4gICAgbGV0IG9wZW4gPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRleHRbaV0gPT09ICd7JyAmJiB0ZXh0W2kgKyAxXSA9PT0gJ3snICYmIHRleHRbaSAtIDFdICE9PSAnXFxcXCcgJiYgIW9wZW4pIHtcbiAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ3N0cmluZycsIHN0YXJ0OiB0b2tlblN0YXJ0LCBlbmQ6IGksIHZhbHVlIH07XG4gICAgICAgICAgICB2YWx1ZSA9ICd7eyc7XG4gICAgICAgICAgICB0b2tlblN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0W2ldID09PSAnfScgJiYgdGV4dFtpICsgMV0gPT09ICd9JyAmJiB0ZXh0W2kgLSAxXSAhPT0gJ1xcXFwnICYmIG9wZW4pIHtcbiAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ3BhcnQnLCBzdGFydDogdG9rZW5TdGFydCwgZW5kOiBpICsgMiwgdmFsdWU6IHZhbHVlLnNsaWNlKDIpLnRyaW0oKSB9O1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIHRva2VuU3RhcnQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHRleHRbaV0gfHwgJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgeWllbGQgeyB0eXBlOiAnc3RyaW5nJywgc3RhcnQ6IHRva2VuU3RhcnQsIGVuZDogdGV4dC5sZW5ndGgsIHZhbHVlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1zdHJpbmctcGFyc2VyLmpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3NldHRlciwgX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF92YWx1ZTtcbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVUZW1wbGF0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKHNldHRlciwgZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3NldHRlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF92YWx1ZS5zZXQodGhpcywgJycpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BdHRyaWJ1dGVUZW1wbGF0ZVBhcnRfc2V0dGVyLCBzZXR0ZXIsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3NldHRlciwgXCJmXCIpLnVwZGF0ZVBhcmVudCgnJyk7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3NldHRlciwgXCJmXCIpLmF0dHIubmFtZTtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF9zZXR0ZXIsIFwiZlwiKS5hdHRyLm5hbWVzcGFjZVVSSTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3ZhbHVlLCBcImZcIik7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BdHRyaWJ1dGVUZW1wbGF0ZVBhcnRfdmFsdWUsIHZhbHVlIHx8ICcnLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF9zZXR0ZXIsIFwiZlwiKS51cGRhdGVQYXJlbnQodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF9zZXR0ZXIsIFwiZlwiKS5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgYm9vbGVhblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3NldHRlciwgXCJmXCIpLmJvb2xlYW5WYWx1ZTtcbiAgICB9XG4gICAgc2V0IGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BdHRyaWJ1dGVUZW1wbGF0ZVBhcnRfc2V0dGVyLCBcImZcIikuYm9vbGVhblZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuX0F0dHJpYnV0ZVRlbXBsYXRlUGFydF9zZXR0ZXIgPSBuZXcgV2Vha01hcCgpLCBfQXR0cmlidXRlVGVtcGxhdGVQYXJ0X3ZhbHVlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVWYWx1ZVNldHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnBhcnRMaXN0ID0gW107XG4gICAgfVxuICAgIGdldCBib29sZWFuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlTlModGhpcy5hdHRyLm5hbWVzcGFjZVVSSSwgdGhpcy5hdHRyLm5hbWUpO1xuICAgIH1cbiAgICBzZXQgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRMaXN0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQnLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucGFydExpc3RbMF0udmFsdWUgPSB2YWx1ZSA/ICcnIDogbnVsbDtcbiAgICB9XG4gICAgYXBwZW5kKHBhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnQocGFydFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRMaXN0Lmxlbmd0aCA9PT0gMSAmJiBwYXJ0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyh0aGlzLmF0dHIubmFtZXNwYWNlVVJJLCB0aGlzLmF0dHIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSB0aGlzLnBhcnRMaXN0Lm1hcChzID0+ICh0eXBlb2YgcyA9PT0gJ3N0cmluZycgPyBzIDogcy52YWx1ZSkpLmpvaW4oJycpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKHRoaXMuYXR0ci5uYW1lc3BhY2VVUkksIHRoaXMuYXR0ci5uYW1lLCBzdHIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXR0cmlidXRlLXRlbXBsYXRlLXBhcnQuanMubWFwIiwidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9Ob2RlVGVtcGxhdGVQYXJ0X3BhcnRzO1xuZXhwb3J0IGNsYXNzIE5vZGVUZW1wbGF0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMsIFtub2RlXSwgXCJmXCIpO1xuICAgICAgICBub2RlLnRleHRDb250ZW50ID0gJyc7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMsIFwiZlwiKS5tYXAobm9kZSA9PiBub2RlLnRleHRDb250ZW50KS5qb2luKCcnKTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHN0cmluZykge1xuICAgICAgICB0aGlzLnJlcGxhY2Uoc3RyaW5nKTtcbiAgICB9XG4gICAgZ2V0IHByZXZpb3VzU2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMsIFwiZlwiKVswXS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMsIFwiZlwiKVtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Ob2RlVGVtcGxhdGVQYXJ0X3BhcnRzLCBcImZcIikubGVuZ3RoIC0gMV0ubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJlcGxhY2UoLi4ubm9kZXMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBub2Rlcy5tYXAobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG5ldyBUZXh0KCcnKSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX05vZGVUZW1wbGF0ZVBhcnRfcGFydHMsIFwiZlwiKVswXS5iZWZvcmUoLi4ucGFydHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTm9kZVRlbXBsYXRlUGFydF9wYXJ0cywgXCJmXCIpKVxuICAgICAgICAgICAgcGFydC5yZW1vdmUoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTm9kZVRlbXBsYXRlUGFydF9wYXJ0cywgcGFydHMsIFwiZlwiKTtcbiAgICB9XG59XG5fTm9kZVRlbXBsYXRlUGFydF9wYXJ0cyA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLXRlbXBsYXRlLXBhcnQuanMubWFwIiwiaW1wb3J0IHsgQXR0cmlidXRlVGVtcGxhdGVQYXJ0IH0gZnJvbSAnLi9hdHRyaWJ1dGUtdGVtcGxhdGUtcGFydC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc29yKHByb2Nlc3NQYXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlQ2FsbGJhY2soaW5zdGFuY2UsIHBhcnRzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0NhbGxiYWNrKGluc3RhbmNlLCBwYXJ0cywgcGFyYW1zKTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc0NhbGxiYWNrKF8sIHBhcnRzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCAhcGFyYW1zKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LmV4cHJlc3Npb24gaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKF9hID0gcGFyYW1zW3BhcnQuZXhwcmVzc2lvbl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUGFydChwYXJ0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzUHJvcGVydHlJZGVudGl0eShwYXJ0LCB2YWx1ZSkge1xuICAgIHBhcnQudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NCb29sZWFuQXR0cmlidXRlKHBhcnQsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgIHBhcnQgaW5zdGFuY2VvZiBBdHRyaWJ1dGVUZW1wbGF0ZVBhcnQgJiZcbiAgICAgICAgdHlwZW9mIHBhcnQuZWxlbWVudFtwYXJ0LmF0dHJpYnV0ZU5hbWVdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcGFydC5ib29sZWFuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjb25zdCBwcm9wZXJ0eUlkZW50aXR5ID0gY3JlYXRlUHJvY2Vzc29yKHByb2Nlc3NQcm9wZXJ0eUlkZW50aXR5KTtcbmV4cG9ydCBjb25zdCBwcm9wZXJ0eUlkZW50aXR5T3JCb29sZWFuQXR0cmlidXRlID0gY3JlYXRlUHJvY2Vzc29yKChwYXJ0LCB2YWx1ZSkgPT4ge1xuICAgIHByb2Nlc3NCb29sZWFuQXR0cmlidXRlKHBhcnQsIHZhbHVlKSB8fCBwcm9jZXNzUHJvcGVydHlJZGVudGl0eShwYXJ0LCB2YWx1ZSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3NvcnMuanMubWFwIiwidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9UZW1wbGF0ZUluc3RhbmNlX3Byb2Nlc3NvciwgX1RlbXBsYXRlSW5zdGFuY2VfcGFydHM7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJy4vdGVtcGxhdGUtc3RyaW5nLXBhcnNlci5qcyc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVWYWx1ZVNldHRlciwgQXR0cmlidXRlVGVtcGxhdGVQYXJ0IH0gZnJvbSAnLi9hdHRyaWJ1dGUtdGVtcGxhdGUtcGFydC5qcyc7XG5pbXBvcnQgeyBOb2RlVGVtcGxhdGVQYXJ0IH0gZnJvbSAnLi9ub2RlLXRlbXBsYXRlLXBhcnQuanMnO1xuaW1wb3J0IHsgcHJvcGVydHlJZGVudGl0eSB9IGZyb20gJy4vcHJvY2Vzc29ycy5qcyc7XG5mdW5jdGlvbiogY29sbGVjdFBhcnRzKGVsKSB7XG4gICAgY29uc3Qgd2Fsa2VyID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCB8IE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCBudWxsLCBmYWxzZSk7XG4gICAgbGV0IG5vZGU7XG4gICAgd2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgJiYgYXR0ci52YWx1ZS5pbmNsdWRlcygne3snKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNldHRlciA9IG5ldyBBdHRyaWJ1dGVWYWx1ZVNldHRlcihub2RlLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBwYXJzZShhdHRyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXR0ZXIuYXBwZW5kKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBuZXcgQXR0cmlidXRlVGVtcGxhdGVQYXJ0KHZhbHVlU2V0dGVyLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTZXR0ZXIuYXBwZW5kKHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgbm9kZS50ZXh0Q29udGVudCAmJiBub2RlLnRleHRDb250ZW50LmluY2x1ZGVzKCd7eycpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKG5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmVuZCA8IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2RlLnNwbGl0VGV4dCh0b2tlbi5lbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAncGFydCcpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBOb2RlVGVtcGxhdGVQYXJ0KG5vZGUsIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIGV4dGVuZHMgRG9jdW1lbnRGcmFnbWVudCB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHBhcmFtcywgcHJvY2Vzc29yID0gcHJvcGVydHlJZGVudGl0eSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfVGVtcGxhdGVJbnN0YW5jZV9wcm9jZXNzb3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9UZW1wbGF0ZUluc3RhbmNlX3BhcnRzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvLyBUaGlzIGlzIHRvIGZpeCBhbiBpbmNvbnNpc3RlbmN5IGluIFNhZmFyaSB3aGljaCBwcmV2ZW50cyB1cyBmcm9tXG4gICAgICAgIC8vIGNvcnJlY3RseSBzdWItY2xhc3NpbmcgRG9jdW1lbnRGcmFnbWVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTU1NlxuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBUZW1wbGF0ZUluc3RhbmNlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRlbXBsYXRlSW5zdGFuY2UucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRlbXBsYXRlLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfVGVtcGxhdGVJbnN0YW5jZV9wYXJ0cywgQXJyYXkuZnJvbShjb2xsZWN0UGFydHModGhpcykpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1RlbXBsYXRlSW5zdGFuY2VfcHJvY2Vzc29yLCBwcm9jZXNzb3IsIFwiZlwiKTtcbiAgICAgICAgKF9iID0gKF9hID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVGVtcGxhdGVJbnN0YW5jZV9wcm9jZXNzb3IsIFwiZlwiKSkuY3JlYXRlQ2FsbGJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0aGlzLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9UZW1wbGF0ZUluc3RhbmNlX3BhcnRzLCBcImZcIiksIHBhcmFtcyk7XG4gICAgfVxuICAgIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVGVtcGxhdGVJbnN0YW5jZV9wcm9jZXNzb3IsIFwiZlwiKS5wcm9jZXNzQ2FsbGJhY2sodGhpcywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVGVtcGxhdGVJbnN0YW5jZV9wYXJ0cywgXCJmXCIpLCBwYXJhbXMpO1xuICAgIH1cbn1cbl9UZW1wbGF0ZUluc3RhbmNlX3Byb2Nlc3NvciA9IG5ldyBXZWFrTWFwKCksIF9UZW1wbGF0ZUluc3RhbmNlX3BhcnRzID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBsYXRlLWluc3RhbmNlLmpzLm1hcCIsImV4cG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UgfSBmcm9tICcuL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmV4cG9ydCB7IHBhcnNlIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdHJpbmctcGFyc2VyLmpzJztcbmV4cG9ydCB7IEF0dHJpYnV0ZVRlbXBsYXRlUGFydCwgQXR0cmlidXRlVmFsdWVTZXR0ZXIgfSBmcm9tICcuL2F0dHJpYnV0ZS10ZW1wbGF0ZS1wYXJ0LmpzJztcbmV4cG9ydCB7IE5vZGVUZW1wbGF0ZVBhcnQgfSBmcm9tICcuL25vZGUtdGVtcGxhdGUtcGFydC5qcyc7XG5leHBvcnQgeyBjcmVhdGVQcm9jZXNzb3IsIHByb2Nlc3NQcm9wZXJ0eUlkZW50aXR5LCBwcm9jZXNzQm9vbGVhbkF0dHJpYnV0ZSwgcHJvcGVydHlJZGVudGl0eSwgcHJvcGVydHlJZGVudGl0eU9yQm9vbGVhbkF0dHJpYnV0ZSB9IGZyb20gJy4vcHJvY2Vzc29ycy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJjb25zdCBkaXJlY3RpdmVzID0gbmV3IFdlYWtTZXQoKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0RpcmVjdGl2ZShkaXJlY3RpdmVDYWxsYmFjaykge1xuICAgIHJldHVybiBkaXJlY3RpdmVzLmhhcyhkaXJlY3RpdmVDYWxsYmFjayk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0RpcmVjdGl2ZShwYXJ0LCB2YWx1ZSkge1xuICAgIGlmIChpc0RpcmVjdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUocGFydCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlyZWN0aXZlKGRpcmVjdGl2ZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gKC4uLnZhbHVlcykgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGRpcmVjdGl2ZUZhY3RvcnkoLi4udmFsdWVzKTtcbiAgICAgICAgZGlyZWN0aXZlcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpcmVjdGl2ZS5qcy5tYXAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVUZW1wbGF0ZVBhcnQgfSBmcm9tICdAZ2l0aHViL3RlbXBsYXRlLXBhcnRzJztcbmNvbnN0IGV2ZW50TGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNsYXNzIEV2ZW50SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgdHlwZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMpO1xuICAgICAgICBldmVudExpc3RlbmVycy5nZXQodGhpcy5lbGVtZW50KS5zZXQodGhpcy50eXBlLCB0aGlzKTtcbiAgICB9XG4gICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IGxpc3RlbmVyLmJpbmQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBsaXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IGxpc3RlbmVyLmhhbmRsZUV2ZW50LmJpbmQobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy50eXBlLCB0aGlzKTtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLmdldCh0aGlzLmVsZW1lbnQpLmRlbGV0ZSh0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmb3IocGFydCkge1xuICAgICAgICBpZiAoIWV2ZW50TGlzdGVuZXJzLmhhcyhwYXJ0LmVsZW1lbnQpKVxuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc2V0KHBhcnQuZWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnQuYXR0cmlidXRlTmFtZS5zbGljZSgyKTtcbiAgICAgICAgY29uc3QgZWxlbWVudExpc3RlbmVycyA9IGV2ZW50TGlzdGVuZXJzLmdldChwYXJ0LmVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudExpc3RlbmVycy5oYXModHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudExpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRIYW5kbGVyKHBhcnQuZWxlbWVudCwgdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NFdmVudChwYXJ0LCB2YWx1ZSkge1xuICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgQXR0cmlidXRlVGVtcGxhdGVQYXJ0ICYmIHBhcnQuYXR0cmlidXRlTmFtZS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5mb3IocGFydCkuc2V0KHZhbHVlKTtcbiAgICAgICAgcGFydC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKHBhcnQuYXR0cmlidXRlTmFtZXNwYWNlLCBwYXJ0LmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsImltcG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UsIE5vZGVUZW1wbGF0ZVBhcnQsIGNyZWF0ZVByb2Nlc3NvciwgcHJvY2Vzc1Byb3BlcnR5SWRlbnRpdHksIHByb2Nlc3NCb29sZWFuQXR0cmlidXRlIH0gZnJvbSAnQGdpdGh1Yi90ZW1wbGF0ZS1wYXJ0cyc7XG5pbXBvcnQgeyBwcm9jZXNzRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgcHJvY2Vzc0V2ZW50IH0gZnJvbSAnLi9ldmVudHMuanMnO1xuZnVuY3Rpb24gcHJvY2Vzc1N1YlRlbXBsYXRlKHBhcnQsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZXN1bHQgJiYgcGFydCBpbnN0YW5jZW9mIE5vZGVUZW1wbGF0ZVBhcnQpIHtcbiAgICAgICAgdmFsdWUucmVuZGVySW50byhwYXJ0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NEb2N1bWVudEZyYWdtZW50KHBhcnQsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCAmJiBwYXJ0IGluc3RhbmNlb2YgTm9kZVRlbXBsYXRlUGFydCkge1xuICAgICAgICBpZiAodmFsdWUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICBwYXJ0LnJlcGxhY2UoLi4udmFsdWUuY2hpbGROb2Rlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0l0ZXJhYmxlKHBhcnQsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgTm9kZVRlbXBsYXRlUGFydCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGVtcGxhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbmRlckludG8oZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goLi4uZnJhZ21lbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goLi4uaXRlbS5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgcGFydC5yZXBsYWNlKC4uLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJ0LnZhbHVlID0gQXJyYXkuZnJvbSh2YWx1ZSkuam9pbignICcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1BhcnQocGFydCwgdmFsdWUpIHtcbiAgICBwcm9jZXNzRGlyZWN0aXZlKHBhcnQsIHZhbHVlKSB8fFxuICAgICAgICBwcm9jZXNzQm9vbGVhbkF0dHJpYnV0ZShwYXJ0LCB2YWx1ZSkgfHxcbiAgICAgICAgcHJvY2Vzc0V2ZW50KHBhcnQsIHZhbHVlKSB8fFxuICAgICAgICBwcm9jZXNzU3ViVGVtcGxhdGUocGFydCwgdmFsdWUpIHx8XG4gICAgICAgIHByb2Nlc3NEb2N1bWVudEZyYWdtZW50KHBhcnQsIHZhbHVlKSB8fFxuICAgICAgICBwcm9jZXNzSXRlcmFibGUocGFydCwgdmFsdWUpIHx8XG4gICAgICAgIHByb2Nlc3NQcm9wZXJ0eUlkZW50aXR5KHBhcnQsIHZhbHVlKTtcbn1cbmNvbnN0IHRlbXBsYXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZW5kZXJlZFRlbXBsYXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZW5kZXJlZFRlbXBsYXRlSW5zdGFuY2VzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cbiAgICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZXMuaGFzKHRoaXMuc3RyaW5ncykpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZXMuZ2V0KHRoaXMuc3RyaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMuc3RyaW5ncy5yZWR1Y2UoKHN0ciwgY3VyLCBpKSA9PiBzdHIgKyBjdXIgKyAoaSA8IGVuZCA/IGB7eyAke2l9IH19YCA6ICcnKSwgJycpO1xuICAgICAgICAgICAgdGVtcGxhdGVzLnNldCh0aGlzLnN0cmluZ3MsIHRlbXBsYXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJJbnRvKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICBpZiAocmVuZGVyZWRUZW1wbGF0ZXMuZ2V0KGVsZW1lbnQpICE9PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmVuZGVyZWRUZW1wbGF0ZXMuc2V0KGVsZW1lbnQsIHRlbXBsYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlSW5zdGFuY2UodGVtcGxhdGUsIHRoaXMudmFsdWVzLCB0aGlzLnByb2Nlc3Nvcik7XG4gICAgICAgICAgICByZW5kZXJlZFRlbXBsYXRlSW5zdGFuY2VzLnNldChlbGVtZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIE5vZGVUZW1wbGF0ZVBhcnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlcGxhY2UoLi4uaW5zdGFuY2UuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZWRUZW1wbGF0ZUluc3RhbmNlcy5nZXQoZWxlbWVudCkudXBkYXRlKHRoaXMudmFsdWVzKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0UHJvY2Vzc29yID0gY3JlYXRlUHJvY2Vzc29yKHByb2Nlc3NQYXJ0KTtcbmV4cG9ydCBmdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgIHJldHVybiBuZXcgVGVtcGxhdGVSZXN1bHQoc3RyaW5ncywgdmFsdWVzLCBkZWZhdWx0UHJvY2Vzc29yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIocmVzdWx0LCBlbGVtZW50KSB7XG4gICAgcmVzdWx0LnJlbmRlckludG8oZWxlbWVudCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odG1sLmpzLm1hcCIsImltcG9ydCB7IHByb2Nlc3NQYXJ0IH0gZnJvbSAnLi9odG1sLmpzJztcbmltcG9ydCB7IGRpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlLmpzJztcbmNvbnN0IHVudGlscyA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY29uc3QgdW50aWwgPSBkaXJlY3RpdmUoKC4uLnByb21pc2VzKSA9PiAocGFydCkgPT4ge1xuICAgIGlmICghdW50aWxzLmhhcyhwYXJ0KSlcbiAgICAgICAgdW50aWxzLnNldChwYXJ0LCB7IGk6IHByb21pc2VzLmxlbmd0aCB9KTtcbiAgICBjb25zdCBzdGF0ZSA9IHVudGlscy5nZXQocGFydCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAocHJvbWlzZXNbaV0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2l0aHViL25vLXRoZW5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShwcm9taXNlc1tpXSkudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdGF0ZS5pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmkgPSBpO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUGFydChwYXJ0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8PSBzdGF0ZS5pKSB7XG4gICAgICAgICAgICBzdGF0ZS5pID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NQYXJ0KHBhcnQsIHByb21pc2VzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW50aWwuanMubWFwIiwiaW1wb3J0IHsgZGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgTm9kZVRlbXBsYXRlUGFydCB9IGZyb20gJ0BnaXRodWIvdGVtcGxhdGUtcGFydHMnO1xuZXhwb3J0IGNvbnN0IHVuc2FmZUhUTUwgPSBkaXJlY3RpdmUoKHZhbHVlKSA9PiAocGFydCkgPT4ge1xuICAgIGlmICghKHBhcnQgaW5zdGFuY2VvZiBOb2RlVGVtcGxhdGVQYXJ0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSk7XG4gICAgcGFydC5yZXBsYWNlKC4uLmZyYWdtZW50LmNoaWxkTm9kZXMpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnNhZmUtaHRtbC5qcy5tYXAiLCJleHBvcnQgeyBUZW1wbGF0ZVJlc3VsdCwgaHRtbCwgcmVuZGVyIH0gZnJvbSAnLi9odG1sLmpzJztcbmV4cG9ydCB7IGlzRGlyZWN0aXZlLCBkaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZS5qcyc7XG5leHBvcnQgeyB1bnRpbCB9IGZyb20gJy4vdW50aWwuanMnO1xuZXhwb3J0IHsgdW5zYWZlSFRNTCB9IGZyb20gJy4vdW5zYWZlLWh0bWwuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHNldFByb3Aoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLnByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHRoaXMucHJvcHNba2V5XSkge1xuICAgICAgICB0aGlzWydfX3N0YXNoX18nXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXNbJ19fc3Rhc2hfXyddLFxuICAgICAgICAgICAgW2tleV06IHZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0aGVuOiAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3Rhc2ggPSB0aGlzWydfX3N0YXNoX18nXTtcbiAgICAgICAgICAgIGlmIChzdGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Rhc2gsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGFzaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgcCA9IHtcbiAgICByZXEoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB7fSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9wdChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHt9LFxuICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wLmpzLm1hcCIsInZhciBfX3NldEZ1bmN0aW9uTmFtZSA9ICh0aGlzICYmIHRoaXMuX19zZXRGdW5jdGlvbk5hbWUpIHx8IGZ1bmN0aW9uIChmLCBuYW1lLCBwcmVmaXgpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuaW1wb3J0IHsgc2V0UHJvcCB9IGZyb20gJy4vdXRpbHMvcC5qcyc7XG5sZXQgYWN0dWFsRWwgPSB1bmRlZmluZWQ7XG5leHBvcnQgZnVuY3Rpb24gRUcoY29uZmlnKSB7XG4gICAgcmV0dXJuIChmdW5jKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gYnVpbGQoZnVuYywgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5wcm9wcykgfHwge30sIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5tYXBwZXIsIHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLmVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKG5hbWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZnVuY3Rpb24gKF9wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChuZXcudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUVsZW1lbnRzLndoZW5EZWZpbmVkKG5hbWUpLnRoZW4oKCkgPT4gY3VzdG9tRWxlbWVudHMuZ2V0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tcG9uZW50LmFkYXB0ZXIgPSAoZnVuYywgZGVmYXVsdFByb3BzKSA9PiBmdW5jKG5hbWUsIGRlZmF1bHRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZChmdW5jLCBwcm9wcywgbWFwcGVyID0gc2V0UHJvcCwgcmVuZGVyID0gKHJlc3VsdCkgPT4gcmVzdWx0LnZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGN1c3RvbUVsID0gKF9hID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0IHByb3BzKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5wcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0IHByb3BzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jIG5leHQocHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzID0gcHJvcHMgfHwgdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWROZXh0ICYmIHRoaXMuZ2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2VuZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbEVsID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyLmNhbGwodGhpcywgZ2VuZXJhdG9yLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBLIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBWID0gcHJvcHNbcEtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiBwVikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHBWLmF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHBLLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wc1twS107XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXIuYXBwbHkodGhpcywgW3BLLCB2YWx1ZSwgYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGlvbiA9IGZ1bmMuY2FsbCh0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICBhY3R1YWxFbCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVuZGVyLmNhbGwodGhpcywgdGhpcy5nZW5lcmF0aW9uLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbYXR0cktleSwgYXR0ck5hbWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uc3RydWN0b3JbJ2F0dHJpYnV0ZXMnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gbmFtZSAmJiB0aGlzW2F0dHJLZXldICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYXR0cktleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmdlbmVyYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX19zZXRGdW5jdGlvbk5hbWUoX2EsIFwiY3VzdG9tRWxcIiksXG4gICAgICAgIF9hLmF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgICAgX2EpO1xuICAgIGNvbnN0IGF0dHJLZXkgPSAnYXR0cmlidXRlcyc7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFJlZmxlY3QuZ2V0KGN1c3RvbUVsLCBhdHRyS2V5KTtcbiAgICBmb3IgKGNvbnN0IHBLIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHBWID0gcHJvcHNbcEtdO1xuICAgICAgICBpZiAoJ3R5cGUnIGluIHBWICYmIHBWLmF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KGN1c3RvbUVsLCBhdHRyS2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgW3BLXTogcFYuYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21FbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbE5vZGUobm9kZXNTeW1ib2wsIGtleSkge1xuICAgIGxldCBub2RlID0geyBjdXJyZW50OiBudWxsIH07XG4gICAgaWYgKGFjdHVhbEVsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChhY3R1YWxFbFtub2Rlc1N5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgICBhY3R1YWxFbFtub2Rlc1N5bWJvbF0gPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBhY3R1YWxFbFtub2Rlc1N5bWJvbF07XG4gICAgaWYgKG5vZGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBub2Rlc1trZXldID0gbm9kZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGVzW2tleV07XG4gICAgcmV0dXJuIG5vZGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FRy5qcy5tYXAiLCJpbXBvcnQgeyBzZXRFbE5vZGUgfSBmcm9tICcuL0VHLmpzJztcbmNvbnN0IHJlZjJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBORyhmdW5jKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlbmRlciA9IChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5nZXRSZW5kZXJGbigpLm5vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgocmVzdWx0KSA9PiByZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiAocmVmID0geyBjdXJyZW50OiBudWxsIH0pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZXNTeW1ib2wgPSBTeW1ib2woJ25vZGVzJyk7XG4gICAgICAgIHJldHVybiAocHJvcHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgX3JlZiA9IHByb3BzLmtleSAhPSBudWxsID8gc2V0RWxOb2RlKG5vZGVzU3ltYm9sLCBwcm9wcy5rZXkpIDogcmVmO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByZWYyTm9kZS5nZXQoX3JlZik7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX25vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLl9yZWYsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBpc1NjaGVkdWxlZE5leHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gUmVmbGVjdC5hcHBseShmdW5jLCBfbm9kZSwgW3Byb3BzXSk7XG4gICAgICAgICAgICAgICAgX25vZGUuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgICAgIF9ub2RlLm5leHQgPSBhc3luYyBmdW5jdGlvbiAoX3Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSBfcHJvcHMgfHwgdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2NoZWR1bGVkTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZyA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShnZW5lcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1NjaGVkdWxlZE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZW5kZXIuY2FsbCh7IGNvbnRhaW5lcjogdGhpcyB9LCBnLm5leHQodGhpcy5wcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XG4gICAgICAgICAgICAgICAgcmVmMk5vZGUuc2V0KF9yZWYsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHJlbmRlci5jYWxsKHsgY29udGFpbmVyOiBub2RlIH0sIG5vZGUuZ2VuZXJhdG9yLm5leHQocHJvcHMpKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ORy5qcy5tYXAiLCJpbXBvcnQgeyBFRyB9IGZyb20gJy4vRUcuanMnO1xuaW1wb3J0IHsgTkcgfSBmcm9tICcuL05HLmpzJztcbmV4cG9ydCBjbGFzcyBWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlciA9IF9yZW5kZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IEVHO1xuICAgICAgICB0aGlzLm5vZGUgPSBORztcbiAgICB9XG4gICAgZ2V0UmVuZGVyRm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5qcy5tYXAiLCJleHBvcnQgeyBFRyB9IGZyb20gJy4vRUcuanMnO1xuZXhwb3J0IHsgTkcgfSBmcm9tICcuL05HLmpzJztcbmV4cG9ydCB7IFZpZXcgfSBmcm9tICcuL1ZpZXcuanMnO1xuZXhwb3J0IHsgcCB9IGZyb20gJy4vdXRpbHMvcC5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBWaWV3IH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9nZmNcIjtcbmltcG9ydCB7IGh0bWwsIHJlbmRlciB9IGZyb20gXCJAZ2l0aHViL2p0bWxcIjtcbmltcG9ydCB7IGRpcmVjdGl2ZSB9IGZyb20gXCJAZ2l0aHViL2p0bWwvbGliL2RpcmVjdGl2ZS5qc1wiO1xuaW1wb3J0IHsgcHJvY2Vzc1BhcnQgfSBmcm9tIFwiQGdpdGh1Yi9qdG1sL2xpYi9odG1sLmpzXCI7XG5jb25zdCByZW5kZXJOb2RlRGlyZWN0aXZlID0gZGlyZWN0aXZlKCh0cGwsIHJlZikgPT4gcGFydCA9PiB7XG4gIGlmIChyZWYuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyKHRwbCwgcmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmVmLmN1cnJlbnQgPSBwYXJ0O1xuICBwcm9jZXNzUGFydChwYXJ0LCB0cGwpO1xufSk7XG5mdW5jdGlvbiByZW5kZXJOb2RlKHRwbCwgcmVmKSB7XG4gIGlmIChyZWYuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyKHRwbCwgcmVmLmN1cnJlbnQpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHJlZi5jdXJyZW50ICE9IG51bGwgJiYgXCJ2YWx1ZVwiIGluIHJlZi5jdXJyZW50KSB7XG4gICAgcHJvY2Vzc1BhcnQocmVmLmN1cnJlbnQsIHRwbCk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlck5vZGVEaXJlY3RpdmUodHBsLCByZWYpO1xufVxuZXhwb3J0IGNvbnN0IHZpZXcgPSBuZXcgVmlldyh7XG4gIGVsZW1lbnQocmVzdWx0KSB7XG4gICAgcmVuZGVyKHJlc3VsdC52YWx1ZSA/PyBodG1sYGAsIHRoaXMuY29udGFpbmVyKTtcbiAgfSxcbiAgbm9kZShyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVuZGVyTm9kZShyZXN1bHQudmFsdWUsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxufSk7IiwiZXhwb3J0ICogZnJvbSBcIi4vanRtbC52aWV3LmpzXCI7XG5leHBvcnQgeyBwIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9nZmNcIjsiLCJpbXBvcnQgeyBodG1sIH0gZnJvbSBcIkBnaXRodWIvanRtbFwiO1xuaW1wb3J0IHsgdmlldyB9IGZyb20gXCJAd2ViLWNvbXBhbmlvbnMvanRtbFwiO1xuZXhwb3J0IGNvbnN0IGNvdW50ZXJOb2RlID0gdmlldy5ub2RlKGZ1bmN0aW9uKiAocHJvcHMpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgdGhpcy5uZXh0KCk7IC8vIGp1c3QgZm9yIHRlc3RzXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHByb3BzID0geWllbGQgaHRtbGBcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbmNsaWNrPVwiJHsoKSA9PiB7XG4gICAgICAgIGNvdW50KyssIHRoaXMubmV4dCgpO1xuICAgICAgfX1cIj5cbiAgICAgICAgICAgICR7cHJvcHM/Lm1zZ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8aT4ke2NvdW50fTwvaT5cbiAgICAgICAgYDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY29uc29sZS5sb2coXCJBIENvdW50ZXJOb2RlIHdpdGgganRtbCByZW5kZXIgd2FzIGRpc2Nvbm5lY3RlZFwiKTtcbiAgfVxufSk7IiwiaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJAZ2l0aHViL2p0bWxcIjtcbmltcG9ydCB7IGNvdW50ZXJOb2RlIH0gZnJvbSBcIi4vY291bnRlci5ub2RlXCI7XG5pbXBvcnQgeyB2aWV3LCBwIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9qdG1sXCI7XG5pbXBvcnQgeyBpcyB9IGZyb20gXCJAd2ViLWNvbXBhbmlvbnMvaC90ZW1wbGF0ZVwiO1xuY29uc3QgQ291bnRlck5vZGUgPSBjb3VudGVyTm9kZSgpO1xuY29uc3QgQ291bnRlck5vZGUxID0gY291bnRlck5vZGUoKTtcbmV4cG9ydCBjb25zdCBjb3VudGVyRWxlbWVudCA9IHZpZXcuZWxlbWVudCh7XG4gIHByb3BzOiB7XG4gICAgbXNnOiBwLnJlcSgpXG4gIH1cbn0pKGZ1bmN0aW9uKiAocHJvcHMpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGlzU2hvd2luZ1RlbXBFbCA9IGZhbHNlO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpc1Nob3dpbmdUZW1wRWwgPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuICB9LCAyMDAwKTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcHJvcHMgPSB5aWVsZCBodG1sYDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuXCIgdHlwZT1cImJ1dHRvblwiIG9uY2xpY2s9XCIkeygpID0+IHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9fVwiPlxuICAgICAgICAgICAgICAke3Byb3BzPy5tc2d9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxpPiR7Y291bnR9PC9pPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgJHtDb3VudGVyTm9kZSh7XG4gICAgICAgIGtleTogXCIxXCIsXG4gICAgICAgIG1zZzogXCJDb3VudGVyIE5vZGUgYXMgSlNYIFRhZzFcIlxuICAgICAgfSl9XG5cbiAgICAgICAgICAke0NvdW50ZXJOb2RlKHtcbiAgICAgICAga2V5OiBcIjJcIixcbiAgICAgICAgbXNnOiBcIkNvdW50ZXIgTm9kZSBhcyBKU1ggVGFnMlwiXG4gICAgICB9KX1cblxuICAgICAgICAgICR7Q291bnRlck5vZGUoe1xuICAgICAgICBtc2c6IFwiQ291bnRlciBOb2RlIGFzIEpTWCBUYWczXCJcbiAgICAgIH0pfVxuXG4gICAgICAgICAgJHtpcyhpc1Nob3dpbmdUZW1wRWwsIGh0bWxgJHtDb3VudGVyTm9kZTEoe1xuICAgICAgICBtc2c6IFwiQ291bnRlciBOb2RlIGFzIEpTWCBCeSBjb25kaXRpb25cIlxuICAgICAgfSl9YCl9XG4gICAgICAgIDwvZGl2PmA7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGNvbnNvbGUubG9nKFwiQSBDb3VudGVyRWxlbWVudCB3aXRoIGp0bWwgcmVuZGVyIHdhcyBkaXNjb25uZWN0ZWRcIik7XG4gIH1cbn0pOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbnZhciBfdGVtcGxhdGVPYmplY3Q7XG5pbXBvcnQgeyBodG1sIH0gZnJvbSBcImxpdC1odG1sXCI7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHsgaWYgKCFyYXcpIHsgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTsgfSByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7IHJhdzogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpIH0gfSkpOyB9XG5pbXBvcnQgeyBwIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9nZmNcIjtcbmltcG9ydCB7IGxpdFZpZXcgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2xpdFwiO1xuaW1wb3J0IHsgcmVmLCBjcmVhdGVSZWYgfSBmcm9tIFwibGl0LWh0bWwvZGlyZWN0aXZlcy9yZWYuanNcIjtcbmltcG9ydCBnaEdpc3RDc3MgZnJvbSBcIi4vZ2hHaXN0LmNzc1wiO1xuaW1wb3J0IGdoR2lzdElmcmFtZUNzcyBmcm9tIFwiLi9naEdpc3RJZnJhbWUuY3NzXCI7XG5pbXBvcnQgeyBzZXRTdHlsZSB9IGZyb20gXCJAd2ViLWNvbXBhbmlvbnMvaC9zdHlsZVwiO1xuZXhwb3J0IHZhciBnaEdpc3RFbGVtZW50ID0gbGl0Vmlldy5lbGVtZW50KHtcbiAgcHJvcHM6IHtcbiAgICBzaGFyZWRMaW5rOiBwLnJlcShcImlmcmFtZWlkXCIpXG4gIH1cbn0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwYXJhbXMpIHtcbiAgdmFyIGlmcmFtZVJlZjtcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgc2V0U3R5bGUoZ2hHaXN0Q3NzLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIGlmcmFtZVJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpZnJhbWVFbCA9IGlmcmFtZVJlZi52YWx1ZTtcbiAgICAgICAgICBpZiAoaWZyYW1lRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaWZyYW1lRWxXaW5kb3cgPSBpZnJhbWVFbFtcImNvbnRlbnRXaW5kb3dcIl07XG4gICAgICAgICAgdmFyIGRvYyA9IGlmcmFtZUVsW1wiY29udGVudERvY3VtZW50XCJdIHx8IChpZnJhbWVFbFdpbmRvdyA9PT0gbnVsbCB8fCBpZnJhbWVFbFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWZyYW1lRWxXaW5kb3cuZG9jdW1lbnQpO1xuICAgICAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb2Mub3BlbigpO1xuICAgICAgICAgIGRvYy53cml0ZSggLypodG1sKi9cIlxcbiAgICAgIDxodG1sPlxcbiAgICAgICAgPGJvZHk+XFxuICAgICAgICAgIDxzY3JcIiArIFwiaXB0IHR5cGU9XFxcInRleHQvamF2YXNjcmlwdFxcXCIgc3JjPVxcXCJcIi5jb25jYXQocGFyYW1zLnNoYXJlZExpbmssIFwiLmpzXFxcIj48L3NjXCIpICsgXCJyaXB0PlxcbiAgICAgICAgPC9ib2R5PlxcbiAgICAgIDwvaHRtbD5cXG4gICAgICBcIik7XG4gICAgICAgICAgZG9jLmNsb3NlKCk7XG4gICAgICAgICAgaWYgKGlmcmFtZUVsV2luZG93ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lRWxXaW5kb3cub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFN0eWxlKGdoR2lzdElmcmFtZUNzcywgZG9jLmJvZHkpO1xuICAgICAgICAgICAgaWZyYW1lRWwuc3R5bGUuaGVpZ2h0ID0gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxpZnJhbWUgLnJlZj1cIiwgXCIgc2Nyb2xsaW5nPVxcXCJub1xcXCI+PC9pZnJhbWU+XCJdKSksIHJlZihpZnJhbWVSZWYpKTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcGFyYW1zID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OlxuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgIH1cbiAgfSwgX2NhbGxlZSwgdGhpcyk7XG59KSk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxudmFyIF90ZW1wbGF0ZU9iamVjdDtcbmltcG9ydCB7IGh0bWwgfSBmcm9tIFwibGl0LWh0bWxcIjtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykgeyBpZiAoIXJhdykgeyByYXcgPSBzdHJpbmdzLnNsaWNlKDApOyB9IHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHsgcmF3OiB7IHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdykgfSB9KSk7IH1cbmltcG9ydCB7IGxpdFZpZXcgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2xpdFwiO1xuZXhwb3J0IHZhciBnZXRTdGFydGVkRWxlbWVudCA9IGxpdFZpZXcuZWxlbWVudCgpKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdCB8fCAoX3RlbXBsYXRlT2JqZWN0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBUaGlzIHBhZ2Ugd2lsbCBnaXZlIHlvdSBhbiBpbnRyb2R1Y3Rpb24gdG8gdGhlIHdheSBvZiB1c2luZ1wiLCBcIlxcbiAgICAgICAgICA8Y29kZT53ZWItY29tcGFuaW9uczwvY29kZT4gaW5zaWRlIHNvbWUgcHJvamVjdC5cXG4gICAgICAgIDwvcD5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBPZiBjb3Vyc2UsIHlvdSBjYW4gdXNlIG9ubHkgb25lIGxpYnJhcnkgZnJvbSBhIGxpc3Qgb2YgcGFja2FnZXMgaW5zaWRlXCIsIFwiXFxuICAgICAgICAgIDxjb2RlPndlYi1jb21wYW5pb25zPC9jb2RlPiB0byBzb2x2ZSBhIHNwZWNpZmljIHRhc2suIEJ1dCBoZXJlIHdlIHdpbGxcXG4gICAgICAgICAgc2hvdyB5b3UgPGI+aG93IHRvIGNyZWF0ZSBhbiBhdG9taWMgY29tcG9uZW50PC9iPiB0aGF0IGlzIHRoZSBnZW5lcmFsXFxuICAgICAgICAgIHB1cnBvc2Ugb2YgPGNvZGU+d2ViLWNvbXBhbmlvbnM8L2NvZGU+IHNldCBvZiB0b29scy5cXG4gICAgICAgIDwvcD5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBXZSB3aWxsIHVzZVwiLCBcIlxcbiAgICAgICAgICA8YSBocmVmPVxcXCJodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9saXQtaHRtbFxcXCI+bGl0LWh0bWw8L2E+IGFzIGFcIiwgXCJcXG4gICAgICAgICAgPGNvZGU+cmVuZGVyPC9jb2RlPiBiZWNhdXNlIGl0J3MgYSByb2J1c3QgYW5kIGhhcyBhIGdvb2Qgc3VwcG9ydFxcbiAgICAgICAgICBpbnNpZGUgPGNvZGU+d2ViLWNvbXBhbmlvbnM8L2NvZGU+LiBBZGRpdGlvbmFsbHksIGZvciBiZXR0ZXIgRFgsIHdlXFxuICAgICAgICAgIHdpbGwgc2V0IHVwXCIsIFwiXFxuICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9zdW1iYWQvYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1qc3gtdG8tdHRcXFwiPlxcbiAgICAgICAgICAgIGJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tanN4LXRvLXR0XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgLiBUaGlzIDxjb2RlPmJhYmVsPC9jb2RlPiBwbHVnaW4gYWxsb3dzIHVzIHRvIHdyaXRlIHRlbXBsYXRlcyB3aXRoXCIsIFwiXFxuICAgICAgICAgIDxjb2RlPkpTWDwvY29kZT4gaW5zdGVhZCBvZiB1c2luZyBUYWdnZWQgVGVtcGxhdGUgTGl0ZXJhbHMgZGlyZWN0bHkuXFxuICAgICAgICAgIEZvciBkZW1vbnN0cmF0aW9uIGdvYWwsIHdlIHdpbGwgdXNlXCIsIFwiXFxuICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vd2VicGFjay5qcy5vcmcvXFxcIj53ZWJwYWNrPC9hPi4gQnV0IG9mIGNvdXJzZSwgeW91IGNhblxcbiAgICAgICAgICB1c2UgPGNvZGU+d2ViLWNvbXBhbmlvbnM8L2NvZGU+IHdpdGhvdXQgYnVuZGxpbmcgYXQgYWxsLiBPaywgc28gbGV0J3NcXG4gICAgICAgICAgc3RhcnQgc3RlcCBieSBzdGVwLlxcbiAgICAgICAgPC9wPlxcblxcbiAgICAgICAgPHNlY3Rpb24+XFxuICAgICAgICAgIDxoNT5cXG4gICAgICAgICAgICAxLiBDcmVhdGUgPGNvZGU+bnBtPC9jb2RlPiBwcm9qZWN0IGFuZCBpbnN0YWxsIDxjb2RlPndlYnBhY2s8L2NvZGU+XCIsIFwiXFxuICAgICAgICAgICAgYW5kIDxjb2RlPmJhYmVsPC9jb2RlPjpcXG4gICAgICAgICAgPC9oNT5cXG4gICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICBSdW4gaW4gdGVybWluYWwgbmV4dCBjb21tYW5kc1xcbiAgICAgICAgICAgIDxjb2RlPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9jb2RlPlxcbiAgICAgICAgICA8L3ByZT5cXG4gICAgICAgIDwvc2VjdGlvbj5cXG4gICAgICAgIDxzZWN0aW9uPlxcbiAgICAgICAgICA8aDU+Mi4gU2V0IHVwIHByb2plY3Q6PC9oNT5cXG4gICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICBDcmVhdGUgPGI+d2VicGFjay5jb25maWcuanM8L2I+IGZpbGUgaW5zaWRlIHdjLWdldC1zdGFydGVkIGZvbGRlclxcbiAgICAgICAgICAgIHdpdGggbmV4dCBjb250ZW50XFxuICAgICAgICAgICAgPGNvZGU+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgICAgQ3JlYXRlIDxiPi5iYWJlbHJjLmpzb248L2I+IGZpbGUgaW5zaWRlIHdjLWdldC1zdGFydGVkIGZvbGRlciB3aXRoXFxuICAgICAgICAgICAgbmV4dCBjb250ZW50XFxuICAgICAgICAgICAgPGNvZGU+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgIDwvcHJlPlxcbiAgICAgICAgPC9zZWN0aW9uPlxcbiAgICAgICAgPHNlY3Rpb24+XFxuICAgICAgICAgIDxoNT5cXG4gICAgICAgICAgICAzLiBJbnN0YWxsIDxjb2RlPndlYi1jb21wYW5pb25zPC9jb2RlPlxcbiAgICAgICAgICA8L2g1PlxcbiAgICAgICAgICA8cHJlPlxcbiAgICAgICAgICAgIFJ1biBpbiB0ZXJtaW5hbCBuZXh0IGNvbW1hbmRzXFxuICAgICAgICAgICAgPGNvZGU+XFxuICAgICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgICA8L2NvZGU+XFxuICAgICAgICAgIDwvcHJlPlxcbiAgICAgICAgPC9zZWN0aW9uPlxcbiAgICAgICAgPHNlY3Rpb24+XFxuICAgICAgICAgIDxoNT5cXG4gICAgICAgICAgICA0LiBDcmVhdGUgeW91ciBmaXJzdCA8Y29kZT52aWV3IGNvbXBvbmVudDwvY29kZT5cXG4gICAgICAgICAgPC9oNT5cXG4gICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICBDcmVhdGUgPGI+aW5kZXguaHRtbDwvYj4gZmlsZSBpbnNpZGUgPGI+d2MtZ2V0LXN0YXJ0ZWQvc3JjPC9iPlwiLCBcIlxcbiAgICAgICAgICAgIGZvbGRlciB3aXRoIG5leHQgY29udGVudFxcbiAgICAgICAgICAgIDxjb2RlPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9jb2RlPlxcbiAgICAgICAgICAgIENyZWF0ZSA8Yj5pbmRleC5qc3g8L2I+IGZpbGUgaW5zaWRlIDxiPndjLWdldC1zdGFydGVkL3NyYzwvYj4gZm9sZGVyXFxuICAgICAgICAgICAgd2l0aCBuZXh0IGNvbnRlbnRcXG4gICAgICAgICAgICA8Y29kZT5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvY29kZT5cXG4gICAgICAgICAgPC9wcmU+XFxuICAgICAgICA8L3NlY3Rpb24+XFxuXFxuICAgICAgICA8c2VjdGlvbj5cXG4gICAgICAgICAgPGg1PjUuIFJ1biBwcm9qZWN0IGxvY2FsbHk6PC9oNT5cXG4gICAgICAgICAgPHByZT5cXG4gICAgICAgICAgICBSdW4gaW4gdGVybWluYWwgbmV4dCBjb21tYW5kc1xcbiAgICAgICAgICAgIDxjb2RlPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9jb2RlPlxcbiAgICAgICAgICA8L3ByZT5cXG4gICAgICAgIDwvc2VjdGlvbj5cXG5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBOb3cgeW91IGNhbiBvcGVuIGluIGEgYnJvd3NlciB1cmwgZnJvbSB5b3VyIHRlcm1pbmFsLiBJdCB3aWxsIHNob3cgeW91XFxuICAgICAgICAgIGEgdmVyeSBzaW1wbGUgcGFnZSB3aXRoIG9ubHkgb25lIGJ1dHRvbi5cXG4gICAgICAgIDwvcD5cXG4gICAgICBcIl0pKSwgXCIgXCIsIFwiIFwiLCBcIiBcIiwgXCIgXCIsIFwiIFwiLCBcIiBcIiwgXCIgXCIsIFwiIFwiLCBcIlxcbm1rZGlyIHdjLWdldC1zdGFydGVkXFxuY2Qgd2MtZ2V0LXN0YXJ0ZWRcXG5ucG0gaW5pdCAteVxcbm5wbSBpbnN0YWxsIHdlYnBhY2sgd2VicGFjay1jbGkgd2VicGFjay1kZXYtc2VydmVyIGJhYmVsLWxvYWRlciBAYmFiZWwvY29yZSBAYmFiZWwvcHJlc2V0LWVudiBiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWpzeC10by10dCAtLXNhdmUtZGV2XFxuICAgICAgICAgICAgICBcIiwgXCJcXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgbW9kZTogJ2RldmVsb3BtZW50JyxcXG4gIGVudHJ5OiB7XFxuICAgIGluZGV4OiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnc3JjJywgJ2luZGV4LmpzeCcpLFxcbiAgfSxcXG4gIG91dHB1dDoge1xcbiAgICBwYXRoOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZGlzdCcpLFxcbiAgfSxcXG4gIGRldlNlcnZlcjoge1xcbiAgICBzdGF0aWM6IHtcXG4gICAgICBkaXJlY3Rvcnk6IHBhdGguam9pbihfX2Rpcm5hbWUsICdzcmMnKSxcXG4gICAgfSxcXG4gIH0sXFxuICBtb2R1bGU6IHtcXG4gICAgcnVsZXM6IFtcXG4gICAgICB7XFxuICAgICAgICB0ZXN0OiAvLm0/anMoeD8pJC8sXFxuICAgICAgICBsb2FkZXI6ICdiYWJlbC1sb2FkZXInLFxcbiAgICAgICAgZXhjbHVkZTogL25vZGVfbW9kdWxlcy8sXFxuICAgICAgfSxcXG4gICAgXSxcXG4gIH0sXFxufTtcXG4gICAgICAgICAgICAgIFwiLCBcIlxcbntcXG4gICAgXFxcInByZXNldHNcXFwiOiBbXFxcIkBiYWJlbC9lbnZcXFwiXSxcXG4gICAgXFxcInBsdWdpbnNcXFwiOiBbXFxuICAgICAgW1xcbiAgICAgICAgXFxcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tanN4LXRvLXR0XFxcIixcXG4gICAgICAgIHtcXG4gICAgICAgICAgXFxcInRhZ1xcXCI6IFxcXCJodG1sXFxcIixcXG4gICAgICAgICAgXFxcImltcG9ydFxcXCI6IHtcXG4gICAgICAgICAgICBcXFwibW9kdWxlXFxcIjogXFxcImxpdC1odG1sXFxcIixcXG4gICAgICAgICAgICBcXFwiZXhwb3J0XFxcIjogXFxcImh0bWxcXFwiXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIFxcXCJhdHRyaWJ1dGVzXFxcIjogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIFxcXCJwcmVzZXRcXFwiOiBcXFwibGl0LWh0bWxcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgICAgXVxcbiAgICBdXFxufSAgXFxuICAgICAgICAgICAgICBcIiwgXCJcXG5ucG0gaW5zdGFsbCBAd2ViLWNvbXBhbmlvbnMvbGl0XFxuICAgICAgICAgICAgICBcIiwgXCIgXCIsIFwiXFxuPCFET0NUWVBFIGh0bWw+XFxuPGh0bWwgbGFuZz1cXFwiZW5cXFwiPlxcbiAgPGhlYWQ+XFxuICAgIDxtZXRhIGNoYXJzZXQ9XFxcIlVURi04XFxcIiAvPlxcbiAgICA8bWV0YSBuYW1lPVxcXCJ2aWV3cG9ydFxcXCIgY29udGVudD1cXFwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFxcXCIgLz5cXG4gICAgPHRpdGxlPlVzZSB3ZWItY29tcGFuaW9uczwvdGl0bGU+XFxuICAgIDxzY3JpcHQgdHlwZT1cXFwibW9kdWxlXFxcIiBzcmM9XFxcIi9pbmRleC5qc1xcXCI+PC9zY3JpcHQ+PC9oZWFkPlxcbiAgPC9oZWFkPlxcbiAgPGJvZHk+XFxuICAgIDxhcHAtbWFpbj48L2FwcC1tYWluPlxcbiAgPC9ib2R5PlxcbjwvaHRtbD5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbmltcG9ydCB7IGxpdFZpZXcgfSBmcm9tICdAd2ViLWNvbXBhbmlvbnMvbGl0JztcXG5cXG5saXRWaWV3LmVsZW1lbnQoKShmdW5jdGlvbiogKCkge1xcbiAgbGV0IGNvdW50ZXIgPSAwO1xcblxcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgeWllbGQgKFxcbiAgICAgIDw+XFxuICAgICAgICA8aDE+XFxuICAgICAgICAgIEdldCBzdGFydGVkIHdpdGggPGNvZGU+d2ViLWNvbXBhbmlvbnM8L2NvZGU+XFxuICAgICAgICA8L2gxPlxcblxcbiAgICAgICAgPHA+VGhpcyBpcyBhIHNpbXBsZSBjb3VudGVyLCBwcmVzcyB0aGUgbmV4dCBidXR0b24gdG8gaW5jcmVhc2UgdmFsdWU8L3A+XFxuXFxuICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IHtcXG4gICAgICAgICAgICBjb3VudGVyKyssIHRoaXMubmV4dCgpO1xcbiAgICAgICAgICB9fVxcbiAgICAgICAgPlxcbiAgICAgICAgICBBZGQgKzFcXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAge2NvdW50ZXJ9XFxuICAgICAgPC8+XFxuICAgICk7XFxuICB9XFxufSkoJ2FwcC1tYWluJyk7XFxuICAgICAgICAgICAgICBcIiwgXCJcXG5ucHggd2VicGFjayBzZXJ2ZVxcbiAgICAgICAgICAgICAgXCIpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBfY29udGV4dC5uZXh0ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgfVxuICB9LCBfY2FsbGVlKTtcbn0pKTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG52YXIgX3RlbXBsYXRlT2JqZWN0O1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJsaXQtaHRtbFwiO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTsgfVxuaW1wb3J0IHsgbGl0VmlldyB9IGZyb20gXCJAd2ViLWNvbXBhbmlvbnMvbGl0XCI7XG5leHBvcnQgdmFyIGludHJvZHVjdGlvbkVsZW1lbnQgPSBsaXRWaWV3LmVsZW1lbnQoKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgICA8aDU+XFxuICAgICAgICAgIFdlbGNvbWUgdG8gdGhlIDxjb2RlPndlYi1jb21wYW5pb25zPC9jb2RlPiBkb2N1bWVudGF0aW9uIVxcbiAgICAgICAgPC9oNT5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBBdCBpdHMgY29yZSwgPGNvZGU+d2ViLWNvbXBhbmlvbnM8L2NvZGU+IGlzIGEgc2V0IG9mIHRvb2xzIHRvIHNpbXBsaWZ5XFxuICAgICAgICAgIHRoZSB3ZWIgZGV2ZWxvcG1lbnQgcHJvY2VzcyB3aXRoXCIsIFwiXFxuICAgICAgICAgIDxiPlxcbiAgICAgICAgICAgIGNvbmNlbnRyYXRpb24gb24gY3JlYXRpbmcgYXRvbWljIHZpZXcgY29tcG9uZW50cyB1c2luZyBXZWJcXG4gICAgICAgICAgICBTcGVjaWZpY2F0aW9uc1xcbiAgICAgICAgICA8L2I+XFxuICAgICAgICAgIC5cXG4gICAgICAgIDwvcD5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBUaGVzZSBsaWJyYXJpZXMgYXJlIG5vdCBhIGZyYW1ld29yayBhbmQgbm90IG5lZWQgdG8gbGVhcm4gaXRcXG4gICAgICAgICAgc2VwYXJhdGVseS4gSXQncyBsaWtlIDxjb2RlPmlubmVySHRtbDwvY29kZT4sIGJ1dCB3aXRoIGhlbHBlcnMgYW5kXFxuICAgICAgICAgIHdyYXBwZXJzIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHVzZSBXZWIgU3BlY2lmaWNhdGlvbnMgYW5kIHBlcmZvcm1cXG4gICAgICAgICAgc2ltcGxlLCBzdHJhaWdodGZvcndhcmQgdGFza3M6XFxuICAgICAgICA8L3A+XFxuICAgICAgICA8dWw+XFxuICAgICAgICAgIDxsaT5Xcml0ZSBuYXRpdmUgVUkgY29tcG9uZW50cyBpbiBhIGNsZWFyIHdheS48L2xpPlxcbiAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgTm8gZXh0cmEga25vd2xlZGdlLiBMZWFybiBsYW5ndWFnZSwgbGVhcm4gc3BlY2lmaWNhdGlvbnMgYW5kXFxuICAgICAgICAgICAgcGxhdGZvcm1zLlxcbiAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICA8bGk+V2l0aG91dCBmcmFtZXdvcmtzIHdpdGggbWluaW11bSBvZiBkZXBlbmRlbmNpZXMuPC9saT5cXG4gICAgICAgIDwvdWw+XFxuXFxuICAgICAgICA8aHI+XFxuICAgICAgICA8aDU+QSBsaXR0bGUgdGhlb3J5PC9oNT5cXG5cXG4gICAgICAgIDxwPkluIGdlbmVyYWwsIGFueSBVSSBjb21wb25lbnQgaGFzIHR3byB0aGluZ3M6PC9wPlxcbiAgICAgICAgPG9sPlxcbiAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgTGlmZWN5Y2xlIFxcdTIwMTMgdG8gY29udHJvbCBob3cgYSBjb21wb25lbnQgd2lsbCBiZSBjcmVhdGVkLCB1cGRhdGVkIGFuZFxcbiAgICAgICAgICAgIGRlc3Ryb3llZC5cXG4gICAgICAgICAgPC9saT5cXG4gICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgIFJlbmRlciBcXHUyMDEzIHRvIHZpc3VhbGx5IHByZXNlbnQgYSBjb21wb25lbnQgaW4gYSBwbGF0Zm9ybSwgZm9yIHdlYiBpdFxcbiAgICAgICAgICAgIHdpbGwgYmUgSFRNTCwgQ1NTLCBTVkcuXFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICA8L29sPlxcblxcbiAgICAgICAgPHByZT5cXG4gICAgICAgICAgPGNvZGU+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvY29kZT5cXG4gICAgICAgIDwvcHJlPlxcblxcbiAgICAgICAgPHA+XFxuICAgICAgICAgIFRvIHNpbXBsaWZ5IHRoZSBkZXZlbG9wbWVudCBwcm9jZXNzIGFuZCBpbmNyZWFzZSBEWCB3ZSBjb21iaW5lZFxcbiAgICAgICAgICBMaWZlY3ljbGUgYW5kIFJlbmRlciBpbnNpZGUgPGNvZGU+dmlldzwvY29kZT4uIEEgPGNvZGU+dmlldzwvY29kZT5cIiwgXCJcXG4gICAgICAgICAgY291bGQgYmUgcmVuZGVyZWQgYXMgYW4gSFRNTCBlbGVtZW50IG9yIGFuIEhUTUwgbm9kZSBpbnNpZGUgYW4gZWxlbWVudFxcbiAgICAgICAgICBpbiBhIHdlYiBwYWdlLiBBbnkgPGNvZGU+dmlldzwvY29kZT4gaXMgYnVpbGRpbmcgb24gdHdvIHBhcnRzOlwiLCBcIlxcbiAgICAgICAgICA8Yj5saWZlY3ljbGUgYW5kIHJlbmRlcjwvYj4uIEluIHR1cm4sIHRoZSBsaWZlY3ljbGUgaXMgYnVpbHQgb25cIiwgXCJcXG4gICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvR2VuZXJhdG9yXFxcIj5cXG4gICAgICAgICAgICBHZW5lcmF0b3JcXG4gICAgICAgICAgPC9hPlwiLCBcIlxcbiAgICAgICAgICBhbmRcIiwgXCJcXG4gICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9jb21wb25lbnRzI2N1c3RvbV9lbGVtZW50c18yXFxcIj5cXG4gICAgICAgICAgICBDdXN0b20gZWxlbWVudHNcXG4gICAgICAgICAgPC9hPlxcbiAgICAgICAgICAuIFRoYXQncyBhbGwhXFxuICAgICAgICA8L3A+XFxuXFxuICAgICAgICA8aHI+XFxuICAgICAgICA8aDU+TW9yZSBkZXRhaWxzPC9oNT5cXG5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBUbyB1c2UgbGlmZWN5Y2xlIGNvbnZlbmllbnQgd2F5LCBpdCB3YXMgd3JhcHBlZCBpbnNpZGVcXG4gICAgICAgICAgPGNvZGU+QHdlYi1jb21wYW5pb25zL2dmYzwvY29kZT4gcGFja2FnZS4gU28gdGhhdCB3ZSBjYW4ganVzdCB3cml0ZSBhXFxuICAgICAgICAgIGdlbmVyYXRvciBmdW5jdGlvbiBmb3IgPGNvZGU+RUc8L2NvZGU+IG9yIDxjb2RlPk5HPC9jb2RlPiBmdW5jdGlvbnMsXFxuICAgICAgICAgIHRoYXQgd2lsbCB1c2UgaXQgaW5zaWRlIGEgY3VzdG9tIGVsZW1lbnQuIEdlbmVyYXRvciBmdW5jdGlvbiBpbiBKUyBpc1xcbiAgICAgICAgICBhIGZ1bmN0aW9uIHRoYXQgY2FuIHJ1biBpdCBwYXJ0IGFuZCByZXR1cm4gdmFsdWVzIHNldmVyYWwgdGltZXNcXG4gICAgICAgICAgd2l0aG91dCByZXJ1biB0aGUgd2hvbGUgZnVuY3Rpb24uIFdlIGNyZWF0ZSBhbiBpbmZpbml0eSBwYXJ0IHRoYXRcXG4gICAgICAgICAgcmVuZGVyIGEgbmV3IEhUTUwgd2l0aCB1cGRhdGVkIHZhbHVlcyBlYWNoIHRpbWUgd2hlbiB3ZSBwcm9kdWNlIHRoZW0uXFxuICAgICAgICA8L3A+XFxuXFxuICAgICAgICA8aW1nIGFsdD1cXFwiV2ViLWNvbXBhbmlvbnMgd29yayBzY2hlbWFcXFwiIHNyYz1cXFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N1bWJhZC93ZWItY29tcGFuaW9ucy9tYXN0ZXIvZG9jL3NjaGVtYS5wbmdcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIj5cXG5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICBObyBtYWdpYywgbm8gY29tcGlsYXRpb25zLCBubyBoYWNrcyBhbmQgaG9va3MuIEFzIHlvdSBjYW4gc2VlLCBpdCdzXFxuICAgICAgICAgIGVhc3kgdG8gcmVwZWF0IHRoZXNlIGxpYnJhcmllcyB1c2luZyBKYXZhU2NyaXB0IGdlbmVyYXRvciBmdW5jdGlvbnNcXG4gICAgICAgICAgYW5kIFdlYiBTcGVjaWZpY2F0aW9ucy5cXG4gICAgICAgIDwvcD5cXG4gICAgICBcIl0pKSwgXCIgXCIsIFwiXFxuPFVJIENvbXBvbmVudD4gPSA8TGlmZWN5Y2xlPiArIDxSZW5kZXI+O1xcblxcbi8vIHdoZXJlOlxcblxcbjxMaWZlY3ljbGU+ID0gQHdlYi1jb21wYW5pb25zL2dmYztcXG5cXG48UmVuZGVyPiA9ICBsaXQtaHRtbCB8IHVodG1sIHwgaHlwZXJIVE1MIHwgQGdpdGh1Yi9qdG1sIHwgPGFueSBvdGhlciwgZXZlbiBpbm5lckhUTUwgaWYgeW91IG5lZWQgc29tZXRoaW5nIHZlcnkgc2ltcGxlPjtcXG4gICAgICAgICAgICBcIiwgXCIgXCIsIFwiIFwiLCBcIiBcIiwgXCIgXCIsIFwiIFwiKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgIH1cbiAgfSwgX2NhbGxlZSk7XG59KSk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxudmFyIF90ZW1wbGF0ZU9iamVjdCwgX3RlbXBsYXRlT2JqZWN0MiwgX3RlbXBsYXRlT2JqZWN0MywgX3RlbXBsYXRlT2JqZWN0NCwgX3RlbXBsYXRlT2JqZWN0NSwgX3RlbXBsYXRlT2JqZWN0NiwgX3RlbXBsYXRlT2JqZWN0NywgX3RlbXBsYXRlT2JqZWN0OCwgX3RlbXBsYXRlT2JqZWN0OSwgX3RlbXBsYXRlT2JqZWN0MTAsIF90ZW1wbGF0ZU9iamVjdDExLCBfdGVtcGxhdGVPYmplY3QxMiwgX3RlbXBsYXRlT2JqZWN0MTMsIF90ZW1wbGF0ZU9iamVjdDE0LCBfdGVtcGxhdGVPYmplY3QxNSwgX3RlbXBsYXRlT2JqZWN0MTYsIF90ZW1wbGF0ZU9iamVjdDE3LCBfdGVtcGxhdGVPYmplY3QxOCwgX3RlbXBsYXRlT2JqZWN0MTksIF90ZW1wbGF0ZU9iamVjdDIwO1xuaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJsaXQtaHRtbFwiO1xuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgXCJ1c2Ugc3RyaWN0XCI7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHsgaWYgKCFyYXcpIHsgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTsgfSByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7IHJhdzogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpIH0gfSkpOyB9XG5pbXBvcnQgeyBwIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9nZmNcIjtcbmltcG9ydCB7IGxpdFZpZXcgfSBmcm9tIFwiQHdlYi1jb21wYW5pb25zL2xpdFwiO1xuaW1wb3J0IHsgY291bnRlckVsZW1lbnQgYXMgY291bnRlckxpdEVsZW1lbnQgfSBmcm9tIFwiLi4vY291bnRlci1saXQvY291bnRlci5lbGVtZW50XCI7XG5pbXBvcnQgeyBjb3VudGVyRWxlbWVudCBhcyBjb3VudGVySnRtbEVsZW1lbnQgfSBmcm9tIFwiLi4vY291bnRlci1qdG1sL2NvdW50ZXIuZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2hHaXN0RWxlbWVudCB9IGZyb20gXCIuLi9naC1naXN0L2doR2lzdC5lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXRTdGFydGVkRWxlbWVudCB9IGZyb20gXCIuLi9nZXQtc3RhcnRlZC9nZXRTdGFydGVkLmVsZW1lbnRcIjtcbmltcG9ydCB7IGlzIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9oL3RlbXBsYXRlXCI7XG5pbXBvcnQgeyBpbnRyb2R1Y3Rpb25FbGVtZW50IH0gZnJvbSAnLi4vaW50cm9kdWN0aW9uL0ludHJvZHVjdGlvbi5lbGVtZW50JztcbnZhciBDb3VudGVySnRtbEVsZW1lbnQgPSBjb3VudGVySnRtbEVsZW1lbnQoXCJkZW1vLWNvdW50ZXItanRtbFwiKTtcbnZhciBDb3VudGVyTGl0RWxlbWVudCA9IGNvdW50ZXJMaXRFbGVtZW50KFwiZGVtby1jb3VudGVyLWxpdFwiKTtcbnZhciBHaEdpc3RFbGVtZW50ID0gZ2hHaXN0RWxlbWVudChcImRlbW8tZ2gtZ2lzdFwiKTtcbnZhciBHZXRTdGFydGVkRWxlbWVudCA9IGdldFN0YXJ0ZWRFbGVtZW50KFwiZ2V0LXN0YXJ0ZWRcIik7XG52YXIgSW50cm9kdWN0aW9uRWxlbWVudCA9IGludHJvZHVjdGlvbkVsZW1lbnQoXCJjb21wYW5pb25zLWludHJvZHVjdGlvblwiKTtcbmV4cG9ydCB2YXIgcGFnZUNvbnRlbnRFbGVtZW50ID0gbGl0Vmlldy5lbGVtZW50KHtcbiAgcHJvcHM6IHtcbiAgICBhY3RpdmVQYWdlOiBwLnJlcSgpXG4gIH1cbn0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwYXJhbXMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIGRlbW8sIHNlbGVjdGVkSXRlbSwgaGFuZGxlU2VsZWN0ZWRJdGVtLCBNZW51VGVtcGxhdGVSZW5kZXJzLCBfZGVtbyRtZW51LCBfZGVtbywgX2RlbW8kZ2lzdHMsIF9kZW1vMjtcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZGVtbyA9IHtcbiAgICAgICAgICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QgfHwgKF90ZW1wbGF0ZU9iamVjdCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXCJdKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udGVudDogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDIgfHwgKF90ZW1wbGF0ZU9iamVjdDIgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlwiXSkpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1lbnU6IGZ1bmN0aW9uIG1lbnUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QzIHx8IChfdGVtcGxhdGVPYmplY3QzID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcIl0pKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnaXN0czogZnVuY3Rpb24gZ2lzdHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3Q0IHx8IChfdGVtcGxhdGVPYmplY3Q0ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcIl0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICBoYW5kbGVTZWxlY3RlZEl0ZW0gPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZEl0ZW0oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgX3RoaXMubmV4dCgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIE1lbnVUZW1wbGF0ZVJlbmRlcnMgPSBmdW5jdGlvbiBNZW51VGVtcGxhdGVSZW5kZXJzKCkge1xuICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDUgfHwgKF90ZW1wbGF0ZU9iamVjdDUgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxuYXYgY2xhc3M9XFxcIm5hdmJhclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDx1bCBjbGFzcz1cXFwibmF2YmFyLWxpc3RcXFwiPlxcbiAgICAgICAgICA8bGkgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIj5cXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFwibmF2YmFyLWxpbmtcXFwiIEBjbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgICBqdG1sIHJlbmRlclxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFwibmF2YmFyLWxpbmtcXFwiIEBjbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgICBsaXQtaHRtbCByZW5kZXJcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICA8L3VsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L25hdj5cIl0pKSwgaGFuZGxlU2VsZWN0ZWRJdGVtKFwianRtbFwiKSwgaGFuZGxlU2VsZWN0ZWRJdGVtKFwibGl0XCIpKTtcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jb250ZXh0LnQwID0gcGFyYW1zLmFjdGl2ZVBhZ2U7XG4gICAgICAgIF9jb250ZXh0Lm5leHQgPSBfY29udGV4dC50MCA9PT0gXCJpbnRyb2R1Y3Rpb25cIiA/IDggOiBfY29udGV4dC50MCA9PT0gXCJnZXRfc3RhcnRlZFwiID8gMTAgOiBfY29udGV4dC50MCA9PT0gXCJjb3VudGVyXCIgPyAxMiA6IDE1O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgODpcbiAgICAgICAgZGVtbyA9IHtcbiAgICAgICAgICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3Q2IHx8IChfdGVtcGxhdGVPYmplY3Q2ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCI8aDE+XFx1RDgzRVxcdUREMTQgSW50cm9kdWN0aW9uPC9oMT5cIl0pKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0NyB8fCAoX3RlbXBsYXRlT2JqZWN0NyA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGNvbXBhbmlvbnMtaW50cm9kdWN0aW9uPjwvY29tcGFuaW9ucy1pbnRyb2R1Y3Rpb24+XCJdKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDE3KTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIGRlbW8gPSB7XG4gICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0OCB8fCAoX3RlbXBsYXRlT2JqZWN0OCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGgxPlxcdUQ4M0NcXHVERkFDIEdldCBzdGFydGVkPC9oMT5cIl0pKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0OSB8fCAoX3RlbXBsYXRlT2JqZWN0OSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGdldC1zdGFydGVkPjwvZ2V0LXN0YXJ0ZWQ+XCJdKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDE3KTtcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIGRlbW8gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlbW8pLCB7fSwge1xuICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbiB0aXRsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDEwIHx8IChfdGVtcGxhdGVPYmplY3QxMCA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGgyPlxcdTI1QjZcXHVGRTBGIERlbW8uIENvdW50ZXI8L2gyPlwiXSkpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIG1lbnU6IE1lbnVUZW1wbGF0ZVJlbmRlcnMsXG4gICAgICAgICAgY29udGVudDogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDExIHx8IChfdGVtcGxhdGVPYmplY3QxMSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGRlbW8tY291bnRlci1qdG1sIC5tc2c9XCIsIFwiPjwvZGVtby1jb3VudGVyLWp0bWw+XCJdKSksIFwiQ291bnRlciBFbGVtZW50XCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2lzdHM6IGZ1bmN0aW9uIGdpc3RzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0MTIgfHwgKF90ZW1wbGF0ZU9iamVjdDEyID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCI8ZGVtby1naC1naXN0IC5zaGFyZWRMaW5rPVwiLCBcIj48L2RlbW8tZ2gtZ2lzdD5cIl0pKSwgXCJodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdW1iYWQvN2QwZWU2YWQzZjkyODJjZmQzYzk5Y2I2ZGRiZWRjNmJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSA9PT0gXCJsaXRcIikge1xuICAgICAgICAgIGRlbW8uY29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDEzIHx8IChfdGVtcGxhdGVPYmplY3QxMyA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiPGRlbW8tY291bnRlci1saXQgLm1zZz1cIiwgXCI+PC9kZW1vLWNvdW50ZXItbGl0PlwiXSkpLCBcIkNvdW50ZXIgRWxlbWVudFwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRlbW8uZ2lzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QxNCB8fCAoX3RlbXBsYXRlT2JqZWN0MTQgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxkZW1vLWdoLWdpc3QgLnNoYXJlZExpbms9XCIsIFwiPjwvZGVtby1naC1naXN0PlwiXSkpLCBcImh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N1bWJhZC83ZDBlZTZhZDNmOTI4MmNmZDNjOTljYjZkZGJlZGM2YlwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCAxNyk7XG4gICAgICBjYXNlIDE1OlxuICAgICAgICBkZW1vID0ge1xuICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbiB0aXRsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDE1IHx8IChfdGVtcGxhdGVPYmplY3QxNSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXCJdKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udGVudDogZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDE2IHx8IChfdGVtcGxhdGVPYmplY3QxNiA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXCJdKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWVudTogZnVuY3Rpb24gbWVudSgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDE3IHx8IChfdGVtcGxhdGVPYmplY3QxNyA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXCJdKSkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2lzdHM6IGZ1bmN0aW9uIGdpc3RzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0MTggfHwgKF90ZW1wbGF0ZU9iamVjdDE4ID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcIl0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgMTcpO1xuICAgICAgY2FzZSAxNzpcbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICByZXR1cm4gaHRtbChfdGVtcGxhdGVPYmplY3QxOSB8fCAoX3RlbXBsYXRlT2JqZWN0MTkgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxkaXYgY2xhc3M9XFxcInBhZ2UtY29udGVudFxcXCI+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiLCBcIlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgICBcIiwgXCJcXG4gICAgICA8L2Rpdj5cIl0pKSwgZGVtby50aXRsZSgpLCAoX2RlbW8kbWVudSA9IChfZGVtbyA9IGRlbW8pLm1lbnUpID09PSBudWxsIHx8IF9kZW1vJG1lbnUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZW1vJG1lbnUuY2FsbChfZGVtbyksIGRlbW8uY29udGVudCgpLCBpcyhkZW1vLmdpc3RzICE9IG51bGwsIGh0bWwoX3RlbXBsYXRlT2JqZWN0MjAgfHwgKF90ZW1wbGF0ZU9iamVjdDIwID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICAgICAgICA8aHI+XFxuICAgICAgICAgICAgPGhyPlxcbiAgICAgICAgICAgIDxoMz5cXHVEODNEXFx1REVFMFxcdUZFMEYgU291cmNlIGNvZGU8L2gzPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIl0pKSwgKF9kZW1vJGdpc3RzID0gKF9kZW1vMiA9IGRlbW8pLmdpc3RzKSA9PT0gbnVsbCB8fCBfZGVtbyRnaXN0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlbW8kZ2lzdHMuY2FsbChfZGVtbzIpKSkpO1xuICAgICAgY2FzZSAxOTpcbiAgICAgICAgcGFyYW1zID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICB9XG4gIH0sIF9jYWxsZWUpO1xufSkpOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbnZhciBfdGVtcGxhdGVPYmplY3QsIF90ZW1wbGF0ZU9iamVjdDI7XG5pbXBvcnQgeyBodG1sIH0gZnJvbSBcImxpdC1odG1sXCI7XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHsgaWYgKCFyYXcpIHsgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTsgfSByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7IHJhdzogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShyYXcpIH0gfSkpOyB9XG5pbXBvcnQgeyBsaXRWaWV3IH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9saXRcIjtcbmltcG9ydCB7IHNldFN0eWxlIH0gZnJvbSBcIkB3ZWItY29tcGFuaW9ucy9oL3N0eWxlXCI7XG5pbXBvcnQgeyBzaWRlbWVudUVsZW1lbnQgfSBmcm9tIFwiLi92aWV3cy9zaWRlbWVudS9zaWRlbWVudS5lbGVtZW50XCI7XG5pbXBvcnQgbWFpbkNzcyBmcm9tIFwiLi9tYWluLmNzc1wiO1xuaW1wb3J0IHsgcGFnZUNvbnRlbnRFbGVtZW50IH0gZnJvbSBcIi4vdmlld3MvcGFnZS1jb250ZW50L3BhZ2VDb250ZW50LmVsZW1lbnRcIjtcbnZhciBTaWRlbWVudUVsZW1lbnQgPSBzaWRlbWVudUVsZW1lbnQoXCJkZW1vLXNpZGVtZW51XCIpO1xudmFyIFBhZ2VDb250ZW50RWxlbWVudCA9IHBhZ2VDb250ZW50RWxlbWVudChcImRlbW8tcGFnZS1jb250ZW50XCIpO1xudmFyIGdpdEh1Ykljb24gPSBsaXRWaWV3Lm5vZGUoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgcmV0dXJuIGh0bWwoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiBjbGFzcz1cXFwiaWNvbiBpY29uLXRhYmxlciBpY29uLXRhYmxlci1icmFuZC1naXRodWJcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiBzdHJva2Utd2lkdGg9XFxcIjFcXFwiIHN0cm9rZT1cXFwiY3VycmVudENvbG9yXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2UtbGluZWNhcD1cXFwicm91bmRcXFwiIHN0cm9rZS1saW5lam9pbj1cXFwicm91bmRcXFwiPlxcbiAgICAgICAgPHBhdGggc3Ryb2tlPVxcXCJub25lXFxcIiBkPVxcXCJNMCAwaDI0djI0SDB6XFxcIiBmaWxsPVxcXCJub25lXFxcIj48L3BhdGg+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNOSAxOWMtNC4zIDEuNCAtNC4zIC0yLjUgLTYgLTNtMTIgNXYtMy41YzAgLTEgLjEgLTEuNCAtLjUgLTJjMi44IC0uMyA1LjUgLTEuNCA1LjUgLTZhNC42IDQuNiAwIDAgMCAtMS4zIC0zLjJhNC4yIDQuMiAwIDAgMCAtLjEgLTMuMnMtMS4xIC0uMyAtMy41IDEuM2ExMi4zIDEyLjMgMCAwIDAgLTYuMiAwYy0yLjQgLTEuNiAtMy41IC0xLjMgLTMuNSAtMS4zYTQuMiA0LjIgMCAwIDAgLS4xIDMuMmE0LjYgNC42IDAgMCAwIC0xLjMgMy4yYzAgNC42IDIuNyA1LjcgNS41IDZjLS42IC42IC0uNiAxLjIgLS41IDJ2My41XFxcIj48L3BhdGg+XFxuICAgICAgPC9zdmc+XCJdKSkpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBfY29udGV4dC5uZXh0ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgfVxuICB9LCBfY2FsbGVlKTtcbn0pKTtcbnZhciBtZW51ID0ge1xuICBpbnRyb2R1Y3Rpb246IHtcbiAgICBsYWJlbDogXCJJbnRyb2R1Y3Rpb25cIixcbiAgICBjYXRlZ29yeTogdHJ1ZSxcbiAgICBhdmFpbGFibGU6IHRydWVcbiAgfSxcbiAgZ2V0X3N0YXJ0ZWQ6IHtcbiAgICBsYWJlbDogXCJHZXQgc3RhcnRlZFwiLFxuICAgIGNhdGVnb3J5OiB0cnVlLFxuICAgIGF2YWlsYWJsZTogdHJ1ZVxuICB9LFxuICBkZW1vOiB7XG4gICAgbGFiZWw6IFwiRGVtb1wiLFxuICAgIGNhdGVnb3J5OiB0cnVlXG4gIH0sXG4gIGNvdW50ZXI6IHtcbiAgICBsYWJlbDogXCJDb3VudGVyXCIsXG4gICAgcGFyZW50OiBcImRlbW9cIixcbiAgICBhdmFpbGFibGU6IHRydWVcbiAgfVxufTtcbi8qKlxuICogUk9PVCBlbGVtZW50XG4gKi9cbmxpdFZpZXcuZWxlbWVudCgpKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBhY3RpdmVQYWdlLCBvbmNoYW5nZUFjdGl2ZTtcbiAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHNldFN0eWxlKG1haW5Dc3MsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgYWN0aXZlUGFnZSA9IFwiaW50cm9kdWN0aW9uXCI7XG4gICAgICAgIG9uY2hhbmdlQWN0aXZlID0gZnVuY3Rpb24gb25jaGFuZ2VBY3RpdmUoZXZlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kZXRhaWwua2V5KTtcbiAgICAgICAgICBhY3RpdmVQYWdlID0gZXZlbnQuZGV0YWlsLmtleTtcbiAgICAgICAgICBfdGhpcy5uZXh0KCk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgIHJldHVybiBodG1sKF90ZW1wbGF0ZU9iamVjdDIgfHwgKF90ZW1wbGF0ZU9iamVjdDIgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgPGRlbW8tc2lkZW1lbnUgc2VhcmNoUGxhY2Vob2xkZXI9XFxcIlNlYXJjaFxcXCIgLmRhdGE9XCIsIFwiIGFjdGl2ZU1lbnVJdGVtPVxcXCJpbnRyb2R1Y3Rpb25cXFwiIEBjaGFuZ2VBY3RpdmU9XCIsIFwiPlxcbiAgICAgICAgICA8Zm9vdGVyPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9zdW1iYWQvd2ViLWNvbXBhbmlvbnNcXFwiPlxcbiAgICAgICAgICAgICAgXCIsIFwiIHdlYi1jb21wYW5pb25zXFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8L2Zvb3Rlcj5cXG4gICAgICAgIDwvZGVtby1zaWRlbWVudT5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRlbW8tY29udGVudFxcXCI+XFxuICAgICAgICAgIDxkZW1vLXBhZ2UtY29udGVudCAuYWN0aXZlUGFnZT1cIiwgXCI+PC9kZW1vLXBhZ2UtY29udGVudD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIFwiXSkpLCBtZW51LCBvbmNoYW5nZUFjdGl2ZSwgZ2l0SHViSWNvbigpKCksIGFjdGl2ZVBhZ2UpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICB9XG4gIH0sIF9jYWxsZWUyLCB0aGlzKTtcbn0pKShcInd3dy1tYWluXCIpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///216\n')},820:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_skeleton_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(466);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_navbar_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(785);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(417);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_4__);\n// Imports\n\n\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(897), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_skeleton_css__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_navbar_css__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_4___default()(___CSS_LOADER_URL_IMPORT_0___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `@font-face {\n  font-family: Raleway;\n  src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format("truetype-variations");\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n}\n\n.demo-content {\n  padding: 0;\n  margin: 0;\n  height: 100vh;\n  overflow: auto;\n  margin-left: 200px;\n}\n\nfooter {\n  display: flex;\n  height: 100%;\n  flex-direction: column;\n  justify-content: flex-end;\n  padding: 5px;\n}\n\nfooter a {\n    margin-left: 10px;\n    font-weight: 100;\n    text-decoration: unset;\n  }\n\nfooter a svg {\n      vertical-align: bottom;\n    }\n\n.page-content {\n  padding: 20px;\n}`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy9tYWluLmNzcz85NTVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9OT19TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzFdIS4vc2tlbGV0b24uY3NzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8xX19fIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzFdIS4vbmF2YmFyLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMF9fXyA9IG5ldyBVUkwoXCIuLi9wdWJsaWMvZm9udHMvUmFsZXdheS9SYWxld2F5LVZhcmlhYmxlRm9udF93Z2h0LnR0ZlwiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18pO1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18uaShfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzFfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiBSYWxld2F5O1xuICBzcmM6IHVybCgke19fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX199KSBmb3JtYXQoXCJ0cnVldHlwZS12YXJpYXRpb25zXCIpO1xufVxuXG5ib2R5IHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuXG4uZGVtby1jb250ZW50IHtcbiAgcGFkZGluZzogMDtcbiAgbWFyZ2luOiAwO1xuICBoZWlnaHQ6IDEwMHZoO1xuICBvdmVyZmxvdzogYXV0bztcbiAgbWFyZ2luLWxlZnQ6IDIwMHB4O1xufVxuXG5mb290ZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBoZWlnaHQ6IDEwMCU7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gIHBhZGRpbmc6IDVweDtcbn1cblxuZm9vdGVyIGEge1xuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bnNldDtcbiAgfVxuXG5mb290ZXIgYSBzdmcge1xuICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcbiAgICB9XG5cbi5wYWdlLWNvbnRlbnQge1xuICBwYWRkaW5nOiAyMHB4O1xufWAsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///820\n')},785:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.navbar {\n  display: none;\n  margin-bottom: 20px;\n}\n\n/* Larger than tablet */\n\n/* @media (width >= 750px) { */\n\n/* Navbar */\n.navbar + .docs-section {\n  border-top-width: 0;\n}\n\n.navbar,\n.navbar-spacer {\n  display: block;\n  width: 100%;\n  height: 6.5rem;\n  background: #fff;\n  z-index: 99;\n  border-top: 1px solid #eee;\n  border-bottom: 1px solid #eee;\n}\n\n.navbar-spacer {\n  display: none;\n}\n\n.navbar > .container {\n  width: 100%;\n}\n\n.navbar-list {\n  list-style: none;\n  margin-bottom: 0;\n  padding-left: 0;\n  margin-top: 0;\n}\n\n.navbar-item {\n  position: relative;\n  float: left;\n  margin-bottom: 0;\n}\n\n.navbar-link {\n  text-transform: uppercase;\n  font-size: 11px;\n  font-weight: 600;\n  letter-spacing: 0.2rem;\n  margin-right: 35px;\n  text-decoration: none;\n  line-height: 6.5rem;\n  color: #222;\n  cursor: pointer;\n}\n\n.navbar-link.active {\n  color: #33c3f0;\n}\n\n.has-docked-nav .navbar {\n  position: fixed;\n  top: 0;\n  left: 0;\n}\n\n.has-docked-nav .navbar-spacer {\n  display: block;\n}\n\n/* Re-overiding the width 100% declaration to match size of % based container */\n.has-docked-nav .navbar > .container {\n  width: 80%;\n}\n\n/* } */\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL25hdmJhci5jc3M/ODU2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAubmF2YmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcbn1cblxuLyogTGFyZ2VyIHRoYW4gdGFibGV0ICovXG5cbi8qIEBtZWRpYSAod2lkdGggPj0gNzUwcHgpIHsgKi9cblxuLyogTmF2YmFyICovXG4ubmF2YmFyICsgLmRvY3Mtc2VjdGlvbiB7XG4gIGJvcmRlci10b3Atd2lkdGg6IDA7XG59XG5cbi5uYXZiYXIsXG4ubmF2YmFyLXNwYWNlciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiA2LjVyZW07XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIHotaW5kZXg6IDk5O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VlZTtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XG59XG5cbi5uYXZiYXItc3BhY2VyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLm5hdmJhciA+IC5jb250YWluZXIge1xuICB3aWR0aDogMTAwJTtcbn1cblxuLm5hdmJhci1saXN0IHtcbiAgbGlzdC1zdHlsZTogbm9uZTtcbiAgbWFyZ2luLWJvdHRvbTogMDtcbiAgcGFkZGluZy1sZWZ0OiAwO1xuICBtYXJnaW4tdG9wOiAwO1xufVxuXG4ubmF2YmFyLWl0ZW0ge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGZsb2F0OiBsZWZ0O1xuICBtYXJnaW4tYm90dG9tOiAwO1xufVxuXG4ubmF2YmFyLWxpbmsge1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICBmb250LXNpemU6IDExcHg7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIGxldHRlci1zcGFjaW5nOiAwLjJyZW07XG4gIG1hcmdpbi1yaWdodDogMzVweDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICBsaW5lLWhlaWdodDogNi41cmVtO1xuICBjb2xvcjogIzIyMjtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ubmF2YmFyLWxpbmsuYWN0aXZlIHtcbiAgY29sb3I6ICMzM2MzZjA7XG59XG5cbi5oYXMtZG9ja2VkLW5hdiAubmF2YmFyIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG59XG5cbi5oYXMtZG9ja2VkLW5hdiAubmF2YmFyLXNwYWNlciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4vKiBSZS1vdmVyaWRpbmcgdGhlIHdpZHRoIDEwMCUgZGVjbGFyYXRpb24gdG8gbWF0Y2ggc2l6ZSBvZiAlIGJhc2VkIGNvbnRhaW5lciAqL1xuLmhhcy1kb2NrZWQtbmF2IC5uYXZiYXIgPiAuY29udGFpbmVyIHtcbiAgd2lkdGg6IDgwJTtcbn1cblxuLyogfSAqL1xuYCwgXCJcIl0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///785\n')},466:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/*\n* Skeleton V2.0.4\n* Copyright 2014, Dave Gamache\n* www.getskeleton.com\n* Free to use under the MIT license.\n* http://www.opensource.org/licenses/mit-license.php\n* 12/29/2014\n*/\n\n\n/* Table of contents\n\n- Grid\n- Base Styles\n- Typography\n- Links\n- Buttons\n- Forms\n- Lists\n- Code\n- Tables\n- Spacing\n- Utilities\n- Clearing\n- Media Queries\n*/\n\n\n/* Grid\n */\n.container {\n    position: relative;\n    width: 100%;\n    max-width: 960px;\n    margin: 0 auto;\n    padding: 0 20px;\n    box-sizing: border-box; }\n\n  .column,\n  .columns {\n    width: 100%;\n    float: left;\n    box-sizing: border-box; }\n  \n  /* For devices larger than 400px */\n  @media (width >= 400px) {\n    .container {\n      width: 85%;\n      padding: 0; }\n  }\n  \n  /* For devices larger than 550px */\n  @media (width >= 550px) {\n    .container {\n      width: 80%; }\n\n    .column,\n    .columns {\n      margin-left: 4%; }\n\n    .column:first-child,\n    .columns:first-child {\n      margin-left: 0; }\n  \n    .one.column,\n    .one.columns                    { width: 4.66666666667%; }\n    .two.columns                    { width: 13.3333333333%; }\n    .three.columns                  { width: 22%;            }\n    .four.columns                   { width: 30.6666666667%; }\n    .five.columns                   { width: 39.3333333333%; }\n    .six.columns                    { width: 48%;            }\n    .seven.columns                  { width: 56.6666666667%; }\n    .eight.columns                  { width: 65.3333333333%; }\n    .nine.columns                   { width: 74.0%;          }\n    .ten.columns                    { width: 82.6666666667%; }\n    .eleven.columns                 { width: 91.3333333333%; }\n    .twelve.columns                 { width: 100%; margin-left: 0; }\n  \n    .one-third.column               { width: 30.6666666667%; }\n    .two-thirds.column              { width: 65.3333333333%; }\n  \n    .one-half.column                { width: 48%; }\n  \n    /* Offsets */\n    .offset-by-one.column,\n    .offset-by-one.columns          { margin-left: 8.66666666667%; }\n\n    .offset-by-two.column,\n    .offset-by-two.columns          { margin-left: 17.3333333333%; }\n\n    .offset-by-three.column,\n    .offset-by-three.columns        { margin-left: 26%;            }\n\n    .offset-by-four.column,\n    .offset-by-four.columns         { margin-left: 34.6666666667%; }\n\n    .offset-by-five.column,\n    .offset-by-five.columns         { margin-left: 43.3333333333%; }\n\n    .offset-by-six.column,\n    .offset-by-six.columns          { margin-left: 52%;            }\n\n    .offset-by-seven.column,\n    .offset-by-seven.columns        { margin-left: 60.6666666667%; }\n\n    .offset-by-eight.column,\n    .offset-by-eight.columns        { margin-left: 69.3333333333%; }\n\n    .offset-by-nine.column,\n    .offset-by-nine.columns         { margin-left: 78.0%;          }\n\n    .offset-by-ten.column,\n    .offset-by-ten.columns          { margin-left: 86.6666666667%; }\n\n    .offset-by-eleven.column,\n    .offset-by-eleven.columns       { margin-left: 95.3333333333%; }\n  \n    .offset-by-one-third.column,\n    .offset-by-one-third.columns    { margin-left: 34.6666666667%; }\n\n    .offset-by-two-thirds.column,\n    .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }\n  \n    .offset-by-one-half.column,\n    .offset-by-one-half.columns     { margin-left: 52%; }\n  \n  }\n  \n  \n  /* Base Styles\n   */\n\n  /* NOTE\n  html is set to 62.5% so that all the REM measurements throughout Skeleton\n  are based on 10px sizing. So basically 1.5rem = 15px :) */\n  html {\n    font-size: 62.5%; }\n\n  body {\n    font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */\n    line-height: 1.6;\n    font-weight: 400;\n    font-family: Raleway, HelveticaNeue, "Helvetica Neue", Helvetica, Arial, sans-serif;\n    color: #222; }\n  \n  \n  /* Typography\n   */\n  h1, h2, h3, h4, h5, h6 {\n    margin-top: 0;\n    margin-bottom: 2rem;\n    font-weight: 300; }\n  h1 { font-size: 4.0rem; line-height: 1.2;  letter-spacing: -.1rem;}\n  h2 { font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; }\n  h3 { font-size: 3.0rem; line-height: 1.3;  letter-spacing: -.1rem; }\n  h4 { font-size: 2.4rem; line-height: 1.35; letter-spacing: -.08rem; }\n  h5 { font-size: 1.8rem; line-height: 1.5;  letter-spacing: -.05rem; }\n  h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }\n  \n  /* Larger than phablet */\n  @media (width >= 550px) {\n    h1 { font-size: 5.0rem; }\n    h2 { font-size: 4.2rem; }\n    h3 { font-size: 3.6rem; }\n    h4 { font-size: 3.0rem; }\n    h5 { font-size: 2.4rem; }\n    h6 { font-size: 1.5rem; }\n  }\n  \n  p {\n    margin-top: 0; }\n  \n  \n  /* Links\n   */\n  a {\n    color: #1EAEDB; }\n\n  a:hover {\n    color: #0FA0CE; }\n  \n  \n  /* Buttons\n   */\n  .button,\n  button,\n  input[type="submit"],\n  input[type="reset"],\n  input[type="button"] {\n    display: inline-block;\n    height: 38px;\n    padding: 0 30px;\n    color: #555;\n    text-align: center;\n    font-size: 11px;\n    font-weight: 600;\n    line-height: 38px;\n    letter-spacing: .1rem;\n    text-transform: uppercase;\n    text-decoration: none;\n    white-space: nowrap;\n    background-color: transparent;\n    border-radius: 4px;\n    border: 1px solid #bbb;\n    cursor: pointer;\n    box-sizing: border-box; }\n\n  .button:hover,\n  button:hover,\n  input[type="submit"]:hover,\n  input[type="reset"]:hover,\n  input[type="button"]:hover,\n  .button:focus,\n  button:focus,\n  input[type="submit"]:focus,\n  input[type="reset"]:focus,\n  input[type="button"]:focus {\n    color: #333;\n    border-color: #888;\n    outline: 0; }\n\n  .button.button-primary,\n  button.button-primary,\n  input[type="submit"].button-primary,\n  input[type="reset"].button-primary,\n  input[type="button"].button-primary {\n    color: #FFF;\n    background-color: #33C3F0;\n    border-color: #33C3F0; }\n\n  .button.button-primary:hover,\n  button.button-primary:hover,\n  input[type="submit"].button-primary:hover,\n  input[type="reset"].button-primary:hover,\n  input[type="button"].button-primary:hover,\n  .button.button-primary:focus,\n  button.button-primary:focus,\n  input[type="submit"].button-primary:focus,\n  input[type="reset"].button-primary:focus,\n  input[type="button"].button-primary:focus {\n    color: #FFF;\n    background-color: #1EAEDB;\n    border-color: #1EAEDB; }\n  \n  \n  /* Forms\n   */\n  input[type="email"],\n  input[type="number"],\n  input[type="search"],\n  input[type="text"],\n  input[type="tel"],\n  input[type="url"],\n  input[type="password"],\n  textarea,\n  select {\n    height: 38px;\n    padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */\n    background-color: #fff;\n    border: 1px solid #D1D1D1;\n    border-radius: 4px;\n    box-shadow: none;\n    box-sizing: border-box; }\n\n  /* Removes awkward default styles on some inputs for iOS */\n  input[type="email"],\n  input[type="number"],\n  input[type="search"],\n  input[type="text"],\n  input[type="tel"],\n  input[type="url"],\n  input[type="password"],\n  textarea {\n    appearance: none;\n       appearance: none;\n            appearance: none; }\n\n  textarea {\n    min-height: 65px;\n    padding-top: 6px;\n    padding-bottom: 6px; }\n\n  input[type="email"]:focus,\n  input[type="number"]:focus,\n  input[type="search"]:focus,\n  input[type="text"]:focus,\n  input[type="tel"]:focus,\n  input[type="url"]:focus,\n  input[type="password"]:focus,\n  textarea:focus,\n  select:focus {\n    border: 1px solid #33C3F0;\n    outline: 0; }\n\n  label,\n  legend {\n    display: block;\n    margin-bottom: .5rem;\n    font-weight: 600; }\n\n  fieldset {\n    padding: 0;\n    border-width: 0; }\n\n  input[type="checkbox"],\n  input[type="radio"] {\n    display: inline; }\n\n  label > .label-body {\n    display: inline-block;\n    margin-left: .5rem;\n    font-weight: normal; }\n  \n  \n  /* Lists\n   */\n  ul {\n    list-style: circle inside; }\n\n  ol {\n    list-style: decimal inside; }\n\n  ol, ul {\n    padding-left: 0;\n    margin-top: 0; }\n\n  ul ul,\n  ul ol,\n  ol ol,\n  ol ul {\n    margin: 1.5rem 0 1.5rem 3rem;\n    font-size: 90%; }\n\n  li {\n    margin-bottom: 1rem; }\n  \n  \n  /* Code\n   */\n  code {\n    padding: .2rem .5rem;\n    margin: 0 .2rem;\n    font-size: 90%;\n    white-space: nowrap;\n    background: #F1F1F1;\n    border: 1px solid #E1E1E1;\n    border-radius: 4px; }\n\n  pre > code {\n    display: block;\n    padding: 1rem 1.5rem;\n    white-space: pre; }\n  \n  \n  /* Tables\n   */\n  th,\n  td {\n    padding: 12px 15px;\n    text-align: left;\n    border-bottom: 1px solid #E1E1E1; }\n\n  th:first-child,\n  td:first-child {\n    padding-left: 0; }\n\n  th:last-child,\n  td:last-child {\n    padding-right: 0; }\n  \n  \n  /* Spacing\n   */\n  button,\n  .button {\n    margin-bottom: 1rem; }\n\n  input,\n  textarea,\n  select,\n  fieldset {\n    margin-bottom: 1.5rem; }\n\n  pre,\n  blockquote,\n  dl,\n  figure,\n  table,\n  p,\n  ul,\n  ol,\n  form {\n    margin-bottom: 2.5rem; }\n  \n  \n  /* Utilities\n   */\n  .u-full-width {\n    width: 100%;\n    box-sizing: border-box; }\n\n  .u-max-full-width {\n    max-width: 100%;\n    box-sizing: border-box; }\n\n  .u-pull-right {\n    float: right; }\n\n  .u-pull-left {\n    float: left; }\n  \n  \n  /* Misc\n   */\n  hr {\n    margin-top: 3rem;\n    margin-bottom: 3.5rem;\n    border-width: 0;\n    border-top: 1px solid #E1E1E1; }\n  \n  \n  /* Clearing\n   */\n  \n  /* Self Clearing Goodness */\n  .container::after,\n  .row::after,\n  .u-cf {\n    content: "";\n    display: table;\n    clear: both; }\n  \n  \n  /* Media Queries\n   */\n\n  /*\n  Note: The best way to structure the use of media queries is to create the queries\n  near the relevant code. For example, if you wanted to change the styles for buttons\n  on small devices, paste the mobile query code up in the buttons section and style it\n  there.\n  */\n  \n  \n  /* Larger than mobile */\n  @media (width >= 400px) {}\n  \n  /* Larger than phablet (also point when grid becomes active) */\n  @media (width >= 550px) {}\n  \n  /* Larger than tablet */\n  @media (width >= 750px) {}\n  \n  /* Larger than desktop */\n  @media (width >= 1000px) {}\n  \n  /* Larger than Desktop HD */\n  @media (width >= 1200px) {}`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDY2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvc2tlbGV0b24uY3NzPzQ1MzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9ub1NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9OT19TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLypcbiogU2tlbGV0b24gVjIuMC40XG4qIENvcHlyaWdodCAyMDE0LCBEYXZlIEdhbWFjaGVcbiogd3d3LmdldHNrZWxldG9uLmNvbVxuKiBGcmVlIHRvIHVzZSB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qIDEyLzI5LzIwMTRcbiovXG5cblxuLyogVGFibGUgb2YgY29udGVudHNcbuKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk1xuLSBHcmlkXG4tIEJhc2UgU3R5bGVzXG4tIFR5cG9ncmFwaHlcbi0gTGlua3Ncbi0gQnV0dG9uc1xuLSBGb3Jtc1xuLSBMaXN0c1xuLSBDb2RlXG4tIFRhYmxlc1xuLSBTcGFjaW5nXG4tIFV0aWxpdGllc1xuLSBDbGVhcmluZ1xuLSBNZWRpYSBRdWVyaWVzXG4qL1xuXG5cbi8qIEdyaWRcbuKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuLmNvbnRhaW5lciB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1heC13aWR0aDogOTYwcHg7XG4gICAgbWFyZ2luOiAwIGF1dG87XG4gICAgcGFkZGluZzogMCAyMHB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cblxuICAuY29sdW1uLFxuICAuY29sdW1ucyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxuICBcbiAgLyogRm9yIGRldmljZXMgbGFyZ2VyIHRoYW4gNDAwcHggKi9cbiAgQG1lZGlhICh3aWR0aCA+PSA0MDBweCkge1xuICAgIC5jb250YWluZXIge1xuICAgICAgd2lkdGg6IDg1JTtcbiAgICAgIHBhZGRpbmc6IDA7IH1cbiAgfVxuICBcbiAgLyogRm9yIGRldmljZXMgbGFyZ2VyIHRoYW4gNTUwcHggKi9cbiAgQG1lZGlhICh3aWR0aCA+PSA1NTBweCkge1xuICAgIC5jb250YWluZXIge1xuICAgICAgd2lkdGg6IDgwJTsgfVxuXG4gICAgLmNvbHVtbixcbiAgICAuY29sdW1ucyB7XG4gICAgICBtYXJnaW4tbGVmdDogNCU7IH1cblxuICAgIC5jb2x1bW46Zmlyc3QtY2hpbGQsXG4gICAgLmNvbHVtbnM6Zmlyc3QtY2hpbGQge1xuICAgICAgbWFyZ2luLWxlZnQ6IDA7IH1cbiAgXG4gICAgLm9uZS5jb2x1bW4sXG4gICAgLm9uZS5jb2x1bW5zICAgICAgICAgICAgICAgICAgICB7IHdpZHRoOiA0LjY2NjY2NjY2NjY3JTsgfVxuICAgIC50d28uY29sdW1ucyAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogMTMuMzMzMzMzMzMzMyU7IH1cbiAgICAudGhyZWUuY29sdW1ucyAgICAgICAgICAgICAgICAgIHsgd2lkdGg6IDIyJTsgICAgICAgICAgICB9XG4gICAgLmZvdXIuY29sdW1ucyAgICAgICAgICAgICAgICAgICB7IHdpZHRoOiAzMC42NjY2NjY2NjY3JTsgfVxuICAgIC5maXZlLmNvbHVtbnMgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogMzkuMzMzMzMzMzMzMyU7IH1cbiAgICAuc2l4LmNvbHVtbnMgICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6IDQ4JTsgICAgICAgICAgICB9XG4gICAgLnNldmVuLmNvbHVtbnMgICAgICAgICAgICAgICAgICB7IHdpZHRoOiA1Ni42NjY2NjY2NjY3JTsgfVxuICAgIC5laWdodC5jb2x1bW5zICAgICAgICAgICAgICAgICAgeyB3aWR0aDogNjUuMzMzMzMzMzMzMyU7IH1cbiAgICAubmluZS5jb2x1bW5zICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6IDc0LjAlOyAgICAgICAgICB9XG4gICAgLnRlbi5jb2x1bW5zICAgICAgICAgICAgICAgICAgICB7IHdpZHRoOiA4Mi42NjY2NjY2NjY3JTsgfVxuICAgIC5lbGV2ZW4uY29sdW1ucyAgICAgICAgICAgICAgICAgeyB3aWR0aDogOTEuMzMzMzMzMzMzMyU7IH1cbiAgICAudHdlbHZlLmNvbHVtbnMgICAgICAgICAgICAgICAgIHsgd2lkdGg6IDEwMCU7IG1hcmdpbi1sZWZ0OiAwOyB9XG4gIFxuICAgIC5vbmUtdGhpcmQuY29sdW1uICAgICAgICAgICAgICAgeyB3aWR0aDogMzAuNjY2NjY2NjY2NyU7IH1cbiAgICAudHdvLXRoaXJkcy5jb2x1bW4gICAgICAgICAgICAgIHsgd2lkdGg6IDY1LjMzMzMzMzMzMzMlOyB9XG4gIFxuICAgIC5vbmUtaGFsZi5jb2x1bW4gICAgICAgICAgICAgICAgeyB3aWR0aDogNDglOyB9XG4gIFxuICAgIC8qIE9mZnNldHMgKi9cbiAgICAub2Zmc2V0LWJ5LW9uZS5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS1vbmUuY29sdW1ucyAgICAgICAgICB7IG1hcmdpbi1sZWZ0OiA4LjY2NjY2NjY2NjY3JTsgfVxuXG4gICAgLm9mZnNldC1ieS10d28uY29sdW1uLFxuICAgIC5vZmZzZXQtYnktdHdvLmNvbHVtbnMgICAgICAgICAgeyBtYXJnaW4tbGVmdDogMTcuMzMzMzMzMzMzMyU7IH1cblxuICAgIC5vZmZzZXQtYnktdGhyZWUuY29sdW1uLFxuICAgIC5vZmZzZXQtYnktdGhyZWUuY29sdW1ucyAgICAgICAgeyBtYXJnaW4tbGVmdDogMjYlOyAgICAgICAgICAgIH1cblxuICAgIC5vZmZzZXQtYnktZm91ci5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS1mb3VyLmNvbHVtbnMgICAgICAgICB7IG1hcmdpbi1sZWZ0OiAzNC42NjY2NjY2NjY3JTsgfVxuXG4gICAgLm9mZnNldC1ieS1maXZlLmNvbHVtbixcbiAgICAub2Zmc2V0LWJ5LWZpdmUuY29sdW1ucyAgICAgICAgIHsgbWFyZ2luLWxlZnQ6IDQzLjMzMzMzMzMzMzMlOyB9XG5cbiAgICAub2Zmc2V0LWJ5LXNpeC5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS1zaXguY29sdW1ucyAgICAgICAgICB7IG1hcmdpbi1sZWZ0OiA1MiU7ICAgICAgICAgICAgfVxuXG4gICAgLm9mZnNldC1ieS1zZXZlbi5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS1zZXZlbi5jb2x1bW5zICAgICAgICB7IG1hcmdpbi1sZWZ0OiA2MC42NjY2NjY2NjY3JTsgfVxuXG4gICAgLm9mZnNldC1ieS1laWdodC5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS1laWdodC5jb2x1bW5zICAgICAgICB7IG1hcmdpbi1sZWZ0OiA2OS4zMzMzMzMzMzMzJTsgfVxuXG4gICAgLm9mZnNldC1ieS1uaW5lLmNvbHVtbixcbiAgICAub2Zmc2V0LWJ5LW5pbmUuY29sdW1ucyAgICAgICAgIHsgbWFyZ2luLWxlZnQ6IDc4LjAlOyAgICAgICAgICB9XG5cbiAgICAub2Zmc2V0LWJ5LXRlbi5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS10ZW4uY29sdW1ucyAgICAgICAgICB7IG1hcmdpbi1sZWZ0OiA4Ni42NjY2NjY2NjY3JTsgfVxuXG4gICAgLm9mZnNldC1ieS1lbGV2ZW4uY29sdW1uLFxuICAgIC5vZmZzZXQtYnktZWxldmVuLmNvbHVtbnMgICAgICAgeyBtYXJnaW4tbGVmdDogOTUuMzMzMzMzMzMzMyU7IH1cbiAgXG4gICAgLm9mZnNldC1ieS1vbmUtdGhpcmQuY29sdW1uLFxuICAgIC5vZmZzZXQtYnktb25lLXRoaXJkLmNvbHVtbnMgICAgeyBtYXJnaW4tbGVmdDogMzQuNjY2NjY2NjY2NyU7IH1cblxuICAgIC5vZmZzZXQtYnktdHdvLXRoaXJkcy5jb2x1bW4sXG4gICAgLm9mZnNldC1ieS10d28tdGhpcmRzLmNvbHVtbnMgICB7IG1hcmdpbi1sZWZ0OiA2OS4zMzMzMzMzMzMzJTsgfVxuICBcbiAgICAub2Zmc2V0LWJ5LW9uZS1oYWxmLmNvbHVtbixcbiAgICAub2Zmc2V0LWJ5LW9uZS1oYWxmLmNvbHVtbnMgICAgIHsgbWFyZ2luLWxlZnQ6IDUyJTsgfVxuICBcbiAgfVxuICBcbiAgXG4gIC8qIEJhc2UgU3R5bGVzXG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuXG4gIC8qIE5PVEVcbiAgaHRtbCBpcyBzZXQgdG8gNjIuNSUgc28gdGhhdCBhbGwgdGhlIFJFTSBtZWFzdXJlbWVudHMgdGhyb3VnaG91dCBTa2VsZXRvblxuICBhcmUgYmFzZWQgb24gMTBweCBzaXppbmcuIFNvIGJhc2ljYWxseSAxLjVyZW0gPSAxNXB4IDopICovXG4gIGh0bWwge1xuICAgIGZvbnQtc2l6ZTogNjIuNSU7IH1cblxuICBib2R5IHtcbiAgICBmb250LXNpemU6IDEuNWVtOyAvKiBjdXJyZW50bHkgZW1zIGNhdXNlIGNocm9tZSBidWcgbWlzaW50ZXJwcmV0aW5nIHJlbXMgb24gYm9keSBlbGVtZW50ICovXG4gICAgbGluZS1oZWlnaHQ6IDEuNjtcbiAgICBmb250LXdlaWdodDogNDAwO1xuICAgIGZvbnQtZmFtaWx5OiBSYWxld2F5LCBIZWx2ZXRpY2FOZXVlLCBcIkhlbHZldGljYSBOZXVlXCIsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgY29sb3I6ICMyMjI7IH1cbiAgXG4gIFxuICAvKiBUeXBvZ3JhcGh5XG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuICBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2IHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XG4gICAgZm9udC13ZWlnaHQ6IDMwMDsgfVxuICBoMSB7IGZvbnQtc2l6ZTogNC4wcmVtOyBsaW5lLWhlaWdodDogMS4yOyAgbGV0dGVyLXNwYWNpbmc6IC0uMXJlbTt9XG4gIGgyIHsgZm9udC1zaXplOiAzLjZyZW07IGxpbmUtaGVpZ2h0OiAxLjI1OyBsZXR0ZXItc3BhY2luZzogLS4xcmVtOyB9XG4gIGgzIHsgZm9udC1zaXplOiAzLjByZW07IGxpbmUtaGVpZ2h0OiAxLjM7ICBsZXR0ZXItc3BhY2luZzogLS4xcmVtOyB9XG4gIGg0IHsgZm9udC1zaXplOiAyLjRyZW07IGxpbmUtaGVpZ2h0OiAxLjM1OyBsZXR0ZXItc3BhY2luZzogLS4wOHJlbTsgfVxuICBoNSB7IGZvbnQtc2l6ZTogMS44cmVtOyBsaW5lLWhlaWdodDogMS41OyAgbGV0dGVyLXNwYWNpbmc6IC0uMDVyZW07IH1cbiAgaDYgeyBmb250LXNpemU6IDEuNXJlbTsgbGluZS1oZWlnaHQ6IDEuNjsgIGxldHRlci1zcGFjaW5nOiAwOyB9XG4gIFxuICAvKiBMYXJnZXIgdGhhbiBwaGFibGV0ICovXG4gIEBtZWRpYSAod2lkdGggPj0gNTUwcHgpIHtcbiAgICBoMSB7IGZvbnQtc2l6ZTogNS4wcmVtOyB9XG4gICAgaDIgeyBmb250LXNpemU6IDQuMnJlbTsgfVxuICAgIGgzIHsgZm9udC1zaXplOiAzLjZyZW07IH1cbiAgICBoNCB7IGZvbnQtc2l6ZTogMy4wcmVtOyB9XG4gICAgaDUgeyBmb250LXNpemU6IDIuNHJlbTsgfVxuICAgIGg2IHsgZm9udC1zaXplOiAxLjVyZW07IH1cbiAgfVxuICBcbiAgcCB7XG4gICAgbWFyZ2luLXRvcDogMDsgfVxuICBcbiAgXG4gIC8qIExpbmtzXG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuICBhIHtcbiAgICBjb2xvcjogIzFFQUVEQjsgfVxuXG4gIGE6aG92ZXIge1xuICAgIGNvbG9yOiAjMEZBMENFOyB9XG4gIFxuICBcbiAgLyogQnV0dG9uc1xuICDigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJMgKi9cbiAgLmJ1dHRvbixcbiAgYnV0dG9uLFxuICBpbnB1dFt0eXBlPVwic3VibWl0XCJdLFxuICBpbnB1dFt0eXBlPVwicmVzZXRcIl0sXG4gIGlucHV0W3R5cGU9XCJidXR0b25cIl0ge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBoZWlnaHQ6IDM4cHg7XG4gICAgcGFkZGluZzogMCAzMHB4O1xuICAgIGNvbG9yOiAjNTU1O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXNpemU6IDExcHg7XG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICBsaW5lLWhlaWdodDogMzhweDtcbiAgICBsZXR0ZXItc3BhY2luZzogLjFyZW07XG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2JiYjtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxuXG4gIC5idXR0b246aG92ZXIsXG4gIGJ1dHRvbjpob3ZlcixcbiAgaW5wdXRbdHlwZT1cInN1Ym1pdFwiXTpob3ZlcixcbiAgaW5wdXRbdHlwZT1cInJlc2V0XCJdOmhvdmVyLFxuICBpbnB1dFt0eXBlPVwiYnV0dG9uXCJdOmhvdmVyLFxuICAuYnV0dG9uOmZvY3VzLFxuICBidXR0b246Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJzdWJtaXRcIl06Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJyZXNldFwiXTpmb2N1cyxcbiAgaW5wdXRbdHlwZT1cImJ1dHRvblwiXTpmb2N1cyB7XG4gICAgY29sb3I6ICMzMzM7XG4gICAgYm9yZGVyLWNvbG9yOiAjODg4O1xuICAgIG91dGxpbmU6IDA7IH1cblxuICAuYnV0dG9uLmJ1dHRvbi1wcmltYXJ5LFxuICBidXR0b24uYnV0dG9uLXByaW1hcnksXG4gIGlucHV0W3R5cGU9XCJzdWJtaXRcIl0uYnV0dG9uLXByaW1hcnksXG4gIGlucHV0W3R5cGU9XCJyZXNldFwiXS5idXR0b24tcHJpbWFyeSxcbiAgaW5wdXRbdHlwZT1cImJ1dHRvblwiXS5idXR0b24tcHJpbWFyeSB7XG4gICAgY29sb3I6ICNGRkY7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzMzQzNGMDtcbiAgICBib3JkZXItY29sb3I6ICMzM0MzRjA7IH1cblxuICAuYnV0dG9uLmJ1dHRvbi1wcmltYXJ5OmhvdmVyLFxuICBidXR0b24uYnV0dG9uLXByaW1hcnk6aG92ZXIsXG4gIGlucHV0W3R5cGU9XCJzdWJtaXRcIl0uYnV0dG9uLXByaW1hcnk6aG92ZXIsXG4gIGlucHV0W3R5cGU9XCJyZXNldFwiXS5idXR0b24tcHJpbWFyeTpob3ZlcixcbiAgaW5wdXRbdHlwZT1cImJ1dHRvblwiXS5idXR0b24tcHJpbWFyeTpob3ZlcixcbiAgLmJ1dHRvbi5idXR0b24tcHJpbWFyeTpmb2N1cyxcbiAgYnV0dG9uLmJ1dHRvbi1wcmltYXJ5OmZvY3VzLFxuICBpbnB1dFt0eXBlPVwic3VibWl0XCJdLmJ1dHRvbi1wcmltYXJ5OmZvY3VzLFxuICBpbnB1dFt0eXBlPVwicmVzZXRcIl0uYnV0dG9uLXByaW1hcnk6Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJidXR0b25cIl0uYnV0dG9uLXByaW1hcnk6Zm9jdXMge1xuICAgIGNvbG9yOiAjRkZGO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMxRUFFREI7XG4gICAgYm9yZGVyLWNvbG9yOiAjMUVBRURCOyB9XG4gIFxuICBcbiAgLyogRm9ybXNcbiAg4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCTICovXG4gIGlucHV0W3R5cGU9XCJlbWFpbFwiXSxcbiAgaW5wdXRbdHlwZT1cIm51bWJlclwiXSxcbiAgaW5wdXRbdHlwZT1cInNlYXJjaFwiXSxcbiAgaW5wdXRbdHlwZT1cInRleHRcIl0sXG4gIGlucHV0W3R5cGU9XCJ0ZWxcIl0sXG4gIGlucHV0W3R5cGU9XCJ1cmxcIl0sXG4gIGlucHV0W3R5cGU9XCJwYXNzd29yZFwiXSxcbiAgdGV4dGFyZWEsXG4gIHNlbGVjdCB7XG4gICAgaGVpZ2h0OiAzOHB4O1xuICAgIHBhZGRpbmc6IDZweCAxMHB4OyAvKiBUaGUgNnB4IHZlcnRpY2FsbHkgY2VudGVycyB0ZXh0IG9uIEZGLCBpZ25vcmVkIGJ5IFdlYmtpdCAqL1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI0QxRDFEMTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XG5cbiAgLyogUmVtb3ZlcyBhd2t3YXJkIGRlZmF1bHQgc3R5bGVzIG9uIHNvbWUgaW5wdXRzIGZvciBpT1MgKi9cbiAgaW5wdXRbdHlwZT1cImVtYWlsXCJdLFxuICBpbnB1dFt0eXBlPVwibnVtYmVyXCJdLFxuICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdLFxuICBpbnB1dFt0eXBlPVwidGV4dFwiXSxcbiAgaW5wdXRbdHlwZT1cInRlbFwiXSxcbiAgaW5wdXRbdHlwZT1cInVybFwiXSxcbiAgaW5wdXRbdHlwZT1cInBhc3N3b3JkXCJdLFxuICB0ZXh0YXJlYSB7XG4gICAgYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICBhcHBlYXJhbmNlOiBub25lO1xuICAgICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTsgfVxuXG4gIHRleHRhcmVhIHtcbiAgICBtaW4taGVpZ2h0OiA2NXB4O1xuICAgIHBhZGRpbmctdG9wOiA2cHg7XG4gICAgcGFkZGluZy1ib3R0b206IDZweDsgfVxuXG4gIGlucHV0W3R5cGU9XCJlbWFpbFwiXTpmb2N1cyxcbiAgaW5wdXRbdHlwZT1cIm51bWJlclwiXTpmb2N1cyxcbiAgaW5wdXRbdHlwZT1cInNlYXJjaFwiXTpmb2N1cyxcbiAgaW5wdXRbdHlwZT1cInRleHRcIl06Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJ0ZWxcIl06Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJ1cmxcIl06Zm9jdXMsXG4gIGlucHV0W3R5cGU9XCJwYXNzd29yZFwiXTpmb2N1cyxcbiAgdGV4dGFyZWE6Zm9jdXMsXG4gIHNlbGVjdDpmb2N1cyB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzMzQzNGMDtcbiAgICBvdXRsaW5lOiAwOyB9XG5cbiAgbGFiZWwsXG4gIGxlZ2VuZCB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgbWFyZ2luLWJvdHRvbTogLjVyZW07XG4gICAgZm9udC13ZWlnaHQ6IDYwMDsgfVxuXG4gIGZpZWxkc2V0IHtcbiAgICBwYWRkaW5nOiAwO1xuICAgIGJvcmRlci13aWR0aDogMDsgfVxuXG4gIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXSxcbiAgaW5wdXRbdHlwZT1cInJhZGlvXCJdIHtcbiAgICBkaXNwbGF5OiBpbmxpbmU7IH1cblxuICBsYWJlbCA+IC5sYWJlbC1ib2R5IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgbWFyZ2luLWxlZnQ6IC41cmVtO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7IH1cbiAgXG4gIFxuICAvKiBMaXN0c1xuICDigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJMgKi9cbiAgdWwge1xuICAgIGxpc3Qtc3R5bGU6IGNpcmNsZSBpbnNpZGU7IH1cblxuICBvbCB7XG4gICAgbGlzdC1zdHlsZTogZGVjaW1hbCBpbnNpZGU7IH1cblxuICBvbCwgdWwge1xuICAgIHBhZGRpbmctbGVmdDogMDtcbiAgICBtYXJnaW4tdG9wOiAwOyB9XG5cbiAgdWwgdWwsXG4gIHVsIG9sLFxuICBvbCBvbCxcbiAgb2wgdWwge1xuICAgIG1hcmdpbjogMS41cmVtIDAgMS41cmVtIDNyZW07XG4gICAgZm9udC1zaXplOiA5MCU7IH1cblxuICBsaSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTsgfVxuICBcbiAgXG4gIC8qIENvZGVcbiAg4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCTICovXG4gIGNvZGUge1xuICAgIHBhZGRpbmc6IC4ycmVtIC41cmVtO1xuICAgIG1hcmdpbjogMCAuMnJlbTtcbiAgICBmb250LXNpemU6IDkwJTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIGJhY2tncm91bmQ6ICNGMUYxRjE7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI0UxRTFFMTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7IH1cblxuICBwcmUgPiBjb2RlIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwYWRkaW5nOiAxcmVtIDEuNXJlbTtcbiAgICB3aGl0ZS1zcGFjZTogcHJlOyB9XG4gIFxuICBcbiAgLyogVGFibGVzXG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuICB0aCxcbiAgdGQge1xuICAgIHBhZGRpbmc6IDEycHggMTVweDtcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjRTFFMUUxOyB9XG5cbiAgdGg6Zmlyc3QtY2hpbGQsXG4gIHRkOmZpcnN0LWNoaWxkIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDA7IH1cblxuICB0aDpsYXN0LWNoaWxkLFxuICB0ZDpsYXN0LWNoaWxkIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwOyB9XG4gIFxuICBcbiAgLyogU3BhY2luZ1xuICDigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJMgKi9cbiAgYnV0dG9uLFxuICAuYnV0dG9uIHtcbiAgICBtYXJnaW4tYm90dG9tOiAxcmVtOyB9XG5cbiAgaW5wdXQsXG4gIHRleHRhcmVhLFxuICBzZWxlY3QsXG4gIGZpZWxkc2V0IHtcbiAgICBtYXJnaW4tYm90dG9tOiAxLjVyZW07IH1cblxuICBwcmUsXG4gIGJsb2NrcXVvdGUsXG4gIGRsLFxuICBmaWd1cmUsXG4gIHRhYmxlLFxuICBwLFxuICB1bCxcbiAgb2wsXG4gIGZvcm0ge1xuICAgIG1hcmdpbi1ib3R0b206IDIuNXJlbTsgfVxuICBcbiAgXG4gIC8qIFV0aWxpdGllc1xuICDigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJPigJMgKi9cbiAgLnUtZnVsbC13aWR0aCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxuXG4gIC51LW1heC1mdWxsLXdpZHRoIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxuXG4gIC51LXB1bGwtcmlnaHQge1xuICAgIGZsb2F0OiByaWdodDsgfVxuXG4gIC51LXB1bGwtbGVmdCB7XG4gICAgZmxvYXQ6IGxlZnQ7IH1cbiAgXG4gIFxuICAvKiBNaXNjXG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuICBociB7XG4gICAgbWFyZ2luLXRvcDogM3JlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAzLjVyZW07XG4gICAgYm9yZGVyLXdpZHRoOiAwO1xuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjRTFFMUUxOyB9XG4gIFxuICBcbiAgLyogQ2xlYXJpbmdcbiAg4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCT4oCTICovXG4gIFxuICAvKiBTZWxmIENsZWFyaW5nIEdvb2RuZXNzICovXG4gIC5jb250YWluZXI6OmFmdGVyLFxuICAucm93OjphZnRlcixcbiAgLnUtY2Yge1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgZGlzcGxheTogdGFibGU7XG4gICAgY2xlYXI6IGJvdGg7IH1cbiAgXG4gIFxuICAvKiBNZWRpYSBRdWVyaWVzXG4gIOKAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAk+KAkyAqL1xuXG4gIC8qXG4gIE5vdGU6IFRoZSBiZXN0IHdheSB0byBzdHJ1Y3R1cmUgdGhlIHVzZSBvZiBtZWRpYSBxdWVyaWVzIGlzIHRvIGNyZWF0ZSB0aGUgcXVlcmllc1xuICBuZWFyIHRoZSByZWxldmFudCBjb2RlLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnRlZCB0byBjaGFuZ2UgdGhlIHN0eWxlcyBmb3IgYnV0dG9uc1xuICBvbiBzbWFsbCBkZXZpY2VzLCBwYXN0ZSB0aGUgbW9iaWxlIHF1ZXJ5IGNvZGUgdXAgaW4gdGhlIGJ1dHRvbnMgc2VjdGlvbiBhbmQgc3R5bGUgaXRcbiAgdGhlcmUuXG4gICovXG4gIFxuICBcbiAgLyogTGFyZ2VyIHRoYW4gbW9iaWxlICovXG4gIEBtZWRpYSAod2lkdGggPj0gNDAwcHgpIHt9XG4gIFxuICAvKiBMYXJnZXIgdGhhbiBwaGFibGV0IChhbHNvIHBvaW50IHdoZW4gZ3JpZCBiZWNvbWVzIGFjdGl2ZSkgKi9cbiAgQG1lZGlhICh3aWR0aCA+PSA1NTBweCkge31cbiAgXG4gIC8qIExhcmdlciB0aGFuIHRhYmxldCAqL1xuICBAbWVkaWEgKHdpZHRoID49IDc1MHB4KSB7fVxuICBcbiAgLyogTGFyZ2VyIHRoYW4gZGVza3RvcCAqL1xuICBAbWVkaWEgKHdpZHRoID49IDEwMDBweCkge31cbiAgXG4gIC8qIExhcmdlciB0aGFuIERlc2t0b3AgSEQgKi9cbiAgQG1lZGlhICh3aWR0aCA+PSAxMjAwcHgpIHt9YCwgXCJcIl0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///466\n')},396:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `iframe {\n  width: 100%;\n  height: 0;\n  border: none;\n}`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL3d3dy9zcmMvdmlld3MvZ2gtZ2lzdC9naEdpc3QuY3NzP2E0MWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9ub1NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9OT19TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgaWZyYW1lIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMDtcbiAgYm9yZGVyOiBub25lO1xufWAsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///396\n')},552:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.gist-meta {\n  pointer-events: none;\n  font-size: 0 !important;\n}\n\n.gist-meta :nth-child(2) {\n    font-size: 12px;\n  }\n\n.gist-data {\n  max-height: 400px;\n}\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL2doLWdpc3QvZ2hHaXN0SWZyYW1lLmNzcz9iMTc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9OT19TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvbm9Tb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC5naXN0LW1ldGEge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgZm9udC1zaXplOiAwICFpbXBvcnRhbnQ7XG59XG5cbi5naXN0LW1ldGEgOm50aC1jaGlsZCgyKSB7XG4gICAgZm9udC1zaXplOiAxMnB4O1xuICB9XG5cbi5naXN0LWRhdGEge1xuICBtYXgtaGVpZ2h0OiA0MDBweDtcbn1cbmAsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///552\n')},663:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.insum-menu-category {\n    transition: all 0.4s;\n\n    /* // input:checked {\n    //   ~.insum-menu-category__link {\n    //     animation: moveout 0.4s, hide 0s infinite;animationanimationanimationanimationanimationanimationanimation\n    //     animation-delay: 0s, 0.4s\n    //animation-delayanimation-delayanimation-delayanimation-delayanimation-delayanimation-delayanimation-delay   }\n    // } */\n  }\n\n  .insum-menu-category input {\n      display: none;\n    }\n\n  .insum-menu-category_hide {\n    max-height: 0;\n    transform: translateX(-50px);\n    opacity: 0;\n  }\n\n  .insum-menu-category__title {\n    display: block; \n    height: 40px;\n    padding-left: 10px;\n    user-select: none;\n    line-height: 40px;\n\n    /* // &:hover {\n    //   cursor: pointer;cursorcursorcursorcursorcursorcursor\n    // } */\n}\n\n.insum-menu-category__link {\n    height: 25px;\n    max-height: 30px;\n    padding-top: 10px;\n    padding-left: 30px;\n    user-select: none;\n    transition: 0.4s all;\n    transform: translateX(0);\n    opacity: 1;\n    font-size: 13px;\n  }\n\n  .insum-menu-category__link_hide {\n    max-height: 0;\n    margin: 0;\n    padding: 0;\n    transform: translateX(-50px);\n    opacity: 0;\n  }\n\n  .insum-menu-category__link_active {\n    font-size: medium;\n    color: var(--insum-sidemenu__font-accent-color);\n  }`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy92aWV3cy9zaWRlbWVudS9zdHlsZXMvaW5zdW0tbWVudS1jYXRlZ29yeS5jc3M/ZDg2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuaW5zdW0tbWVudS1jYXRlZ29yeSB7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNHM7XG5cbiAgICAvKiAvLyBpbnB1dDpjaGVja2VkIHtcbiAgICAvLyAgIH4uaW5zdW0tbWVudS1jYXRlZ29yeV9fbGluayB7XG4gICAgLy8gICAgIGFuaW1hdGlvbjogbW92ZW91dCAwLjRzLCBoaWRlIDBzIGluZmluaXRlO2FuaW1hdGlvbmFuaW1hdGlvbmFuaW1hdGlvbmFuaW1hdGlvbmFuaW1hdGlvbmFuaW1hdGlvbmFuaW1hdGlvblxuICAgIC8vICAgICBhbmltYXRpb24tZGVsYXk6IDBzLCAwLjRzXG4gICAgLy9hbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXlhbmltYXRpb24tZGVsYXkgICB9XG4gICAgLy8gfSAqL1xuICB9XG5cbiAgLmluc3VtLW1lbnUtY2F0ZWdvcnkgaW5wdXQge1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG5cbiAgLmluc3VtLW1lbnUtY2F0ZWdvcnlfaGlkZSB7XG4gICAgbWF4LWhlaWdodDogMDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwcHgpO1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuICAuaW5zdW0tbWVudS1jYXRlZ29yeV9fdGl0bGUge1xuICAgIGRpc3BsYXk6IGJsb2NrOyBcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xuXG4gICAgLyogLy8gJjpob3ZlciB7XG4gICAgLy8gICBjdXJzb3I6IHBvaW50ZXI7Y3Vyc29yY3Vyc29yY3Vyc29yY3Vyc29yY3Vyc29yY3Vyc29yXG4gICAgLy8gfSAqL1xufVxuXG4uaW5zdW0tbWVudS1jYXRlZ29yeV9fbGluayB7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIG1heC1oZWlnaHQ6IDMwcHg7XG4gICAgcGFkZGluZy10b3A6IDEwcHg7XG4gICAgcGFkZGluZy1sZWZ0OiAzMHB4O1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIHRyYW5zaXRpb246IDAuNHMgYWxsO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcbiAgICBvcGFjaXR5OiAxO1xuICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgfVxuXG4gIC5pbnN1bS1tZW51LWNhdGVnb3J5X19saW5rX2hpZGUge1xuICAgIG1heC1oZWlnaHQ6IDA7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MHB4KTtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG5cbiAgLmluc3VtLW1lbnUtY2F0ZWdvcnlfX2xpbmtfYWN0aXZlIHtcbiAgICBmb250LXNpemU6IG1lZGl1bTtcbiAgICBjb2xvcjogdmFyKC0taW5zdW0tc2lkZW1lbnVfX2ZvbnQtYWNjZW50LWNvbG9yKTtcbiAgfWAsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///663\n')},747:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.insum-menu-search {\n  position: relative;\n  display: flex;\n}\n.insum-menu-search .insum-menu-search__icon {\n    position: absolute;\n    left: 10px;\n    width: 20px;\n    line-height: 40px;\n  }\n.insum-menu-search input {\n    width: calc(100% - 50px);\n    height: 40px;\n    padding: 0 10px 0 40px;\n    transition: 0.2s all;\n    color: var(--insum-sidemenu__font-accent-color);\n    border: none;\n    outline: none;\n    background: transparent;\n    font-size: 14px;\n  }\n.insum-menu-search input:focus {\n      border-bottom: 2px solid var(--insum-sidemenu__font-accent-color);\n    }\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi93d3cvc3JjL3ZpZXdzL3NpZGVtZW51L3N0eWxlcy9pbnN1bS1tZW51LXNlYXJjaC5jc3M/ZmIzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuaW5zdW0tbWVudS1zZWFyY2gge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG4uaW5zdW0tbWVudS1zZWFyY2ggLmluc3VtLW1lbnUtc2VhcmNoX19pY29uIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMTBweDtcbiAgICB3aWR0aDogMjBweDtcbiAgICBsaW5lLWhlaWdodDogNDBweDtcbiAgfVxuLmluc3VtLW1lbnUtc2VhcmNoIGlucHV0IHtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gNTBweCk7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIHBhZGRpbmc6IDAgMTBweCAwIDQwcHg7XG4gICAgdHJhbnNpdGlvbjogMC4ycyBhbGw7XG4gICAgY29sb3I6IHZhcigtLWluc3VtLXNpZGVtZW51X19mb250LWFjY2VudC1jb2xvcik7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICB9XG4uaW5zdW0tbWVudS1zZWFyY2ggaW5wdXQ6Zm9jdXMge1xuICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHZhcigtLWluc3VtLXNpZGVtZW51X19mb250LWFjY2VudC1jb2xvcik7XG4gICAgfVxuYCwgXCJcIl0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///747\n')},304:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.insum-menu__title {\n  text-align: center;\n}\n\n.insum-menu-category__title_active {\n  color: var(--insum-sidemenu__font-accent-color);\n}\n\n.insum-menu__sidenav {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n  width: var(--insum-sidemenu__size_width);\n  height: 100%;\n  color: var(--insum-sidemenu__font-main-color);\n  border-radius: var(--insum-sidemenu__border-radius);\n  background: var(--insum-sidemenu__background-color);\n  box-shadow: var(--insum-sidemenu__box-shadow);\n  font-family: var(--insum-sidemenu__font-family);\n}\n`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy92aWV3cy9zaWRlbWVudS9zdHlsZXMvaW5zdW0tbWVudS5jc3M/MjVhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuaW5zdW0tbWVudV9fdGl0bGUge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbi5pbnN1bS1tZW51LWNhdGVnb3J5X190aXRsZV9hY3RpdmUge1xuICBjb2xvcjogdmFyKC0taW5zdW0tc2lkZW1lbnVfX2ZvbnQtYWNjZW50LWNvbG9yKTtcbn1cblxuLmluc3VtLW1lbnVfX3NpZGVuYXYge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgd2lkdGg6IHZhcigtLWluc3VtLXNpZGVtZW51X19zaXplX3dpZHRoKTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBjb2xvcjogdmFyKC0taW5zdW0tc2lkZW1lbnVfX2ZvbnQtbWFpbi1jb2xvcik7XG4gIGJvcmRlci1yYWRpdXM6IHZhcigtLWluc3VtLXNpZGVtZW51X19ib3JkZXItcmFkaXVzKTtcbiAgYmFja2dyb3VuZDogdmFyKC0taW5zdW0tc2lkZW1lbnVfX2JhY2tncm91bmQtY29sb3IpO1xuICBib3gtc2hhZG93OiB2YXIoLS1pbnN1bS1zaWRlbWVudV9fYm94LXNoYWRvdyk7XG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1pbnN1bS1zaWRlbWVudV9fZm9udC1mYW1pbHkpO1xufVxuYCwgXCJcIl0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///304\n')},278:(module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(601);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(304);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_search_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(747);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_category_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(663);\n// Imports\n\n\n\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_css__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_search_css__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A);\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_0_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_insum_menu_category_css__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `:host {\n    --insum-sidemenu__background-color: #222;\n    --insum-sidemenu__font-family: "Ubuntu", sans-serif;\n    --insum-sidemenu__font-main-color: #d9d9d9;\n    --insum-sidemenu__font-accent-color: #fff;\n    --insum-sidemenu__size_width: 200px;\n    --insum-sidemenu__border-radius: 0;\n    --insum-sidemenu__box-shadow: 0 2px 4px rgb(0 0 0 / 25%);\n}\n\n@keyframes moveout {\n  from {\n    transform: translateX(0);\n    opacity: 1;\n  }\n\n  to {\n    transform: translateX(-50px);\n    opacity: 0;\n  }\n}\n\n@keyframes movein {\n  from {\n    transform: translateX(-50px);\n    opacity: 0;\n  }\n\n  to {\n    transform: translateX(0);\n    opacity: 1;\n  }\n}\n\n@keyframes hide {\n  to,\n  from {\n    max-height: 0;\n    transform: translateX(-50px);\n    opacity: 0;\n  }\n}`, ""]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1jb21wYW5pb25zLy4vd3d3L3NyYy92aWV3cy9zaWRlbWVudS9zdHlsZXMvc2lkZW1lbnUuY3NzP2IzM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX05PX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9ub1NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FUX1JVTEVfSU1QT1JUXzBfX18gZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzBdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMV0hLi9pbnN1bS1tZW51LmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVsxXSEuL2luc3VtLW1lbnUtc2VhcmNoLmNzc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVsxXSEuL2luc3VtLW1lbnUtY2F0ZWdvcnkuY3NzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfTk9fU09VUkNFTUFQX0lNUE9SVF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMV9fXyk7XG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5pKF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMl9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYDpob3N0IHtcbiAgICAtLWluc3VtLXNpZGVtZW51X19iYWNrZ3JvdW5kLWNvbG9yOiAjMjIyO1xuICAgIC0taW5zdW0tc2lkZW1lbnVfX2ZvbnQtZmFtaWx5OiBcIlVidW50dVwiLCBzYW5zLXNlcmlmO1xuICAgIC0taW5zdW0tc2lkZW1lbnVfX2ZvbnQtbWFpbi1jb2xvcjogI2Q5ZDlkOTtcbiAgICAtLWluc3VtLXNpZGVtZW51X19mb250LWFjY2VudC1jb2xvcjogI2ZmZjtcbiAgICAtLWluc3VtLXNpZGVtZW51X19zaXplX3dpZHRoOiAyMDBweDtcbiAgICAtLWluc3VtLXNpZGVtZW51X19ib3JkZXItcmFkaXVzOiAwO1xuICAgIC0taW5zdW0tc2lkZW1lbnVfX2JveC1zaGFkb3c6IDAgMnB4IDRweCByZ2IoMCAwIDAgLyAyNSUpO1xufVxuXG5Aa2V5ZnJhbWVzIG1vdmVvdXQge1xuICBmcm9tIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIHRvIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwcHgpO1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbn1cblxuQGtleWZyYW1lcyBtb3ZlaW4ge1xuICBmcm9tIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwcHgpO1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuICB0byB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cbn1cblxuQGtleWZyYW1lcyBoaWRlIHtcbiAgdG8sXG4gIGZyb20ge1xuICAgIG1heC1oZWlnaHQ6IDA7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MHB4KTtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG59YCwgXCJcIl0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///278\n')},314:module=>{eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWNvbXBhbmlvbnMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///314\n')},417:module=>{eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^[\'"].*[\'"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/["\'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return "\\"".concat(url.replace(/"/g, \'\\\\"\').replace(/\\n/g, "\\\\n"), "\\"");\n  }\n  return url;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9nZXRVcmwuanM/MWRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpO1xuXG4gIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9XG5cbiAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICBpZiAoL1tcIicoKSBcXHRcXG5dfCglMjApLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCBcIlxcXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///417\n')},601:module=>{eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItY29tcGFuaW9ucy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9ub1NvdXJjZU1hcHMuanM/MjdjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaSkge1xuICByZXR1cm4gaVsxXTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///601\n")},897:(e,t,n)=>{e.exports=n.p+"e14d84ccec6be3ff19e3.ttf"}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.p="",__webpack_require__.b=document.baseURI||self.location.href;var __webpack_exports__=__webpack_require__(216)})();